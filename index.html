<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Чат-бот Charis</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg-color: #fdeef5;
      --accent-color: #ff7aac;
      --accent-gradient: linear-gradient(135deg, #ff7aac 0%, #ffb6d5 100%);
      --text-color: #E91E63; /* Default pink text color */
      --italic-text-color: #9E9E9E; /* Default light gray for italics */
      --bold-text-color: #E91E63; /* Default pink for bold (as per user, can be same as text-color) */
      --card-bg: #fff8fb;
      --card-bg-rgb: 255, 248, 251; /* RGB for --card-bg */
      --input-bg: #ffe8f2;
      --input-bg-rgb: 255, 232, 242; /* RGB for --input-bg */
      --border-radius: 16px;
      --participant-bg: #fff0f7;
      --participant-active-bg: #ff7aac;
      --shadow: 0 10px 35px 0 rgba(255, 122, 172, 0.15);
      --transition-fast: 0.2s ease-out;
      --transition-normal: 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      --bubble-user: #ffe8f2;
      --bubble-user-rgb: 255, 232, 242;
      --bubble-bot: #f0f8ff;
      --bubble-bot-rgb: 240, 248, 255;
      --bubble-system: #f5f5f5;
      --bubble-system-rgb: 245, 245, 245;
      --bubble-api: #e6fff5;
      --bubble-api-rgb: 230, 255, 245;
      --sidebar-bg: #fff5fa;
      --sidebar-accent: #ff6fa8;
      --sidebar-hover-bg: #ffe0ef;
      --sidebar-active-bg: #ff7aac;
      --button-hover-brightness: 1.08;
      --button-active-scale: 0.97;
      --accent-color-rgb: 255, 122, 172;
      --chat-font-size-multiplier: 1;
      --app-height: 100vh; /* Variable for dynamic viewport height */
      --sidebar-width: 280px;
      --sidebar-width-collapsed: 0px;
    }

    .dark-theme {
      --bg-color: #2c1d27;
      --accent-color: #ff8fbc;
      --accent-gradient: linear-gradient(135deg, #ff8fbc 0%, #ff6099 100%);
      --card-bg: #3b2a36;
      --card-bg-rgb: 59, 42, 54; /* RGB for dark --card-bg */
      --input-bg: #4f3548;
      --input-bg-rgb: 79, 53, 72; /* RGB for dark --input-bg */
      --participant-bg: #5c4055;
      --participant-active-bg: #ff6099;
      --bubble-user: #4f3548;
      --bubble-user-rgb: 79, 53, 72;
      --bubble-bot: #30404f;
      --bubble-bot-rgb: 48, 64, 79;
      --bubble-system: #4a4a4a;
      --bubble-system-rgb: 74, 74, 74;
      --bubble-api: #2a4f40;
      --bubble-api-rgb: 42, 79, 64;
      --sidebar-bg: #3b2a36;
      --sidebar-accent: #ff6099;
      --sidebar-hover-bg: #603050;
      --sidebar-active-bg: #ff6099;
      --shadow: 0 10px 35px 0 rgba(255, 96, 153, 0.3);
      --accent-color-rgb: 255, 143, 188;
    }

    html {
      height: -webkit-fill-available;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Montserrat', 'Segoe UI', sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      width: 100vw;
      overflow: hidden;
      transition: background 0.4s var(--transition-normal), color 0.4s var(--transition-normal);
      scroll-behavior: smooth;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      height: var(--app-height);
      min-height: var(--app-height);
    }

    body {
      display: flex;
      flex-direction: row;
    }

    .hamburger-btn {
        display: none;
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 1005;
        background: var(--accent-gradient);
        border: none;
        border-radius: 50%;
        width: 44px;
        height: 44px;
        cursor: pointer;
        box-shadow: 0 2px 10px rgba(var(--accent-color-rgb),0.3);
        align-items: center;
        justify-content: center;
        padding: 0;
    }
    .hamburger-btn span {
        display: block;
        width: 22px;
        height: 3px;
        background-color: white;
        border-radius: 3px;
        position: relative;
        transition: all 0.3s ease-in-out;
    }
    .hamburger-btn span::before,
    .hamburger-btn span::after {
        content: '';
        position: absolute;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: white;
        border-radius: 3px;
        transition: all 0.3s ease-in-out;
    }
    .hamburger-btn span::before { transform: translateY(-7px); }
    .hamburger-btn span::after { transform: translateY(7px); }

    .hamburger-btn.open span { background-color: transparent; }
    .hamburger-btn.open span::before { transform: rotate(45deg) translateY(0px); }
    .hamburger-btn.open span::after { transform: rotate(-45deg) translateY(0px); }


    .mobile-menu-container {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 280px;
        max-width: 80vw;
        height: var(--app-height);
        background-color: var(--sidebar-bg);
        box-shadow: 3px 0 15px rgba(0,0,0,0.2);
        z-index: 1000;
        transform: translateX(-100%);
        transition: transform 0.3s var(--transition-normal);
        overflow-y: auto;
        flex-direction: column;
    }
    .mobile-menu-container.open {
        transform: translateX(0);
    }
    .mobile-menu-header {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 1rem 1.2rem;
        border-bottom: 1px solid rgba(var(--accent-color-rgb),0.2);
        position: relative;
    }
    .mobile-menu-title {
        font-size: 1.3rem;
        font-weight: 600;
        color: var(--sidebar-accent);
    }
    .close-mobile-menu-btn {
        background: transparent;
        border: none;
        font-size: 2rem;
        color: var(--text-color);
        cursor: pointer;
        padding: 0.2rem;
        line-height: 1;
    }
    .mobile-menu-header .close-mobile-menu-btn {
        display: none;
    }

    #mobileMenuItemsPlaceholder {
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }
    #mobileMenuItemsPlaceholder .sidebar-header {
        text-align: left; padding: 0 0 0.5rem 0; border-bottom: none; font-size: 1.2rem;
    }
    #mobileMenuItemsPlaceholder .chat-list {
        flex-direction: column; gap: 0.5rem; padding: 0; max-height: 250px; overflow-y: auto;
    }
    #mobileMenuItemsPlaceholder .chat-item {
        width: 100%; box-sizing: border-box;
    }

    #mobileMenuItemsPlaceholder #themeToggle,
    #mobileMenuItemsPlaceholder #toggleSettingsBtn {
        position: static;
        width: 100%;
        border-radius: var(--border-radius);
        display: flex !important;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        padding: 0.8rem;
        font-size: 1rem;
    }
     #mobileMenuItemsPlaceholder #themeToggle svg { margin-right: 8px; }

    #mobileMenuItemsPlaceholder #themeToggle:hover,
    #mobileMenuItemsPlaceholder #toggleSettingsBtn:hover {
        transform: scale(1.02);
        filter: brightness(var(--button-hover-brightness));
        box-shadow: 0 4px 12px rgba(var(--accent-color-rgb),0.2);
    }

    #mobileMenuItemsPlaceholder #themeToggle:active,
    #mobileMenuItemsPlaceholder #toggleSettingsBtn:active {
        transform: scale(0.98);
        filter: brightness(0.95);
    }

    #sidebarToggleButton {
        background: var(--accent-gradient);
        color: white;
        border: none;
        cursor: pointer;
        width: 40px;
        height: 40px;
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 1001;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 1.1rem;
        font-weight: bold;
        box-shadow: 0 2px 10px rgba(var(--accent-color-rgb),0.25);
        border-radius: 50%;
        transition: background 0.2s var(--transition-fast), transform 0.2s var(--transition-fast), opacity 0.3s var(--transition-normal), filter 0.2s var(--transition-fast);
    }
    #sidebarToggleButton:hover {
        filter: brightness(var(--button-hover-brightness));
        transform: scale(1.05);
    }
    #sidebarToggleButton:active {
        transform: scale(var(--button-active-scale));
    }


    .sidebar {
      width: var(--sidebar-width);
      background-color: var(--sidebar-bg);
      border-right: 1px solid rgba(var(--accent-color-rgb),0.2);
      display: flex;
      flex-direction: column;
      padding: 1rem 0;
      box-shadow: 3px 0 15px rgba(var(--accent-color-rgb),0.05);
      overflow-y: auto;
      overflow-x: hidden;
      user-select: none;
      transition: width 0.3s var(--transition-normal), background 0.4s var(--transition-normal), border-color 0.4s var(--transition-normal), padding 0.3s var(--transition-normal);
      flex-shrink: 0;
      height: var(--app-height);
      position: sticky;
      top: 0;
    }
    .sidebar.collapsed {
      width: var(--sidebar-width-collapsed);
      padding: 1rem 0;
      border-right-width: 0;
    }
    .sidebar.collapsed .sidebar-header,
    .sidebar.collapsed .chat-list,
    .sidebar.collapsed .sidebar-footer {
        display: none;
    }

    .dark-theme .sidebar {
      border-color: rgba(var(--accent-color-rgb),0.3);
      box-shadow: 3px 0 15px rgba(var(--accent-color-rgb),0.15);
    }
    .sidebar-header {
      font-weight: 700;
      font-size: 1.5rem;
      color: var(--sidebar-accent);
      text-align: center;
      padding: 0 1rem 1.2rem 1rem;
      border-bottom: 1px solid rgba(var(--accent-color-rgb),0.2);
      transition: border-color 0.4s var(--transition-normal), color 0.4s var(--transition-normal);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      letter-spacing: 0.02em;
    }
    .dark-theme .sidebar-header {
      border-bottom: 1px solid rgba(var(--accent-color-rgb),0.3);
    }
    .chat-list {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      padding: 1rem;
    }
    .chat-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1.2rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      background: transparent;
      box-shadow: none;
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast), border-color var(--transition-fast);
      color: var(--text-color);
      position: relative;
      font-weight: 500;
      font-size: 1rem;
      border: 1px solid transparent;
    }
    .chat-item:hover {
      background: var(--sidebar-hover-bg);
      box-shadow: 0 4px 12px rgba(var(--accent-color-rgb),0.1);
      transform: translateX(4px);
      border-color: rgba(var(--accent-color-rgb),0.3);
    }
    .chat-item.active {
      background: var(--sidebar-active-bg);
      color: #fff;
      box-shadow: 0 6px 18px rgba(var(--accent-color-rgb),0.25);
      transform: translateX(0);
      font-weight: 600;
      border-color: transparent;
    }
    .chat-item img {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      flex-shrink: 0;
      transition: border-color 0.4s var(--transition-normal);
    }
    .dark-theme .chat-item img {
      border-color: var(--accent-color);
    }
    .chat-item .chat-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-grow: 1;
    }
    .delete-char-btn {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: transparent;
      border: none;
      color: var(--text-color);
      opacity: 0.6;
      font-weight: 700;
      cursor: pointer;
      font-size: 18px;
      padding: 0;
      line-height: 1;
      transition: color var(--transition-fast), opacity var(--transition-fast);
    }
    .delete-char-btn:hover {
      color: #ff0055;
      opacity: 1;
    }

    .main-content {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      background: var(--bg-color);
      position: relative;
      height: var(--app-height);
      max-height: var(--app-height);
      overflow: hidden;
      transition: background 0.4s var(--transition-normal), width 0.3s var(--transition-normal);
      width: calc(100% - var(--sidebar-width));
    }
    .sidebar.collapsed + .main-content {
        width: calc(100% - var(--sidebar-width-collapsed));
    }


    .chat-container {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      min-height: 0;
      padding: 1rem 0 0.2rem 1.5rem;
      overflow: hidden;
      position: relative;
      background: var(--card-bg);
      transition: background-image 0.4s var(--transition-normal), background-color 0.4s var(--transition-normal), padding 0.4s var(--transition-normal);
    }
    .chat-container.chat-container-custom-bg {
        padding-left: 0px;
        padding-bottom: 0px;
    }


    .toggle-mode {
      margin-bottom: 1.5rem;
      text-align: center;
      user-select: none;
      display: flex;
      justify-content: center;
      gap: 1rem;
      padding: 0.5rem 0;
      flex-shrink: 0;
    }
    .toggle-mode button {
      background: transparent;
      color: var(--accent-color);
      border: 2px solid var(--accent-color);
      padding: 0.6rem 1.8rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: background var(--transition-fast), color var(--transition-fast), box-shadow var(--transition-fast), transform 0.1s ease-out;
      outline: none;
      letter-spacing: 0.01em;
    }
    .toggle-mode button.selected, .toggle-mode button:hover {
      background: var(--accent-gradient);
      color: #fff;
      box-shadow: 0 3px 12px rgba(var(--accent-color-rgb),0.2);
      border-color: transparent;
    }
    .toggle-mode button:active {
      transform: scale(var(--button-active-scale));
      transition-duration: 0.05s;
    }

    #groupParticipants {
      display: none;
      margin-bottom: 1.5rem;
      padding: 0.75rem;
      background: var(--participant-bg);
      border-radius: var(--border-radius);
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05), var(--shadow);
      overflow-x: auto;
      white-space: nowrap;
      user-select: none;
      transition: background 0.4s var(--transition-normal), box-shadow 0.4s var(--transition-normal);
      flex-shrink: 0;
      animation: slideDownFadeIn 0.4s var(--transition-normal) forwards;
    }
    .dark-theme #groupParticipants {
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1), var(--shadow);
    }
    #groupParticipants .participant {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0.5rem 0.8rem;
      border-radius: calc(var(--border-radius) - 4px);
      background: rgba(255,255,255,0.8);
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      margin-right: 0.8rem;
      min-width: 75px;
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
      color: var(--text-color);
      font-weight: 500;
      font-size: 0.9rem;
    }
    .dark-theme #groupParticipants .participant {
      background: rgba(255,255,255,0.1);
    }
    #groupParticipants .participant:hover {
      background: #fff;
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .dark-theme #groupParticipants .participant:hover {
      background: rgba(255,255,255,0.2);
    }
    #groupParticipants .participant.active {
      background: var(--participant-active-bg);
      color: #fff;
      box-shadow: 0 5px 15px rgba(var(--accent-color-rgb),0.3);
      transform: scale(1.08);
      font-weight: 600;
    }
    #groupParticipants .participant img {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      object-fit: cover;
      margin-bottom: 0.3rem;
      border: 2px solid #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .dark-theme #groupParticipants .participant img {
      border-color: var(--accent-color);
    }

    #settingsModal, #lorebookModal, #backgroundModal, #greetingSelectModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.65);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.25s ease-out;
      padding: 1rem;
      box-sizing: border-box;
    }
    #settingsModal.above-hamburger,
    #lorebookModal.above-hamburger,
    #backgroundModal.above-hamburger,
    #greetingSelectModal.above-hamburger {
        z-index: 1010;
    }

    #settingsModal[style*="display: flex"],
    #lorebookModal[style*="display: flex"],
    #backgroundModal[style*="display: flex"],
    #greetingSelectModal[style*="display: flex"] {
      opacity: 1;
    }
    .settings-content, .greeting-select-content {
      background: var(--card-bg);
      padding: 1.5rem 2rem;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      max-width: 900px;
      width: 95%;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
      animation: slideUpFadeInModal 0.3s var(--transition-normal) forwards;
    }
    .greeting-select-content { max-width: 500px; }
    .greeting-select-content h2 { margin-top: 0;}
    .greeting-options { display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 1rem; }
    .greeting-option {
        padding: 0.75rem;
        border: 1px solid rgba(var(--accent-color-rgb), 0.3);
        border-radius: calc(var(--border-radius) - 4px);
        cursor: pointer;
        transition: background-color var(--transition-fast), border-color var(--transition-fast);
        font-size: 0.9rem;
        white-space: pre-wrap;
        word-break: break-word;
    }
    .greeting-option:hover {
        background-color: var(--sidebar-hover-bg);
        border-color: var(--accent-color);
    }
    .greeting-option.selected {
        background-color: var(--accent-color);
        color: white;
        border-color: var(--accent-color);
    }


    @keyframes slideUpFadeInModal {
      from { opacity: 0.5; transform: translateY(20px) scale(0.98); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    .dark-theme .settings-content, .dark-theme .greeting-select-content {
      background: var(--card-bg);
    }
    .settings-content .close-btn, .greeting-select-content .close-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      background: transparent;
      border: none;
      font-size: 28px;
      line-height: 1;
      padding: 5px;
      cursor: pointer;
      color: var(--text-color);
      opacity: 0.7;
      transition: opacity var(--transition-fast), transform var(--transition-fast);
      transform-origin: center;
    }
    .settings-content .close-btn:hover, .greeting-select-content .close-btn:hover {
      opacity: 1;
      transform: rotate(90deg);
    }

    .settings {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem 1.5rem;
    }

    .settings-content fieldset {
      border: 1px solid rgba(var(--accent-color-rgb), 0.3);
      border-radius: var(--border-radius);
      padding: 1rem 1.2rem;
      margin-bottom: 1rem;
      background: rgba(var(--accent-color-rgb), 0.03);
    }
    .dark-theme .settings-content fieldset {
      border-color: rgba(var(--accent-color-rgb), 0.4);
      background: rgba(var(--accent-color-rgb), 0.06);
    }
    .settings-content legend {
      font-weight: 600;
      color: var(--accent-color);
      padding: 0 0.5rem;
      font-size: 1.1rem;
    }

    .settings-content .settings > fieldset {
      grid-column: span 2;
    }

    .settings-content .settings > .fieldset-span-1 {
      grid-column: span 1;
    }

    .settings-content label {
        color: var(--text-color);
        display: block;
        margin-bottom: 0.3rem;
        font-weight: 500;
    }
    .settings-content input, .settings-content textarea, .settings-content select, .settings-content input[type="color"] {
      width: 100%;
      margin-bottom: 0.5rem;
      padding: 0.8rem 1rem;
      font-size: 0.95rem;
      background-color: var(--input-bg);
      border: 1px solid transparent;
      border-radius: calc(var(--border-radius) - 6px);
      color: var(--text-color);
      transition: box-shadow var(--transition-fast), background var(--transition-fast), border-color var(--transition-fast);
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
      font-family: inherit;
      outline: none;
      font-weight: 500;
      box-sizing: border-box;
    }
     .settings-content input[type="color"] {
        padding: 0.2rem;
        height: 40px;
    }
    .settings-content input[type="range"] {
        padding: 0.2rem 0;
    }
    .settings-content .font-size-indicator {
        display: inline-block;
        margin-left: 10px;
        font-weight: 500;
        color: var(--text-color);
    }
    .settings-content input:focus, .settings-content textarea:focus, .settings-content select:focus, .settings-content input[type="color"]:focus {
      box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb), 0.3);
      border-color: var(--accent-color);
      background: #fff;
    }
    .dark-theme .settings-content input:focus, .dark-theme .settings-content textarea:focus, .dark-theme .settings-content select:focus, .dark-theme .settings-content input[type="color"]:focus {
      background: var(--sidebar-hover-bg);
      border-color: var(--accent-color);
    }
    .settings-content textarea {
      min-height: 100px;
      max-height: 250px;
      resize: vertical;
    }
    .settings-content .avatar-selection {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .settings-content .settings .avatar-selection {
        grid-column: span 1;
    }

    .settings-content button,
    #lorebookModal button[type="button"],
    #backgroundModal button[type="button"],
    .greeting-select-content button {
      background: var(--accent-gradient);
      color: #fff;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(var(--accent-color-rgb),0.15);
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast), filter var(--transition-fast);
      outline: none;
      letter-spacing: 0.01em;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .settings-content button:hover,
    #lorebookModal button[type="button"]:hover,
    #backgroundModal button[type="button"]:hover,
    .greeting-select-content button:hover {
      filter: brightness(var(--button-hover-brightness));
      box-shadow: 0 4px 15px rgba(var(--accent-color-rgb),0.25);
      transform: translateY(-1px);
    }
    .settings-content button:active,
    #lorebookModal button[type="button"]:active,
    #backgroundModal button[type="button"]:active,
    .greeting-select-content button:active {
      transform: scale(var(--button-active-scale)) translateY(0);
      filter: brightness(0.95);
    }
    .settings-content .avatar-selection button {
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
    }

    .switch { position: relative; display: inline-block; width: 50px; height: 28px; margin-bottom: 0.4rem;}
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .3s var(--transition-normal); border-radius: 28px; }
    .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .3s var(--transition-normal); border-radius: 50%; }
    input:checked + .slider { background-color: var(--accent-color); }
    input:focus + .slider { box-shadow: 0 0 1px var(--accent-color); }
    input:checked + .slider:before { transform: translateX(22px); }

    .messages {
      flex-grow: 1;
      overflow-y: auto;
      padding: 1rem 0.5rem;
      background-color: transparent;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      transition: background 0.4s var(--transition-normal), background-color 0.4s var(--transition-normal);
      scroll-behavior: smooth;
      position: relative;
      white-space: pre-wrap;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      font-size: calc(1.05rem * var(--chat-font-size-multiplier));
      line-height: calc(1.5 * var(--chat-font-size-multiplier));
      color: var(--text-color);
      user-select: text;
      min-height: 150px;
    }
    .messages.has-custom-background .message {
        background-color: rgba(var(--bubble-bot-rgb), 0.85);
    }
    .messages.has-custom-background .message.user {
        background-color: rgba(var(--bubble-user-rgb), 0.85);
    }
    .messages.has-custom-background .message.api {
        background-color: rgba(var(--bubble-api-rgb), 0.85);
    }
    .messages.has-custom-background .message.system {
        background-color: rgba(var(--bubble-system-rgb), 0.85);
        color: var(--text-color);
    }
    .dark-theme .messages.has-custom-background .message.system {
        color: var(--text-color);
    }


    .dark-theme .messages {
      color: var(--text-color);
    }
    .message-container {
      display: flex;
      flex-direction: column;
      margin-bottom: 1.2rem;
      opacity: 0;
      animation: messageFadeInUp 0.4s var(--transition-normal) forwards;
      position: relative;
      width: 100%;
      box-sizing: border-box;
    }
    .message-content-wrapper {
        display: flex;
        align-items: flex-start;
        width: 100%;
    }
    .message-container.user-container .message-content-wrapper {
        justify-content: flex-end;
    }

    @keyframes messageFadeInUp {
      0% { opacity: 0; transform: translateY(15px); }
      100% { opacity: 1; transform: translateY(0); }
    }
    .avatar {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      object-fit: cover;
      margin-right: 0.8rem;
      border: 2px solid var(--accent-color);
      box-shadow: 0 2px 10px rgba(var(--accent-color-rgb),0.1);
      transition: border-color 0.4s var(--transition-normal);
      background: #fff;
      flex-shrink: 0;
      cursor: pointer;
    }
    .dark-theme .avatar {
      border-color: var(--accent-color);
      box-shadow: 0 2px 10px rgba(var(--accent-color-rgb),0.4);
      background: var(--card-bg);
    }
    .message {
      word-wrap: break-word;
      flex: 0 1 auto;
      max-width: calc(75% - 40px);
      background: var(--bubble-bot);
      padding: 0.75rem 1.1rem;
      border-radius: 1.2em 1.2em 1.2em 0.5em;
      line-height: 1.45;
      box-shadow: 0 2px 5px rgba(0,0,0,0.08);
      transition: background 0.3s var(--transition-normal), color 0.3s var(--transition-normal);
      position: relative;
      color: var(--text-color);
      white-space: pre-wrap;
    }

    .message em, .message i {
        color: var(--italic-text-color);
        font-style: italic;
    }
    .message strong, .message b {
        color: var(--bold-text-color);
        font-weight: bold;
    }
    .dark-theme .message em, .dark-theme .message i {
        color: var(--italic-text-color);
    }
    .dark-theme .message strong, .dark-theme .message b {
        color: var(--bold-text-color);
    }

    .message .attachments-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 0.5rem;
        margin-top: 0.5rem;
    }
    .message img.attached-image, .message .attached-file-preview {
        max-width: 100%;
        height: auto;
        max-height: 120px;
        border-radius: calc(var(--border-radius) - 8px);
        display: block;
        cursor: zoom-in;
        object-fit: cover;
    }
    .message a.attached-file-link {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        margin-top: 0.5rem;
        padding: 0.5rem;
        background-color: rgba(var(--accent-color-rgb), 0.1);
        color: var(--accent-color);
        border-radius: calc(var(--border-radius) - 8px);
        text-decoration: none;
        font-size: 0.9em;
        font-weight: 500;
        word-break: break-all;
        height: 100px;
    }
    .message a.attached-file-link:hover {
        background-color: rgba(var(--accent-color-rgb), 0.2);
    }
    .message a.attached-file-link .file-icon {
        font-size: 2rem;
        margin-bottom: 0.3rem;
    }


    .dark-theme .message {
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .message p { margin: 0.3em 0; padding: 0; }
    .message h1, .message h2, .message h3, .message h4, .message h5, .message h6 { display: block; font-size: 1.1em; font-weight: bold; margin-top: 0.5em; margin-bottom: 0.2em;}
    .message ul, .message ol { margin: 0.5em 0; padding-left: 1.8em; }
    .message.user {
      background: var(--bubble-user);
      border-radius: 1.2em 1.2em 0.5em 1.2em;
      font-weight: 500;
    }
    .message-container.user-container .message-content-wrapper .avatar {
        order: 1;
        margin-left: 0.8rem;
        margin-right: 0;
    }
    .message.api { background: var(--bubble-api); }
    .message.system { background: var(--bubble-system); color: #777; font-style: italic; font-size: 0.9em; max-width: 100%; text-align: center; }
    .dark-theme .message.system { color: #bbb; }

    .message-buttons {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      margin-top: 0.5rem;
      padding-left: calc(44px + 0.8rem);
      width: fit-content;
    }
    .message-container.user-container .message-buttons {
      padding-left: 0;
      padding-right: calc(44px + 0.8rem);
      margin-left: auto;
    }

    .message-buttons button {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      background: var(--accent-gradient);
      color: #fff;
      font-size: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast), filter var(--transition-fast);
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .message-buttons button:hover {
      filter: brightness(var(--button-hover-brightness));
      box-shadow: 0 2px 6px rgba(var(--accent-color-rgb),0.2);
      transform: scale(1.1);
    }
    .message-buttons button:active {
      transform: scale(var(--button-active-scale)) translateY(0);
    }
    .message-buttons button:disabled {
        background: #ccc;
        cursor: not-allowed;
        filter: grayscale(50%);
    }
    .message-buttons .delete-btn::before { content: "🗑️"; }
    .message-buttons .regen-btn::before { content: "🔄"; }
    .message-buttons .edit-btn::before { content: "✏️"; }
    .message-buttons .copy-btn::before { content: "📋"; }

    /* --- СТИЛИ ДЛЯ РЕДАКТИРОВАНИЯ СООБЩЕНИЙ (ИСПРАВЛЕНО) --- */
    .message-edit-area {
      width: 100%; /* Заполняет родительский элемент, но ограничивается max-width */
      max-width: 75%; /* Ограничение ширины, как у обычного сообщения */
      box-sizing: border-box; /* Чтобы padding не влиял на общую ширину */
      min-height: 80px;
      max-height: 200px;
      resize: vertical;
      font-size: inherit;
      padding: 0.7rem 1rem;
      border-radius: var(--border-radius);
      border: 1px solid var(--accent-color);
      background: var(--input-bg);
      color: var(--text-color);
      font-family: inherit;
      box-shadow: 0 2px 8px rgba(var(--accent-color-rgb),0.2);
      margin-bottom: 0.5rem;
      outline: none;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .message-container:not(.user-container) .message-edit-area {
        margin-left: calc(44px + 0.8rem); /* Отступ слева для сообщений бота */
    }
    .message-container.user-container .message-edit-area {
        margin-left: auto; /* Авто-отступ слева для выравнивания по правому краю */
        margin-right: calc(44px + 0.8rem); /* Отступ справа для сообщений пользователя */
    }
    .dark-theme .message-edit-area {
      box-shadow: 0 2px 8px rgba(var(--accent-color-rgb),0.5);
    }
    .edit-button-container {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem;
        padding-left: calc(44px + 0.8rem);
    }
    .message-container.user-container .edit-button-container {
        padding-left: 0;
        padding-right: calc(44px + 0.8rem);
        justify-content: flex-end;
    }


    .input-area-container {
        padding: 0.3rem 0;
        border-top: 1px solid rgba(var(--accent-color-rgb),0.2);
        background: var(--card-bg);
        flex-shrink: 0;
        transition: border-color 0.4s var(--transition-normal), background-color 0.4s var(--transition-normal);
    }
    .dark-theme .input-area-container {
        border-top: 1px solid rgba(var(--accent-color-rgb),0.3);
    }
    /* --- СТИЛИ ДЛЯ ПРОЗРАЧНОГО ВВОДА (ИСПРАВЛЕНО) --- */
    .input-area-container.has-custom-background-too {
        background-color: rgba(var(--card-bg-rgb), 0.65) !important;
        border-top-color: rgba(var(--accent-color-rgb), 0.2) !important;
        -webkit-backdrop-filter: blur(4px);
        backdrop-filter: blur(4px);
    }
    .input-area-container.has-custom-background-too #userInput {
        background-color: rgba(var(--input-bg-rgb), 0.7) !important;
        color: var(--text-color);
    }
    .dark-theme .input-area-container.has-custom-background-too #userInput {
        background-color: rgba(var(--input-bg-rgb), 0.7) !important;
    }


    #filePreviewsContainer {
        display: none;
        flex-wrap: wrap;
        gap: 0.5rem;
        padding: 0.5rem 0.5rem 0.3rem 0.5rem;
        max-height: 120px;
        overflow-y: auto;
        border-bottom: 1px solid rgba(var(--accent-color-rgb),0.1);
    }
    .file-preview-item {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: var(--input-bg);
        border-radius: calc(var(--border-radius) - 8px);
        padding: 0.3rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        width: 80px;
        height: 80px;
    }
    .file-preview-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: calc(var(--border-radius) - 10px);
    }
    .file-preview-item .file-info {
        font-size: 0.7rem;
        color: var(--text-color);
        text-align: center;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        width: 100%;
        margin-top: 0.2rem;
    }
    .file-preview-item .file-icon-placeholder {
        font-size: 2rem;
        color: var(--accent-color);
        flex-grow: 1;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .remove-file-btn {
        position: absolute;
        top: -5px;
        right: -5px;
        background: rgba(0,0,0,0.6);
        color: white;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        font-size: 12px;
        line-height: 20px;
        text-align: center;
        cursor: pointer;
        z-index: 1;
    }


    .input-row {
      display: flex;
      align-items: flex-end; /* ИСПРАВЛЕНО: выравнивание по нижнему краю */
      gap: 0.5rem;
      position: relative;
      padding: 0 0.5rem;
    }

    .mobile-input-prefix {
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 0.4rem;
        flex-shrink: 0;
    }

    #userInput {
      flex-grow: 1;
      padding: 0.8rem 1rem;
      font-size: 1rem;
      border-radius: var(--border-radius);
      border: 1px solid transparent;
      background-color: var(--input-bg);
      color: var(--text-color);
      resize: none;
      transition: box-shadow var(--transition-fast), background var(--transition-fast), border-color var(--transition-fast);
      font-family: inherit;
      min-height: 44px;
      max-height: 150px;
      outline: none;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
      overflow-y: auto;
      line-height: 1.4;
      box-sizing: border-box; /* Добавлено для предсказуемости размеров */
    }
    #userInput:focus {
      box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb), 0.3);
      border-color: var(--accent-color);
      background: #fff;
    }
    .dark-theme #userInput:focus {
      background: var(--sidebar-hover-bg);
    }
    button.send-button, .file-attach-button {
      background: var(--accent-gradient);
      color: #fff;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-weight: 600;
      transition: filter var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
      outline: none;
      white-space: nowrap;
      user-select: none;
      box-shadow: 0 2px 8px rgba(var(--accent-color-rgb),0.15);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      box-sizing: border-box; /* Добавлено для предсказуемости размеров */
    }
    button.send-button:hover, .file-attach-button:hover {
      filter: brightness(var(--button-hover-brightness));
      box-shadow: 0 4px 15px rgba(var(--accent-color-rgb),0.25);
      transform: translateY(-1px);
    }
    button.send-button:active, .file-attach-button:active {
      transform: scale(var(--button-active-scale)) translateY(0);
      filter: brightness(0.95);
    }
    button.send-button#sendButton {
      padding: 0.8rem 1.5rem; /* Скорректировано для соответствия высоте textarea */
      height: 44px; /* Явная высота */
      font-size: 1rem;
      letter-spacing: 0.02em;
    }
    .file-attach-button {
      width: 44px;
      height: 44px;
      font-size: 18px;
    }
    input#fileInput { display: none; }

    .status-container {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.3rem;
      padding: 0 0.5rem;
      flex-wrap: wrap;
    }
    #messages-status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ccc;
      box-shadow: 0 0 8px #ccc;
      transition: background 0.3s var(--transition-normal), box-shadow 0.3s var(--transition-normal);
      flex-shrink: 0;
      margin-bottom: 16px; /* Выравнивание с кнопками */
    }
    #messages-status-indicator.active {
      background: #4CAF50;
      box-shadow: 0 0 12px #4CAF50;
      animation: pulseIndicator 1.8s infinite ease-in-out;
    }
    @keyframes pulseIndicator {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
    }
    .status-container button {
        padding: 0.5rem 1rem;
        font-size: 0.85rem;
        background: var(--participant-bg);
        color: var(--text-color);
        border: 1px solid var(--accent-color);
    }
    .status-container button:hover {
        background: var(--sidebar-hover-bg);
    }
    .status-container button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    #variantCounter {
        font-weight: 600;
        font-size: 0.9rem;
        user-select: none;
        color: var(--accent-color);
    }

    .memory-box {
      background: var(--input-bg);
      border-radius: calc(var(--border-radius) - 6px);
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
      padding: 0.8rem 1rem;
      font-size: 0.95rem;
      color: var(--text-color);
      resize: vertical;
      min-height: 80px;
      max-height: 150px;
      width: 100%;
      font-family: inherit;
      border: 1px solid transparent;
      outline: none;
      transition: box-shadow var(--transition-fast), background var(--transition-fast), border-color var(--transition-fast);
      font-weight: 500;
      box-sizing: border-box;
    }
    .memory-box:focus {
      box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb), 0.3);
      border-color: var(--accent-color);
      background: #fff;
    }
    .dark-theme .memory-box {
      background: var(--input-bg);
    }
    .dark-theme .memory-box:focus {
      background: var(--sidebar-hover-bg);
    }

    #themeToggle, #toggleSettingsBtn {
      position: fixed;
      background: var(--accent-gradient);
      border: none;
      border-radius: 50%;
      width: 52px;
      height: 52px;
      cursor: pointer;
      box-shadow: 0 4px 18px rgba(var(--accent-color-rgb),0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s var(--transition-normal), transform 0.2s var(--transition-fast), box-shadow 0.3s var(--transition-normal), filter 0.2s var(--transition-fast);
      z-index: 100;
      outline: none;
    }
    #themeToggle:hover, #toggleSettingsBtn:hover {
      filter: brightness(var(--button-hover-brightness));
      transform: scale(1.1) rotate(5deg);
      box-shadow: 0 6px 22px rgba(var(--accent-color-rgb),0.4);
    }
    #themeToggle:active, #toggleSettingsBtn:active {
      transform: scale(var(--button-active-scale));
    }
    #themeToggle { top: 20px; right: 20px; }
    #toggleSettingsBtn { top: 85px; right: 20px; }
    #themeToggle svg { fill: white; width: 24px; height: 24px; transition: transform 0.4s ease-in-out; }
    .dark-theme #themeToggle svg { transform: rotate(180deg); }
    #toggleSettingsBtn span { font-size: 22px; color: white; }

    #lorebookModal .settings-content { max-width: 600px; }
    .lorebook-entry {
      margin-bottom: 1rem;
      padding: 1rem;
      background: rgba(0,0,0,0.03);
      border-radius: calc(var(--border-radius) - 4px);
      border: 1px solid rgba(var(--accent-color-rgb),0.2);
    }
    .dark-theme .lorebook-entry {
        background: rgba(255,255,255,0.04);
        border-color: rgba(var(--accent-color-rgb),0.3);
    }
    .lorebook-entry label { display: block; font-weight: 500; margin-bottom: 0.3rem; font-size: 0.9rem; color: var(--accent-color); }
    .lorebook-entry input, .lorebook-entry textarea {
      width: 100%;
      margin-bottom: 0.5rem;
      box-sizing: border-box;
    }
    .lorebook-entry textarea { min-height: 80px; }

    #backgroundModal .settings-content { max-width: 450px; text-align: center; }
    #backgroundModal input[type="file"] { display: block; margin: 1rem auto; }

    @keyframes slideDownFadeIn {
      from { opacity: 0; transform: translateY(-15px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes slideUpFadeIn {
      from { opacity: 0; transform: translateY(15px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    @media (max-width: 900px) {
      body {
        flex-direction: column;
        overflow-y: hidden;
        height: var(--app-height);
      }

      .hamburger-btn { display: flex; }
      .mobile-menu-container { display: flex; }

      #sidebarToggleButton { display: none !important; }
      .sidebar { display: none !important; }

      body > #themeToggle, body > #toggleSettingsBtn { display: none !important; }


      .main-content {
          width: 100% !important;
          min-height: 0;
          flex-grow: 1;
          overflow: hidden;
          height: 100%;
      }
      .chat-container {
          padding: 0.8rem 0 0.3rem 0.8rem;
      }
      .chat-container.chat-container-custom-bg {
          padding-left: 0px;
          padding-bottom: 0px;
      }

      .messages {
          padding-left: 0.1rem;
          padding-right: 0.8rem;
      }

      .message-content-wrapper {
          flex-direction: column;
      }
      .message-container .message-content-wrapper {
          align-items: flex-start;
      }
      .message-container.user-container .message-content-wrapper {
          align-items: flex-end;
      }

      .avatar {
          width: 30px;
          height: 30px;
          margin-right: 0;
          margin-left: 0;
          margin-bottom: 0.3rem;
      }
      .message-container.user-container .message-content-wrapper .avatar {
          order: 0;
      }

      .message {
          max-width: 100%;
          padding: 0.5rem 0.8rem;
      }

      .message-buttons {
          padding: 0 0.8rem;
          box-sizing: border-box;
          width: 100%;
          margin-left: 0;
          margin-right: 0;
      }
      .message-container .message-buttons {
          justify-content: flex-start;
      }
      .message-container.user-container .message-buttons {
          justify-content: flex-end;
          padding-right: 0 !important;
      }

      .edit-button-container {
          padding: 0 0.8rem;
          box-sizing: border-box;
          width: 100%;
          margin-left: 0;
          margin-right: 0;
      }
      .message-container .edit-button-container {
          justify-content: flex-start;
      }
      .message-container.user-container .edit-button-container {
          justify-content: flex-end;
          padding-right: 0 !important;
      }

      #groupParticipants { margin-bottom: 1rem; }


      .input-area-container {
        padding: 0.5rem;
      }
      .input-row {
        flex-wrap: nowrap;
        align-items: center; /* На мобильных вернем центрирование */
        gap: 0.4rem;
        padding: 0;
      }
      .mobile-input-prefix {
        display: flex;
      }

      .input-row > .file-attach-button:not(.mobile-input-prefix .file-attach-button),
      .input-row > #messages-status-indicator:not(.mobile-input-prefix #messages-status-indicator) {
        display: none !important;
      }


      #userInput {
        font-size: 0.95rem;
        padding: 0.7rem 0.9rem;
        min-height: 80px;
      }
      button.send-button#sendButton {
        width: 40px;
        height: 40px;
        padding: 0;
        font-size: 1.2rem;
        line-height: 1;
        border-radius: 50%;
        flex-shrink: 0;
        margin-left: 0.4rem;
      }

      .mobile-input-prefix .file-attach-button {
        width: 40px;
        height: 40px;
        font-size: 1.1rem;
        flex-shrink: 0;
      }
      .mobile-input-prefix #messages-status-indicator {
          margin: 0;
          flex-shrink: 0;
          width: 12px;
          height: 12px;
      }
      #messages-status-indicator {
        margin-bottom: 0;
      }

      .settings-content .settings {
        grid-template-columns: 1fr;
      }
      .settings-content .settings > .fieldset-span-1 {
        grid-column: span 1;
      }
      .settings-content .settings .avatar-selection {
        flex-direction: column;
        align-items: stretch;
        grid-column: span 1;
      }
      .settings-content .settings .avatar-selection button {
        width: 100%;
        margin-bottom: 0.5rem;
      }
      .settings-content { padding: 1rem 1.2rem; max-height: 80vh; }


      .message-buttons button { width: 28px; height: 28px; font-size: 14px; }
    }
    @media (min-width: 901px) {
        .hamburger-btn {
            display: none !important;
        }
        #sidebarToggleButton {
            display: flex !important;
        }
        .sidebar {
            display: flex !important;
        }
    }


    @media (max-width: 480px) {
      .avatar {
          width: 28px;
          height: 28px;
          margin-bottom: 0.2rem;
      }
      .message {
          padding: 0.4rem 0.7rem;
      }

      .input-row { gap: 0.2rem; }
      #userInput { min-height: 70px; padding: 0.6rem 0.8rem; font-size: 0.9rem; }
      button.send-button#sendButton,
      .mobile-input-prefix .file-attach-button {
        width: 38px;
        height: 38px;
      }
      .mobile-input-prefix { margin-right: 0.3rem; }


      .memory-box { font-size: 0.9rem; padding: 0.7rem; }
      .settings-content { padding: 1rem; }
      .settings-content legend {font-size: 1rem;}
      .settings-content input, .settings-content textarea, .settings-content select {font-size: 0.9rem; padding: 0.7rem 0.9rem;}
      .settings-content button {font-size: 0.9rem; padding: 0.7rem 1.2rem;}


      .hamburger-btn { top: 10px; left: 10px; width: 40px; height: 40px; }
      .hamburger-btn span { width: 20px; height: 2.5px;}
      .hamburger-btn span::before { transform: translateY(-6px); }
      .hamburger-btn span::after { transform: translateY(6px); }
    }

  </style>
</head>
<body>
  <!-- Hamburger Menu Button (Mobile) -->
  <button id="hamburgerBtn" class="hamburger-btn" aria-label="Меню" aria-expanded="false" aria-controls="mobileMenuContainer">
    <span></span>
  </button>

  <!-- Sidebar Toggle Button (PC) -->
  <button id="sidebarToggleButton" aria-label="Свернуть/развернуть боковую панель" title="Свернуть/развернуть панель">&lt;&lt;</button>

  <!-- Mobile Menu Flyout -->
  <div id="mobileMenuContainer" class="mobile-menu-container" aria-hidden="true">
    <div class="mobile-menu-header">
        <span class="mobile-menu-title">Меню</span>
    </div>
    <div id="mobileMenuItemsPlaceholder">
        <!-- Content will be injected by JS -->
    </div>
  </div>

  <!-- Floating Action Buttons (Theme, Settings) -->
  <button id="themeToggle" aria-label="Переключить тему" title="Переключить тему" tabindex="0">
    <svg id="themeIcon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
      <path d="M21 12.79A9 9 0 0112.21 3 7 7 0 1021 12.79z"/> </svg>
  </button>
  <button id="toggleSettingsBtn" aria-label="Настройки" title="Настройки" tabindex="0">
    <span>⚙️</span>
  </button>

  <!-- Main Sidebar (PC) -->
  <aside class="sidebar" id="sidebar" aria-label="Список чатов" role="navigation">
    <div class="sidebar-header">💬 Чаты с ботами</div>
    <div class="chat-list" id="chatList" role="list">
      <!-- Character list items will be injected by JS -->
    </div>
  </aside>

  <!-- Main Content Area -->
  <main class="main-content" id="mainContent">
    <div id="groupParticipants" aria-label="Участники группового чата" role="list">
      <!-- Group participants will be injected by JS -->
    </div>

    <div class="chat-container" id="chatContainer">
      <div class="messages" id="messages" aria-live="polite" aria-relevant="additions">
        <!-- Messages will be injected by JS -->
      </div>

      <div class="input-area-container">
         <div id="filePreviewsContainer">
            <!-- File previews will be injected by JS -->
         </div>
        <div class="input-row" id="mainInputRow">
          <div class="mobile-input-prefix">
            <!-- Mobile-specific buttons injected by JS -->
          </div>
          <div id="messages-status-indicator" title="Статус нейросети" aria-label="Статус нейросети"></div>
          <textarea id="userInput" rows="1" placeholder="Введите сообщение..." aria-label="Поле для ввода сообщения" spellcheck="true"></textarea>
          <button class="send-button" id="sendButton" aria-label="Отправить сообщение">Отправить</button>
        </div>
        <div class="status-container" style="justify-content: flex-end; padding-right: 5px;">
          <div style="display:flex; align-items:center; gap:10px;">
            <button class="send-button" onclick="prevVariant()" aria-label="Предыдущий вариант" id="prevVariantBtn" style="display:none;">← Пред.</button>
            <span id="variantCounter" style="font-weight:700; user-select:none; display:none;"></span>
            <button class="send-button" onclick="nextVariant()" aria-label="Следующий вариант" id="nextVariantBtn" style="display:none;">След. →</button>
            <button class="send-button" onclick="applyVariant()" aria-label="Применить вариант" id="applyVariantBtn" style="display:none;">Применить</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Settings Modal -->
  <div id="settingsModal">
    <div class="settings-content">
      <button class="close-btn" onclick="closeSettingsModal()" aria-label="Закрыть настройки" title="Закрыть">×</button>
      <h2>⚙️ Настройки чата и персонажа</h2>

      <fieldset style="margin-top:1rem; margin-bottom:1.5rem;"> <legend>Режим чата</legend>
        <div class="toggle-mode" role="tablist" aria-label="Режимы чата">
            <button id="personalModeBtn" class="selected" role="tab" aria-selected="true" aria-controls="settingsSection" tabindex="0">👤 Личный чат</button>
            <button id="groupModeBtn" role="tab" aria-selected="false" aria-controls="groupParticipants" tabindex="0">👥 Групповой чат</button>
        </div>
      </fieldset>

      <section class="settings" id="settingsSection" aria-label="Настройки персонажа">
        <fieldset class="fieldset-span-1"> <legend>🔌 Настройки API LLM (По умолчанию)</legend>
          <label for="apiKey">Ключ API (LLM):</label>
          <input type="password" id="apiKey" placeholder="Введите ваш API ключ" autocomplete="off" aria-label="Ключ API LLM" />
          <label for="apiUrl">URL API LLM:</label>
          <input type="text" id="apiUrl" value="https://llm.chutes.ai/v1/chat/completions" aria-label="URL LLM API" />
          <label for="model">Модель LLM (по умолчанию):</label>
          <input type="text" id="model" value="deepseek-ai/DeepSeek-V3-0324" readonly aria-label="Модель LLM" />
          <label for="temperature">Температура (0-1):</label>
          <input type="number" id="temperature" placeholder="Например, 0.7" step="0.1" value="0.7" aria-label="Температура LLM" />
          <label for="maxTokens">Максимум токенов:</label>
          <input type="number" id="maxTokens" placeholder="Например, 1024" value="1024" aria-label="Максимум токенов LLM" />
        </fieldset>

        <fieldset class="fieldset-span-1">
            <legend>🇬 Настройки Google Gemini API</legend>
            <label for="googleApiKey">Ключ Google API:</label>
            <input type="password" id="googleApiKey" placeholder="Введите ваш Google API ключ" autocomplete="off" aria-label="Ключ Google API" />
            <label for="googleApiModel">Модель Google Gemini:</label>
            <select id="googleApiModel" aria-label="Модель Google Gemini"></select>
            <div style="display: flex; align-items: center; margin-top: 0.5rem; gap: 10px;">
                <label for="enableGoogleApi" style="font-weight: 500; margin-bottom: 0;">Использовать Google Gemini API:</label>
                <label class="switch">
                    <input type="checkbox" id="enableGoogleApi" aria-label="Включить Google Gemini API">
                    <span class="slider round"></span>
                </label>
            </div>
        </fieldset>

        <fieldset>
            <legend>🔗 Настройки REST API</legend>
            <label for="restApiUrl">URL REST API:</label>
            <input type="text" id="restApiUrl" placeholder="URL конечной точки REST API" aria-label="URL REST API" />
            <label for="restApiHeaders">Заголовки REST API (JSON):</label>
            <textarea id="restApiHeaders" placeholder='Пример: {"Authorization": "Bearer ВАШ_ТОКЕН"}' aria-label="Заголовки REST API (JSON)"></textarea>
            <div style="display: flex; align-items: center; margin-top: 0.5rem; gap: 10px;">
                <label for="enableRestApi" style="font-weight: 500; margin-bottom: 0;">Использовать REST API:</label>
                <label class="switch">
                    <input type="checkbox" id="enableRestApi" aria-label="Включить REST API">
                    <span class="slider round"></span>
                </label>
            </div>
        </fieldset>

        <fieldset>
          <legend>👤 Основные настройки Персонажа</legend>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
              <div>
                <label for="characterSelect">Выбрать персонажа:</label>
                <select id="characterSelect" aria-label="Выбор персонажа" disabled></select>
              </div>
              <div>
                <label for="characterName">Имя персонажа:</label>
                <input type="text" id="characterName" placeholder="Введите имя персонажа" aria-label="Имя персонажа" />
              </div>
          </div>
           <label for="characterModel">Модель для персонажа (если отличается):</label>
           <input type="text" id="characterModel" placeholder="Например, gpt-4-turbo или модель Gemini" aria-label="Модель персонажа" />
        </fieldset>

        <fieldset>
            <legend>📝 Описание и личность</legend>
            <label for="description">Описание (внешность, роль, цели):</label>
            <textarea id="description" placeholder="Описание роли, характера, предыстории..." aria-label="Описание персонажа" style="min-height: 140px;"></textarea>
            <label for="personality">Личность (черты характера):</label>
            <textarea id="personality" placeholder="Личность, манера речи, поведение..." aria-label="Личность персонажа"></textarea>
        </fieldset>

        <fieldset>
            <legend>📖 Сценарий и примеры диалога</legend>
            <label for="scenario">Сценарий (мир, окружение):</label>
            <textarea id="scenario" placeholder="Описание мира, ситуации, сеттинга..." aria-label="Сценарий"></textarea>
            <label for="mes_example">Пример диалога:</label>
            <textarea id="mes_example" placeholder="<START>\nПример диалога для демонстрации стиля..." aria-label="Пример диалога" style="min-height: 140px;"></textarea>
        </fieldset>

        <fieldset>
            <legend>👋 Приветствия</legend>
            <label for="welcomeMessage">Основное приветствие:</label>
            <textarea id="welcomeMessage" placeholder="Сообщение от бота при начале чата" aria-label="Основное приветственное сообщение"></textarea>
            <!-- REMOVED: Alternative Greetings Input Field -->
        </fieldset>

        <fieldset>
            <legend>⚙️ Дополнительные инструкции для ИИ</legend>
             <label for="system_prompt">Системный промпт:</label>
            <textarea id="system_prompt" placeholder="Глобальные инструкции для ИИ (system prompt)" aria-label="Системный промпт"></textarea>
            <label for="post_history_instructions">Инструкции после истории:</label>
            <textarea id="post_history_instructions" placeholder="Инструкции, которые вставляются после истории чата" aria-label="Инструкции после истории"></textarea>
             <label for="creator_notes">Заметки создателя:</label>
            <textarea id="creator_notes" placeholder="Заметки от создателя персонажа" aria-label="Заметки создателя"></textarea>
        </fieldset>

        <fieldset class="fieldset-span-1">
          <legend>🎨 Настройки оформления</legend>
          <div>
            <label for="mainTextColor">Основной цвет текста:</label>
            <input type="color" id="mainTextColor" aria-label="Основной цвет текста" />
          </div>
          <div style="margin-top: 1rem;">
            <label for="chatFontSize">Размер текста в чате: <span id="chatFontSizeIndicator">100%</span></label>
            <input type="range" id="chatFontSize" min="0.8" max="1.5" step="0.05" value="1" aria-label="Размер текста в чате" />
          </div>
        </fieldset>

        <fieldset class="fieldset-span-1">
          <legend>🖼️ Аватары</legend>
          <div class="avatar-selection">
            <button type="button" onclick="showAvatarOptions('link', 'character')">Аватар Персонажа: Ссылка</button>
            <button type="button" onclick="showAvatarOptions('file', 'character')">Аватар Персонажа: Файл</button>
          </div>
           <div id="avatarLinkInput_character" style="display:none; margin-top: 0.5rem;">
              <input type="text" id="avatarUrl_character" placeholder="URL аватара персонажа" aria-label="Ссылка на аватар персонажа" />
            </div>
            <div id="avatarFileInputWrapper_character" style="display:none; margin-top: 0.5rem;">
              <input type="file" id="avatarFileInput_character" accept="image/*" aria-label="Выбор файла аватара персонажа" />
            </div>

          <div class="avatar-selection" style="margin-top: 1rem;">
            <button type="button" onclick="showAvatarOptions('link', 'user')">Ваш Аватар: Ссылка</button>
            <button type="button" onclick="showAvatarOptions('file', 'user')">Ваш Аватар: Файл</button>
          </div>
           <div id="avatarLinkInput_user" style="display:none; margin-top: 0.5rem;">
              <input type="text" id="avatarUrl_user" placeholder="URL вашего аватара" aria-label="Ссылка на ваш аватар" />
            </div>
            <div id="avatarFileInputWrapper_user" style="display:none; margin-top: 0.5rem;">
              <input type="file" id="avatarFileInput_user" accept="image/*" aria-label="Выбор файла вашего аватара" />
            </div>
        </fieldset>

        <fieldset>
          <legend>🧠 Память ИИ (Общая)</legend>
          <textarea id="neuralMemory" class="memory-box" placeholder="Заметки и контекст, которые бот будет помнить глобально..." aria-label="Память нейросети" spellcheck="true"></textarea>
        </fieldset>

        <div style="grid-column: span 2; display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; margin-top:1rem;">
            <button type="button" onclick="saveSettings()">💾 Сохранить/Обновить</button>
            <button type="button" onclick="clearMessages()" style="background: #ffcdd2; color:#5f2120;">🗑️ Очистить чат</button>
            <button type="button" onclick="exportCharacterData()">📤 Экспорт JSON</button>
            <button type="button" onclick="importCharacterData()">📥 Импорт JSON</button>
            <input type="file" id="jsonFileInput" accept=".json, .card" style="display:none" onchange="handleFileUpload(event)" />
            <button type="button" onclick="openLorebookModal()">📚 Lorebook</button>
            <button type="button" onclick="openBackgroundModal()">🖼️ Фон чата</button>
        </div>
      </section>
    </div>
  </div>

  <!-- Lorebook Modal -->
  <div id="lorebookModal">
    <div class="settings-content"> <button class="close-btn" onclick="closeLorebookModal()" aria-label="Закрыть Lorebook" title="Закрыть">×</button>
      <h2>📚 Lorebook для "<span id="lorebookCharacterName"></span>"</h2>
      <p style="font-size: 0.9rem; color: var(--text-color); opacity: 0.8; margin-bottom: 1rem;">Добавляйте записи с названием, ключевыми словами (триггерами) и информацией, которую бот будет использовать, если триггер встретится в сообщении пользователя.</p>
      <div id="lorebookEntries" style="margin-bottom: 1rem;">
        <!-- Lorebook entries injected by JS -->
      </div>
      <button type="button" onclick="addLorebookEntry()">➕ Добавить запись</button>
    </div>
  </div>

  <!-- Background Modal -->
  <div id="backgroundModal">
    <div class="settings-content"> <button class="close-btn" onclick="closeBackgroundModal()" aria-label="Закрыть настройки фона" title="Закрыть">×</button>
      <h2>🖼️ Фон для "<span id="backgroundCharacterName"></span>"</h2>
      <p style="font-size: 0.9rem; color: var(--text-color); opacity: 0.8; margin-bottom: 1rem;">Выберите изображение для фона области сообщений этого персонажа.</p>
      <input type="file" id="backgroundFileInput" accept="image/*" aria-label="Выбрать файл фона"/>
      <div style="margin-top: 1rem;">
        <button type="button" onclick="uploadBackground()">📥 Загрузить</button>
        <button type="button" onclick="deleteBackground()" style="background: #ffcdd2; color:#5f2120;">🗑️ Удалить фон</button>
      </div>
    </div>
  </div>

  <!-- Greeting Selection Modal -->
  <div id="greetingSelectModal">
    <div class="greeting-select-content"> <button class="close-btn" onclick="closeGreetingModal()" aria-label="Закрыть выбор приветствия" title="Закрыть">×</button>
      <h2>👋 Выберите приветствие для <span id="greetingCharacterName"></span></h2>
      <div id="greetingOptions" class="greeting-options">
        <!-- Greeting options injected by JS -->
      </div>
      <button type="button" onclick="confirmGreetingSelection()">Выбрать это приветствие</button>
    </div>
  </div>

  <input type="file" id="fileInput" accept="image/*,application/*,text/*,*/*" style="display:none;" multiple />


  <script>
    // --- Global Variables and Constants ---
    let currentMode = "personal";
    let characters = {};
    let activeCharacter = null;
    let attachedFiles = [];
    let regenerateVariants = [];
    let currentVariantIndex = -1;
    let isBotGenerating = false;
    let shouldScrollToBottom = true;
    let tempImportedCharacterData = null;

    const ROOM_HISTORY_KEY = "roomHistory_v3";
    const MEMORY_KEY = "neuralMemory_v3";
    const API_KEY_STORAGE = "userApiKey_v3";
    const API_URL_STORAGE = "apiUrl_v3";
    const THEME_STORAGE = "themePreference_v3";
    const TEXT_COLOR_STORAGE = "mainTextColor_v3";
    const CHAT_FONT_SIZE_STORAGE = "chatFontSize_v1";
    const SIDEBAR_STATE_STORAGE = "sidebarState_v1";
    const REST_API_URL_STORAGE = "restApiUrl_v2";
    const REST_API_HEADERS_STORAGE = "restApiHeaders_v2";
    const ENABLE_REST_API_STORAGE = "enableRestApi_v2";
    const GOOGLE_API_KEY_STORAGE = "googleApiKey_v1";
    const GOOGLE_API_MODEL_STORAGE = "googleApiModel_v1";
    const ENABLE_GOOGLE_API_STORAGE = "enableGoogleApi_v1";
    const AVAILABLE_GOOGLE_MODELS = [ { id: "gemini-2.0-flash", name: "Gemini 2.0 Flash" } ];

    let useRestApi = false;
    let restApiUrlValue = "";
    let restApiHeadersValue = {};
    let useGoogleApi = false;
    let googleApiKey = "";
    let googleApiModel = "";

    // --- DOM Elements Cache ---
    const prevVariantBtn = document.getElementById("prevVariantBtn");
    const nextVariantBtn = document.getElementById("nextVariantBtn");
    const applyVariantBtn = document.getElementById("applyVariantBtn");
    const variantCounter = document.getElementById("variantCounter");
    let globalToggleSettingsBtn;
    let globalThemeToggleBtn;
    const sendButton = document.getElementById("sendButton");
    const personalModeBtn = document.getElementById("personalModeBtn");
    const groupModeBtn = document.getElementById("groupModeBtn");
    const messagesBox = document.getElementById("messages");
    const userInput = document.getElementById("userInput");
    const chatFontSizeSlider = document.getElementById("chatFontSize");
    const chatFontSizeIndicator = document.getElementById("chatFontSizeIndicator");
    const hamburgerBtn = document.getElementById('hamburgerBtn');
    const mobileMenuContainer = document.getElementById('mobileMenuContainer');
    const mobileMenuItemsPlaceholder = document.getElementById('mobileMenuItemsPlaceholder');
    const mainInputRow = document.getElementById('mainInputRow');
    const sidebar = document.getElementById('sidebar');
    const sidebarToggleButton = document.getElementById('sidebarToggleButton');
    const filePreviewsContainer = document.getElementById('filePreviewsContainer');

    // --- Utility Functions ---

    /**
     * [FIXED] Adds the copy to clipboard functionality.
     * @param {string} text - The text to copy.
     */
    function copyMessageToClipboard(text) {
      if (!text) return;
      const textArea = document.createElement("textarea");
      textArea.value = text;
      
      // Prevent screen from scrolling to the element
      textArea.style.top = "0";
      textArea.style.left = "0";
      textArea.style.position = "fixed";

      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
            showCustomAlert('Текст скопирован в буфер обмена!');
        } else {
            showCustomAlert('Не удалось скопировать текст.');
        }
      } catch (err) {
        console.error('Ошибка копирования:', err);
        showCustomAlert('Ошибка при копировании текста.');
      }

      document.body.removeChild(textArea);
    }

    function setAppHeight() {
      const doc = document.documentElement;
      doc.style.setProperty('--app-height', `${window.innerHeight}px`);
    }

    function setAccentRgb() {
        const rootStyle = getComputedStyle(document.documentElement);
        const accentColor = rootStyle.getPropertyValue('--accent-color').trim();
        if (accentColor.startsWith('#')) {
            const hex = accentColor.substring(1);
            const r = parseInt(hex.substring(0,2), 16);
            const g = parseInt(hex.substring(2,4), 16);
            const b = parseInt(hex.substring(4,6), 16);
            document.documentElement.style.setProperty('--accent-color-rgb', `${r},${g},${b}`);
        } else if (accentColor.startsWith('rgb')) {
             const match = accentColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
            if (match) {
                document.documentElement.style.setProperty('--accent-color-rgb', `${match[1]},${match[2]},${match[3]}`);
            }
        }
    }

    function isMobileView() {
        return window.innerWidth <= 900;
    }

    // --- Mobile Menu & View Handling ---

    function setupMobileHamburgerMenu() {
        const placeholder = mobileMenuItemsPlaceholder;
        if (!placeholder) return;
        placeholder.innerHTML = '';

        const originalSidebarHeader = document.querySelector('.sidebar .sidebar-header');
        if (originalSidebarHeader) placeholder.appendChild(originalSidebarHeader.cloneNode(true));

        const mobileChatListDiv = document.createElement('div');
        mobileChatListDiv.id = 'mobileMenuChatListInternal';
        mobileChatListDiv.className = 'chat-list';
        placeholder.appendChild(mobileChatListDiv);
        renderChatList(mobileChatListDiv);

        globalThemeToggleBtn = document.getElementById('themeToggle');
        if (globalThemeToggleBtn && globalThemeToggleBtn.parentElement !== placeholder) {
             placeholder.appendChild(globalThemeToggleBtn);
        }

        globalToggleSettingsBtn = document.getElementById('toggleSettingsBtn');
        if (globalToggleSettingsBtn && globalToggleSettingsBtn.parentElement !== placeholder) {
            placeholder.appendChild(globalToggleSettingsBtn);
        }
    }

    function restoreDesktopElements() {
        const themeToggleInHamburger = mobileMenuItemsPlaceholder.querySelector('#themeToggle');
        if (themeToggleInHamburger) {
            document.body.appendChild(themeToggleInHamburger);
        }
        const settingsToggleInHamburger = mobileMenuItemsPlaceholder.querySelector('#toggleSettingsBtn');
        if (settingsToggleInHamburger) {
            document.body.appendChild(settingsToggleInHamburger);
        }
    }


    function handleViewChange() {
        setAppHeight();
        const mainContentEl = document.getElementById('mainContent');
        const visibleFileAttachBtn = mainInputRow.querySelector('.file-attach-button');
        const originalStatusIndicator = document.getElementById('messages-status-indicator');
        const pcSidebarToggle = document.getElementById('sidebarToggleButton');

        if (isMobileView()) {
            setupMobileHamburgerMenu();
            sendButton.innerHTML = '→';
            sendButton.setAttribute('aria-label', 'Отправить');

            let mobilePrefixDiv = mainInputRow.querySelector('.mobile-input-prefix');
            if (!mobilePrefixDiv) {
                mobilePrefixDiv = document.createElement('div');
                mobilePrefixDiv.className = 'mobile-input-prefix';
                mainInputRow.insertBefore(mobilePrefixDiv, userInput);
            }
            mobilePrefixDiv.style.display = 'flex';


            let mobileFileAttachBtn = mobilePrefixDiv.querySelector('.file-attach-button');
            if (!mobileFileAttachBtn && visibleFileAttachBtn) {
                mobileFileAttachBtn = visibleFileAttachBtn.cloneNode(true);
                mobileFileAttachBtn.onclick = () => document.getElementById('fileInput').click();
                mobilePrefixDiv.appendChild(mobileFileAttachBtn);
            } else if (mobileFileAttachBtn) {
                 mobileFileAttachBtn.style.display = 'flex';
            }
             if (visibleFileAttachBtn && visibleFileAttachBtn.parentElement === mainInputRow) {
                visibleFileAttachBtn.style.display = 'none';
            }


            let mobileStatusIndicator = mobilePrefixDiv.querySelector('#messages-status-indicator');
            if (!mobileStatusIndicator && originalStatusIndicator) {
                mobileStatusIndicator = originalStatusIndicator.cloneNode(true);
                mobilePrefixDiv.appendChild(mobileStatusIndicator);
            } else if (mobileStatusIndicator) {
                 mobileStatusIndicator.style.display = 'block';
            }
            if (originalStatusIndicator && originalStatusIndicator.parentElement === mainInputRow) {
                 originalStatusIndicator.style.display = 'none';
            }

            if(sidebar) sidebar.style.display = 'none';
            if(pcSidebarToggle) pcSidebarToggle.style.display = 'none';

        } else {
            restoreDesktopElements();
            sendButton.innerHTML = 'Отправить';

            const mobilePrefixDiv = mainInputRow.querySelector('.mobile-input-prefix');
            if (mobilePrefixDiv) mobilePrefixDiv.style.display = 'none';


            if (visibleFileAttachBtn && visibleFileAttachBtn.parentElement === mainInputRow) {
                 visibleFileAttachBtn.style.display = 'flex';
            }
            if (originalStatusIndicator && originalStatusIndicator.parentElement === mainInputRow) {
                originalStatusIndicator.style.display = 'block';
            }

            if (sidebar) sidebar.style.display = 'flex';
            if(pcSidebarToggle) pcSidebarToggle.style.display = 'flex';
            loadSidebarState();
        }
    }


    // --- Initialization ---
    window.onload = () => {
      setAccentRgb();
      loadSettings();
      loadNeuralMemory();
      loadTheme();
      loadTextColor();
      loadChatTextSize();
      populateGoogleApiModelSelect();

      const statusIndicator = document.getElementById('messages-status-indicator');
      const userInputEl = document.getElementById('userInput');

      let desktopFileAttachButton = mainInputRow.querySelector('.file-attach-button:not(.mobile-input-prefix .file-attach-button)');
      if (!desktopFileAttachButton) {
          desktopFileAttachButton = document.createElement('button');
          desktopFileAttachButton.className = 'file-attach-button';
          desktopFileAttachButton.setAttribute('aria-label', 'Прикрепить файл или изображение');
          desktopFileAttachButton.title = 'Прикрепить файл или изображение';
          desktopFileAttachButton.innerHTML = '📎'; // Changed from '?' to '📎'
          desktopFileAttachButton.type = 'button';
          desktopFileAttachButton.onclick = () => document.getElementById('fileInput').click();

          if (statusIndicator && statusIndicator.parentElement === mainInputRow) {
            mainInputRow.insertBefore(desktopFileAttachButton, statusIndicator);
          } else if (userInputEl) {
            mainInputRow.insertBefore(desktopFileAttachButton, userInputEl);
          } else {
            mainInputRow.insertBefore(desktopFileAttachButton, mainInputRow.firstChild);
          }
      } else {
         desktopFileAttachButton.innerHTML = '📎'; // Changed from '?' to '📎'
      }


      renderMode();
      renderChatList();
      renderGroupParticipants();
      setupEventListeners();
      updateVariantControls();
      handleViewChange();
      renderFilePreviews();

      if (activeCharacter) {
        setActiveCharacter(activeCharacter);
      } else {
        displayInitialHelperMessage();
      }
      userInput.style.height = 'auto';
      userInput.style.height = (userInput.scrollHeight) + 'px';
      setAppHeight();
    };


    function displayInitialHelperMessage() {
        if (Object.keys(characters).length === 0 && messagesBox.children.length === 0) {
             const helperP = document.createElement('p');
             helperP.style.textAlign = 'center';
             helperP.style.color = 'var(--text-color)';
             helperP.style.padding = '20px';
             helperP.style.fontStyle = 'italic';
             helperP.style.opacity = '0.7';
             helperP.innerHTML = 'Добро пожаловать! 👋<br>Создайте своего первого персонажа в настройках (⚙️), чтобы начать чат.';
             messagesBox.appendChild(helperP);
        }
    }

    // --- Event Listeners Setup ---
    function setupEventListeners() {
      if (hamburgerBtn) {
        hamburgerBtn.addEventListener('click', () => {
            mobileMenuContainer.classList.toggle('open');
            hamburgerBtn.classList.toggle('open');
            hamburgerBtn.setAttribute('aria-expanded', mobileMenuContainer.classList.contains('open'));
            mobileMenuContainer.setAttribute('aria-hidden', !mobileMenuContainer.classList.contains('open'));
        });
      }
      document.addEventListener('click', (event) => {
        if (mobileMenuContainer && mobileMenuContainer.classList.contains('open') &&
            !mobileMenuContainer.contains(event.target) &&
            hamburgerBtn && !hamburgerBtn.contains(event.target)) {
            mobileMenuContainer.classList.remove('open');
            if (hamburgerBtn) {
                hamburgerBtn.classList.remove('open');
                hamburgerBtn.setAttribute('aria-expanded', 'false');
            }
            mobileMenuContainer.setAttribute('aria-hidden', 'true');
        }
      });

      document.body.addEventListener('click', function(event) {
        const target = event.target.closest('#themeToggle');
        if (target) {
            document.body.classList.toggle("dark-theme");
            const isDark = document.body.classList.contains("dark-theme");
            setTheme(isDark);
            setAccentRgb();
            const savedUserColor = localStorage.getItem(TEXT_COLOR_STORAGE);
            if (savedUserColor) {
                applyTextColor(savedUserColor);
            } else {
                const themeTextColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
                applyTextColor(themeTextColor);
            }
        }
      });
      document.body.addEventListener('click', function(event) {
        if (event.target.closest('#toggleSettingsBtn')) {
            openSettingsModal();
        }
      });


      document.getElementById("settingsModal").addEventListener("click", (e) => {
        if (e.target === document.getElementById("settingsModal")) closeSettingsModal();
      });
       document.getElementById("lorebookModal").addEventListener("click", (e) => {
        if (e.target === document.getElementById("lorebookModal")) closeLorebookModal();
      });
       document.getElementById("backgroundModal").addEventListener("click", (e) => {
        if (e.target === document.getElementById("backgroundModal")) closeBackgroundModal();
      });
      document.getElementById("greetingSelectModal").addEventListener("click", (e) => {
        if (e.target === document.getElementById("greetingSelectModal")) closeGreetingModal();
      });

      // ИСПРАВЛЕНО: Закрытие модальных окон по Escape
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          closeSettingsModal();
          closeLorebookModal();
          closeBackgroundModal();
          closeGreetingModal();
          const avatarModal = document.querySelector('.avatar-preview-modal');
          if (avatarModal) document.body.removeChild(avatarModal);
          if (mobileMenuContainer && mobileMenuContainer.classList.contains('open')) {
            mobileMenuContainer.classList.remove('open');
            if (hamburgerBtn) {
                 hamburgerBtn.classList.remove('open');
                 hamburgerBtn.setAttribute('aria-expanded', 'false');
            }
            mobileMenuContainer.setAttribute('aria-hidden', 'true');
          }
        }
      });
      
      // ИСПРАВЛЕНО: Убираем фокус с поля ввода по клику вне его
      document.getElementById('chatContainer').addEventListener('click', (e) => {
        const inputContainer = document.querySelector('.input-area-container');
        // Check if the clicked element or any of its parents is the userInput or a child of inputContainer
        if (inputContainer && !inputContainer.contains(e.target)) {
            userInput.blur(); // Blur the input if click is outside
        }
      });

      sendButton.addEventListener("click", sendMessage);
      userInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          sendMessage();
        }
      });
      userInput.addEventListener('input', () => {
          userInput.style.height = 'auto';
          userInput.style.height = (userInput.scrollHeight) + 'px';
      });

      personalModeBtn.addEventListener('click', () => switchMode("personal"));
      groupModeBtn.addEventListener('click', () => switchMode("group"));


      document.getElementById("apiKey").addEventListener("input", () => saveToStorage(API_KEY_STORAGE, document.getElementById("apiKey").value.trim()));
      document.getElementById("apiUrl").addEventListener("input", () => saveToStorage(API_URL_STORAGE, document.getElementById("apiUrl").value.trim()));

      document.getElementById("googleApiKey").addEventListener("input", () => {
          googleApiKey = document.getElementById("googleApiKey").value.trim();
          saveToStorage(GOOGLE_API_KEY_STORAGE, googleApiKey);
      });
      document.getElementById("googleApiModel").addEventListener("change", () => {
          googleApiModel = document.getElementById("googleApiModel").value;
          saveToStorage(GOOGLE_API_MODEL_STORAGE, googleApiModel);
      });
      document.getElementById("enableGoogleApi").addEventListener("change", (event) => {
          useGoogleApi = event.target.checked;
          saveToStorage(ENABLE_GOOGLE_API_STORAGE, useGoogleApi.toString());
      });


      document.getElementById("neuralMemory").addEventListener("input", () => saveToStorage(MEMORY_KEY, document.getElementById("neuralMemory").value));
      document.getElementById("mainTextColor").addEventListener("input", (e) => {
          applyTextColor(e.target.value);
          saveToStorage(TEXT_COLOR_STORAGE, e.target.value);
      });
      chatFontSizeSlider.addEventListener("input", (e) => {
          applyChatTextSize(e.target.value);
          saveToStorage(CHAT_FONT_SIZE_STORAGE, e.target.value);
          chatFontSizeIndicator.textContent = `${Math.round(e.target.value * 100)}%`;
      });

      if (sidebarToggleButton) {
        sidebarToggleButton.addEventListener('click', toggleSidebar);
      }

      setupRestApiSwitch();
      setupFileAttach();
      setupScrollHandler();
      setupAvatarClickHandler();
      window.addEventListener('resize', handleViewChange);
    }

    // --- Sidebar Toggle (PC) ---
    function toggleSidebar() {
        if (!sidebar) return;
        sidebar.classList.toggle('collapsed');
        const isCollapsed = sidebar.classList.contains('collapsed');
        if (sidebarToggleButton) {
            sidebarToggleButton.innerHTML = isCollapsed ? '&gt;&gt;' : '&lt;&lt;';
            sidebarToggleButton.setAttribute('aria-label', isCollapsed ? 'Развернуть боковую панель' : 'Свернуть боковую панель');
        }
        localStorage.setItem(SIDEBAR_STATE_STORAGE, isCollapsed ? 'collapsed' : 'expanded');
        applyBackground(getCurrentCharacterName());
    }

    function loadSidebarState() {
        if (isMobileView() || !sidebar) {
             if(sidebar) sidebar.classList.add('collapsed');
             return;
        }
        const state = localStorage.getItem(SIDEBAR_STATE_STORAGE);
        const isCollapsed = state === 'collapsed';
        sidebar.classList.toggle('collapsed', isCollapsed);
        if (sidebarToggleButton) {
            sidebarToggleButton.innerHTML = isCollapsed ? '&gt;&gt;' : '&lt;&lt;';
            sidebarToggleButton.setAttribute('aria-label', isCollapsed ? 'Развернуть боковую панель' : 'Свернуть боковую панель');
        }
    }


    // --- Theme and Color Management ---
    function setTheme(isDark) {
      localStorage.setItem(THEME_STORAGE, isDark ? "dark" : "light");
      const themeIconPath = isDark ?
        '<path d="M12 3.6A8.4 8.4 0 003.6 12 8.4 8.4 0 0012 20.4a8.4 8.4 0 008.4-8.4A8.4 8.4 0 0012 3.6zm0 14.4a6 6 0 110-12 6 6 0 010 12zM12 7a1 1 0 00-1 1v3H8a1 1 0 000 2h3v3a1 1 0 002 0v-3h3a1 1 0 000-2h-3V8a1 1 0 00-1-1z"/>'
        : '<path d="M21 12.79A9 9 0 0112.21 3 7 7 0 1021 12.79z"/>';
      const themeIconEl = document.getElementById("themeIcon");
      if (themeIconEl) themeIconEl.innerHTML = themeIconPath;
    }
    function loadTheme() {
      const savedTheme = localStorage.getItem(THEME_STORAGE);
      const isDark = savedTheme === "dark";
      document.body.classList.toggle("dark-theme", isDark);
      setTheme(isDark);
      setAccentRgb();
    }
    function applyTextColor(color) {
        document.documentElement.style.setProperty('--text-color', color);
        document.documentElement.style.setProperty('--bold-text-color', color);
    }
    function loadTextColor() {
        const savedColor = localStorage.getItem(TEXT_COLOR_STORAGE);
        const colorPicker = document.getElementById("mainTextColor");
        if (savedColor) {
            applyTextColor(savedColor);
            if(colorPicker) colorPicker.value = savedColor;
        } else {
            const defaultThemeColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            applyTextColor(defaultThemeColor);
            if(colorPicker) colorPicker.value = defaultThemeColor;
        }
    }

    // --- Chat Font Size ---
    function applyChatTextSize(sizeMultiplier) {
        document.documentElement.style.setProperty('--chat-font-size-multiplier', sizeMultiplier);
        if (chatFontSizeIndicator) chatFontSizeIndicator.textContent = `${Math.round(sizeMultiplier * 100)}%`;
    }

    function loadChatTextSize() {
        const savedSize = localStorage.getItem(CHAT_FONT_SIZE_STORAGE);
        const defaultSize = 1;
        const sizeToApply = savedSize ? parseFloat(savedSize) : defaultSize;
        applyChatTextSize(sizeToApply);
        if (chatFontSizeSlider) chatFontSizeSlider.value = sizeToApply;
    }


    // --- Modal Handling ---
    function openSettingsModal() {
        const modal = document.getElementById("settingsModal");
        modal.style.display = "flex";
        if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
            modal.classList.add('above-hamburger');
        }
        document.getElementById("personalModeBtn").classList.toggle("selected", currentMode === "personal");
        document.getElementById("personalModeBtn").setAttribute("aria-selected", currentMode === "personal");
        document.getElementById("groupModeBtn").classList.toggle("selected", currentMode === "group");
        document.getElementById("groupModeBtn").setAttribute("aria-selected", currentMode === "group");
    }
    function closeSettingsModal() {
        const modal = document.getElementById("settingsModal");
        modal.style.display = "none";
        modal.classList.remove('above-hamburger');
    }
    function openLorebookModal() {
      const name = getCurrentCharacterName();
      if (!name || !characters[name]) return showCustomAlert("Сначала выберите или создайте персонажа.");
      document.getElementById("lorebookCharacterName").textContent = name;
      renderLorebookEntries(name);
      const modal = document.getElementById("lorebookModal");
      modal.style.display = "flex";
      const settingsModal = document.getElementById("settingsModal");
      if (settingsModal.style.display === "flex") {
          const settingsZIndex = parseInt(window.getComputedStyle(settingsModal).zIndex, 10) || 1000;
          modal.style.zIndex = settingsZIndex + 10;
      } else if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
            modal.classList.add('above-hamburger');
      } else {
          modal.style.zIndex = '';
      }
    }
    function closeLorebookModal() {
        const modal = document.getElementById("lorebookModal");
        modal.style.display = "none";
        modal.classList.remove('above-hamburger');
        modal.style.zIndex = '';
    }
    function openBackgroundModal() {
      const name = getCurrentCharacterName();
      if (!name) return showCustomAlert("Сначала выберите или создайте персонажа.");
      document.getElementById("backgroundCharacterName").textContent = name;
      const modal = document.getElementById("backgroundModal");
      modal.style.display = "flex";
      const settingsModal = document.getElementById("settingsModal");
      if (settingsModal.style.display === "flex") {
          const settingsZIndex = parseInt(window.getComputedStyle(settingsModal).zIndex, 10) || 1000;
          modal.style.zIndex = settingsZIndex + 10;
      } else if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
            modal.classList.add('above-hamburger');
      } else {
          modal.style.zIndex = '';
      }
    }
    function closeBackgroundModal() {
        const modal = document.getElementById("backgroundModal");
        modal.style.display = "none";
        modal.classList.remove('above-hamburger');
        modal.style.zIndex = '';
    }

    function openGreetingModal(characterName, greetings) {
        document.getElementById("greetingCharacterName").textContent = characterName;
        const optionsContainer = document.getElementById("greetingOptions");
        optionsContainer.innerHTML = "";
        let selectedGreeting = null;

        greetings.forEach((greeting, index) => {
            const optionDiv = document.createElement("div");
            optionDiv.className = "greeting-option";
            optionDiv.textContent = greeting.length > 150 ? greeting.substring(0, 150) + "..." : greeting;
            optionDiv.dataset.fullGreeting = greeting;
            if (index === 0) {
                optionDiv.classList.add("selected");
                selectedGreeting = greeting;
            }
            optionDiv.addEventListener("click", () => {
                optionsContainer.querySelectorAll(".greeting-option").forEach(opt => opt.classList.remove("selected"));
                optionDiv.classList.add("selected");
                selectedGreeting = greeting;
            });
            optionsContainer.appendChild(optionDiv);
        });

        const greetingModal = document.getElementById("greetingSelectModal");
        greetingModal.style.display = "flex";
        greetingModal.style.zIndex = '';
        greetingModal.classList.remove('above-hamburger');

        const settingsModal = document.getElementById("settingsModal");
        if (settingsModal.style.display === "flex") {
            const settingsZIndex = parseInt(window.getComputedStyle(settingsModal).zIndex, 10) || 1000;
            greetingModal.style.zIndex = settingsZIndex + 10;
        } else if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
            greetingModal.classList.add('above-hamburger');
        }
    }

    function closeGreetingModal() {
        const modal = document.getElementById("greetingSelectModal");
        modal.style.display = "none";
        modal.classList.remove('above-hamburger');
        modal.style.zIndex = '';
        tempImportedCharacterData = null;
    }
    function confirmGreetingSelection() {
        const selectedOption = document.querySelector("#greetingOptions .greeting-option.selected");
        if (selectedOption && tempImportedCharacterData) {
            tempImportedCharacterData.character.welcomeMessage = selectedOption.dataset.fullGreeting;
            finalizeImport(tempImportedCharacterData);
        }
        closeGreetingModal();
    }


    // --- Mode Switching (Personal/Group) ---
    function switchMode(mode) {
      if (currentMode === mode) return;
      currentMode = mode;

      const settingsPersonalBtn = document.querySelector('#settingsModal #personalModeBtn');
      const settingsGroupBtn = document.querySelector('#settingsModal #groupModeBtn');
      if (settingsPersonalBtn) {
        settingsPersonalBtn.classList.toggle("selected", mode === "personal");
        settingsPersonalBtn.setAttribute("aria-selected", mode === "personal");
      }
      if (settingsGroupBtn) {
        settingsGroupBtn.classList.toggle("selected", mode === "group");
        settingsGroupBtn.setAttribute("aria-selected", mode === "group");
      }

      renderMode();
      clearVariants();
    }

    function renderMode() {
      document.getElementById("groupParticipants").style.display = currentMode === "group" ? "flex" : "none";
      document.getElementById("characterSelect").disabled = currentMode === "group";
      shouldScrollToBottom = true;
      loadAndRenderMessages();
      renderGroupParticipants();
      updateVariantControls();
    }

    // --- Data Storage Utilities ---
    function saveToStorage(key, value) {
      if (value !== undefined && value !== null) localStorage.setItem(key, value);
      else localStorage.removeItem(key);
    }

    // --- Settings Load/Save ---
    function loadSettings() {
      characters = JSON.parse(localStorage.getItem("characters_v3")) || {};
      document.getElementById("apiKey").value = localStorage.getItem(API_KEY_STORAGE) || "";
      document.getElementById("apiUrl").value = localStorage.getItem(API_URL_STORAGE) || "https://llm.chutes.ai/v1/chat/completions";

      restApiUrlValue = localStorage.getItem(REST_API_URL_STORAGE) || "";
      document.getElementById("restApiUrl").value = restApiUrlValue;
      const headersString = localStorage.getItem(REST_API_HEADERS_STORAGE) || "";
      document.getElementById("restApiHeaders").value = headersString;
      try { restApiHeadersValue = headersString ? JSON.parse(headersString) : {}; }
      catch (e) { console.error("Ошибка парсинга сохраненных заголовков REST API:", e); restApiHeadersValue = {}; }
      useRestApi = localStorage.getItem(ENABLE_REST_API_STORAGE) === "true";
      document.getElementById("enableRestApi").checked = useRestApi;

      googleApiKey = localStorage.getItem(GOOGLE_API_KEY_STORAGE) || "";
      document.getElementById("googleApiKey").value = googleApiKey;
      googleApiModel = localStorage.getItem(GOOGLE_API_MODEL_STORAGE) || (AVAILABLE_GOOGLE_MODELS.length > 0 ? AVAILABLE_GOOGLE_MODELS[0].id : "");
      document.getElementById("googleApiModel").value = googleApiModel;
      useGoogleApi = localStorage.getItem(ENABLE_GOOGLE_API_STORAGE) === "true";
      document.getElementById("enableGoogleApi").checked = useGoogleApi;


      if (!activeCharacter && Object.keys(characters).length > 0) {
        activeCharacter = Object.keys(characters)[0];
      }
      populateCharacterSelect();
    }
    function loadNeuralMemory() {
      document.getElementById("neuralMemory").value = localStorage.getItem(MEMORY_KEY) || "";
    }

    /**
     * [FIXED] Saves settings and handles avatar file uploads by resizing and compressing them.
     */
    async function saveSettings() {
      const name = document.getElementById("characterName").value.trim();
      if (!name) return showCustomAlert("Введите имя персонажа.");

      const isNewChar = !characters[name];
      const charData = characters[name] || {};

      // --- Update character data from all form fields ---
      charData.name = name;
      charData.description = document.getElementById("description").value;
      charData.personality = document.getElementById("personality").value;
      charData.scenario = document.getElementById("scenario").value;
      charData.mes_example = document.getElementById("mes_example").value;
      charData.welcomeMessage = document.getElementById("welcomeMessage").value;
      // Removed: charData.alternate_greetings = document.getElementById("alternate_greetings").value.split('\n').map(g => g.trim()).filter(g => g);
      // When saving, we don't take alternate_greetings from UI, they are only imported.
      // If charData.alternate_greetings doesn't exist or is empty, initialize it as an empty array.
      if (!charData.alternate_greetings || !Array.isArray(charData.alternate_greetings)) {
          charData.alternate_greetings = [];
      }


      // Advanced prompts
      charData.system_prompt = document.getElementById("system_prompt").value;
      charData.post_history_instructions = document.getElementById("post_history_instructions").value;
      charData.creator_notes = document.getElementById("creator_notes").value;

      charData.model = document.getElementById("characterModel").value.trim() || document.getElementById("model").value;
      charData.lorebook = charData.lorebook || [];

      // Await avatar processing
      const charAvatarFromFile = await handleAvatarUpload('character');
      const userAvatarFromFile = await handleAvatarUpload('user');

      // Prioritize file upload, then URL input, then existing, then default placeholder
      if (charAvatarFromFile) {
          charData.avatarCharacter = charAvatarFromFile;
      } else if (document.getElementById("avatarUrl_character").value) {
          charData.avatarCharacter = document.getElementById("avatarUrl_character").value;
      } else if (!charData.avatarCharacter || charData.avatarCharacter.startsWith('data:image')) {
          charData.avatarCharacter = "https://placehold.co/100x100/FF7AAC/FFFFFF?text=Бот";
      }

      if (userAvatarFromFile) {
          charData.avatarUser = userAvatarFromFile;
      } else if (document.getElementById("avatarUrl_user").value) {
          charData.avatarUser = document.getElementById("avatarUrl_user").value;
      } else if (!charData.avatarUser || charData.avatarUser.startsWith('data:image')) {
          charData.avatarUser = "https://placehold.co/100x100/7AC5FF/FFFFFF?text=Вы";
      }


      // Save REST API settings
      restApiUrlValue = document.getElementById("restApiUrl").value.trim();
      saveToStorage(REST_API_URL_STORAGE, restApiUrlValue);
      const headersString = document.getElementById("restApiHeaders").value.trim();
      saveToStorage(REST_API_HEADERS_STORAGE, headersString);
      try { restApiHeadersValue = headersString ? JSON.parse(headersString) : {}; }
      catch (e) { showCustomAlert("Ошибка в JSON формате заголовков REST API. Заголовки не сохранены."); console.error("Неверный JSON в заголовках REST API:", e); restApiHeadersValue = {};}
      useRestApi = document.getElementById("enableRestApi").checked;
      saveToStorage(ENABLE_REST_API_STORAGE, useRestApi.toString());

      // Save Google API settings
      googleApiKey = document.getElementById("googleApiKey").value.trim();
      saveToStorage(GOOGLE_API_KEY_STORAGE, googleApiKey);
      googleApiModel = document.getElementById("googleApiModel").value;
      saveToStorage(GOOGLE_API_MODEL_STORAGE, googleApiModel);
      useGoogleApi = document.getElementById("enableGoogleApi").checked;
      saveToStorage(ENABLE_GOOGLE_API_STORAGE, useGoogleApi.toString());

      characters[name] = charData;
      localStorage.setItem("characters_v3", JSON.stringify(characters));

      populateCharacterSelect();
      renderChatList(document.getElementById('chatList'));
      const hamburgerChatListContainer = document.getElementById('mobileMenuChatListInternal');
      if (hamburgerChatListContainer) renderChatList(hamburgerChatListContainer);

      renderGroupParticipants();

      if (isNewChar || activeCharacter !== name) {
          setActiveCharacter(name);
      } else {
          loadAndRenderMessages();
          applyBackground(name);
      }
      document.getElementById("characterSelect").value = name;
      animateSaveButton();
      showCustomAlert(`Персонаж "${name}" сохранён.`);
      closeSettingsModal();
    }

    function populateGoogleApiModelSelect() {
        const selectEl = document.getElementById("googleApiModel");
        if (!selectEl) return;
        selectEl.innerHTML = "";
        AVAILABLE_GOOGLE_MODELS.forEach(model => {
            const option = document.createElement("option");
            option.value = model.id;
            option.textContent = model.name;
            selectEl.appendChild(option);
        });
        selectEl.value = localStorage.getItem(GOOGLE_API_MODEL_STORAGE) || (AVAILABLE_GOOGLE_MODELS.length > 0 ? AVAILABLE_GOOGLE_MODELS[0].id : "");
    }


    function animateSaveButton() {
      const btn = document.querySelector('.settings-content button[onclick="saveSettings()"]');
      if (!btn) return;
      const originalText = btn.textContent;
      btn.textContent = "✅ Сохранено!";
      btn.style.background = "linear-gradient(135deg, #a8e063 0%, #56ab2f 100%)";
      setTimeout(() => {
        btn.textContent = originalText;
        btn.style.background = "";
      }, 1500);
    }

    function showAvatarOptions(option, target) {
      document.getElementById(`avatarLinkInput_${target}`).style.display = option === 'link' ? 'block' : 'none';
      document.getElementById(`avatarFileInputWrapper_${target}`).style.display = option === 'file' ? 'block' : 'none';
    }

    /**
     * [FIXED] Handles avatar file upload. Resizes and compresses the image to prevent
     * localStorage size limit issues before converting to a Data URL.
     * @param {string} target - 'character' or 'user'.
     * @returns {Promise<string|null>} A promise that resolves with the compressed Data URL or null.
     */
    async function handleAvatarUpload(target) {
        const fileInput = document.getElementById(`avatarFileInput_${target}`);
        if (!fileInput || fileInput.files.length === 0) {
            return null;
        }
        const file = fileInput.files[0];
        const MAX_WIDTH = 256;
        const MAX_HEIGHT = 256;

        return new Promise((resolve) => {
            const img = document.createElement("img");
            const reader = new FileReader();

            reader.onload = (e) => {
                img.src = e.target.result; // Load file into an image element
            };

            img.onerror = () => {
                console.error("Не удалось загрузить файл изображения для обработки.");
                resolve(null); // Resolve with null if the image fails to load
            };

            img.onload = () => {
                // Resize the image on a canvas
                const canvas = document.createElement("canvas");
                let width = img.width;
                let height = img.height;

                if (width > height) {
                    if (width > MAX_WIDTH) {
                        height *= MAX_WIDTH / width;
                        width = MAX_WIDTH;
                    }
                } else {
                    if (height > MAX_HEIGHT) {
                        width *= MAX_HEIGHT / height;
                        height = MAX_HEIGHT;
                    }
                }
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0, width, height);

                // Get a compressed data URL (jpeg is usually smaller for photos)
                const dataUrl = canvas.toDataURL("image/jpeg", 0.85); 
                resolve(dataUrl);
            };
            
            reader.readAsDataURL(file);
        });
    }


    // --- Character List and Selection ---
    function populateCharacterSelect() {
      const select = document.getElementById("characterSelect");
      if (!select) return;
      const currentVal = select.value;
      select.innerHTML = "<option value=\"\" disabled>-- Выберите персонажа --</option>";
      const sortedNames = Object.keys(characters).sort((a, b) => a.localeCompare(b, 'ru'));

      for (const name of sortedNames) {
        const option = document.createElement("option");
        option.value = name;
        option.textContent = name;
        select.appendChild(option);
      }
      if (characters[currentVal]) select.value = currentVal;
      else if (activeCharacter && characters[activeCharacter]) select.value = activeCharacter;
      else if (sortedNames.length > 0) select.value = "";

      select.onchange = () => {
          if (select.value) setActiveCharacter(select.value);
          clearVariants();
      };
    }

    function renderChatList(targetContainerEl = null) {
      const container = targetContainerEl || document.getElementById("chatList");
      if (!container) {
        return;
      }

      container.innerHTML = "";
      const fragment = document.createDocumentFragment();
      const sortedNames = Object.keys(characters).sort((a, b) => a.localeCompare(b, 'ru'));

      if (sortedNames.length === 0 && container.id === "chatList") {
          container.innerHTML = `<p style="text-align:center; font-style:italic; opacity:0.7; padding:1rem;">Нет созданных персонажей.</p>`;
          return;
      }

      for (const name of sortedNames) {
        const char = characters[name];
        const chatItem = document.createElement("div");
        chatItem.className = "chat-item";
        if (activeCharacter === name && currentMode === "personal") chatItem.classList.add("active");
        chatItem.setAttribute("role", "listitem");
        chatItem.setAttribute("tabindex", "0");

        const avatarSrc = char.avatarCharacter || "https://placehold.co/80x80/FF7AAC/FFFFFF?text=" + name.charAt(0);
        chatItem.innerHTML = `
          <img src="${avatarSrc}" alt="Аватар ${name}" onerror="this.onerror=null;this.src='https://placehold.co/80x80/FF7AAC/FFFFFF?text=?';"/>
          <div class="chat-name" title="${name}">${name}</div>
          <button class="delete-char-btn" aria-label="Удалить персонажа ${name}" title="Удалить ${name}">×</button>
        `;
        chatItem.addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-char-btn')) return;
            setActiveCharacter(name);
            switchMode("personal");
            clearVariants();
            if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
                mobileMenuContainer.classList.remove('open');
                if(hamburgerBtn) hamburgerBtn.classList.remove('open');
            }
        });
        chatItem.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                if (e.target.classList.contains('delete-char-btn')) {
                    e.target.click();
                } else {
                    setActiveCharacter(name);
                    switchMode("personal");
                    clearVariants();
                     if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
                        mobileMenuContainer.classList.remove('open');
                        if(hamburgerBtn) hamburgerBtn.classList.remove('open');
                    }
                }
            }
        });

        chatItem.querySelector('.delete-char-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            showCustomConfirm(`Вы уверены, что хотите удалить персонажа "${name}" и всю историю чата с ним? Это действие нельзя отменить.`, () => {
              delete characters[name];
              localStorage.setItem("characters_v3", JSON.stringify(characters));
              localStorage.removeItem(getChatKey(name));

              if (activeCharacter === name) {
                activeCharacter = Object.keys(characters)[0] || null;
                if (activeCharacter) {
                  setActiveCharacter(activeCharacter);
                } else {
                  // Clear all fields if no characters left
                  ['characterName', 'description', 'personality', 'scenario', 'mes_example', 'welcomeMessage', 'characterModel', 'system_prompt', 'post_history_instructions', 'creator_notes', 'avatarUrl_character', 'avatarUrl_user'].forEach(id => document.getElementById(id).value = '');
                  // For alternate_greetings, we no longer have an input field, so just ensure it's handled as an empty array or null if needed.
                  loadAndRenderMessages();
                  applyBackground(null);
                  displayInitialHelperMessage();
                }
              }
              renderChatList(document.getElementById('chatList'));
              const hamburgerChatList = document.getElementById('mobileMenuChatListInternal');
              if (hamburgerChatList) renderChatList(hamburgerChatList);

              renderGroupParticipants();
              populateCharacterSelect();
              clearVariants();
            });
        });
        fragment.appendChild(chatItem);
      }
      container.appendChild(fragment);
    }


    function renderGroupParticipants() {
      const container = document.getElementById("groupParticipants");
      container.innerHTML = "";
      if (currentMode !== "group" || Object.keys(characters).length === 0) {
        container.style.display = "none";
        return;
      }
      container.style.display = "flex";
      const fragment = document.createDocumentFragment();
      const sortedNames = Object.keys(characters).sort((a, b) => a.localeCompare(b, 'ru'));

      for (const name of sortedNames) {
        const char = characters[name];
        const participant = document.createElement("div");
        participant.className = "participant";
        participant.title = `Ответить от имени ${name}`;
        participant.setAttribute("role", "button");
        participant.setAttribute("tabindex", "0");
        const avatarSrc = char.avatarCharacter || 'https://placehold.co/80x80/FF7AAC/FFFFFF?text=' + name.charAt(0);
        participant.innerHTML = `
          <img src="${avatarSrc}" alt="Аватар ${name}" onerror="this.onerror=null;this.src='https://placehold.co/80x80/FF7AAC/FFFFFF?text=?';"/>
          <div>${name}</div>
        `;
        participant.addEventListener('click', () => {
            showCustomConfirm(`Сгенерировать ответ от имени ${name}?`, () => {
                 respondToLastMessage(name);
            });
        });
        participant.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                showCustomConfirm(`Сгенерировать ответ от имени ${name}?`, () => {
                     respondToLastMessage(name);
                });
            }
        });
        fragment.appendChild(participant);
      }
      if (sortedNames.length === 0) {
          container.innerHTML = `<p style="text-align:center; font-style:italic; opacity:0.7; padding:0.5rem;">Сначала создайте персонажей в настройках.</p>`;
      } else {
          container.appendChild(fragment);
      }
    }


    function setActiveCharacter(name) {
      if (!characters[name]) {
        console.warn(`Персонаж "${name}" не найден.`);
        activeCharacter = null;
        return;
      }
      activeCharacter = name;
      const ch = characters[name];

      // --- Populate all settings fields for the active character ---
      document.getElementById("characterName").value = name;
      document.getElementById("description").value = ch.description || "";
      document.getElementById("personality").value = ch.personality || "";
      document.getElementById("scenario").value = ch.scenario || "";
      document.getElementById("mes_example").value = ch.mes_example || "";
      document.getElementById("welcomeMessage").value = ch.welcomeMessage || "";
      // Removed: document.getElementById("alternate_greetings").value = (ch.alternate_greetings || []).join('\n');
      document.getElementById("system_prompt").value = ch.system_prompt || "";
      document.getElementById("post_history_instructions").value = ch.post_history_instructions || "";
      document.getElementById("creator_notes").value = ch.creator_notes || "";
      document.getElementById("characterModel").value = ch.model || "";
      
      // Update avatar URL input fields based on character data
      const avatarUrlInputChar = document.getElementById("avatarUrl_character");
      if (ch.avatarCharacter && !ch.avatarCharacter.startsWith('data:image')) {
          avatarUrlInputChar.value = ch.avatarCharacter;
          showAvatarOptions('link', 'character');
      } else {
          avatarUrlInputChar.value = "";
          showAvatarOptions('file', 'character'); // Default to file input if it's a data URL or missing
      }
      
      const avatarUrlInputUser = document.getElementById("avatarUrl_user");
      if (ch.avatarUser && !ch.avatarUser.startsWith('data:image')) {
          avatarUrlInputUser.value = ch.avatarUser;
          showAvatarOptions('link', 'user');
      } else {
          avatarUrlInputUser.value = "";
          showAvatarOptions('file', 'user'); // Default to file input if it's a data URL or missing
      }


      if (document.getElementById("characterSelect").value !== name) {
          document.getElementById("characterSelect").value = name;
      }

      shouldScrollToBottom = true;
      loadAndRenderMessages();
      renderChatList(document.getElementById('chatList'));
      const hamburgerChatList = document.getElementById('mobileMenuChatListInternal');
      if (hamburgerChatList) renderChatList(hamburgerChatList);

      applyBackground(name);
      clearVariants();
    }

    function getCurrentCharacterName() {
      if (currentMode === "personal") {
        return activeCharacter || (Object.keys(characters).length > 0 ? Object.keys(characters)[0] : null);
      }
      return null;
    }

    // --- Chat History Management ---
    function getChatKey(name) { return `chatHistory_v3_${name}`; }
    function saveChat(name, messages) {
      if (!name) return;
      try {
        localStorage.setItem(getChatKey(name), JSON.stringify(messages));
      } catch (e) {
        console.error("Ошибка сохранения чата в localStorage:", e);
        showCustomAlert("Ошибка: не удалось сохранить историю чата. Возможно, она слишком большая.");
      }
      allMessages = messages;
    }
    function loadChat(name) {
      if (!name) return [];
      let msgs = JSON.parse(localStorage.getItem(getChatKey(name)) || "[]");
      return msgs.map(msg => ({ ...msg, attachments: msg.attachments || null }));
    }
    function saveRoomChat(messages) {
        try {
            localStorage.setItem(ROOM_HISTORY_KEY, JSON.stringify(messages));
        } catch(e) {
            console.error("Ошибка сохранения чата комнаты в localStorage:", e);
            showCustomAlert("Ошибка: не удалось сохранить историю чата. Возможно, она слишком большая.");
        }
        allMessages = messages;
    }
    function loadRoomChat() {
      let msgs = JSON.parse(localStorage.getItem(ROOM_HISTORY_KEY) || "[]");
      return msgs.map(msg => ({ ...msg, attachments: msg.attachments || null }));
    }

    let allMessages = [];

    function loadAndRenderMessages(scrollToIndex = -1) {
        messagesBox.innerHTML = "";
        let characterForBackground = null;

        if (currentMode === "personal") {
            const name = getCurrentCharacterName();
            if (!name) {
                displayInitialHelperMessage();
                applyBackground(null);
                allMessages = [];
                return;
            }
            allMessages = loadChat(name);
            characterForBackground = name;
            if (allMessages.length === 0 && characters[name]?.welcomeMessage) {
                const welcome = characters[name].welcomeMessage;
                const welcomeMsgObject = { role: "assistant", content: welcome, avatar: characters[name].avatarCharacter, attachments: null };
                allMessages.push(welcomeMsgObject);
                saveChat(name, allMessages);
            } else if (allMessages.length === 0) {
                 const helperP = document.createElement('p');
                 helperP.style.textAlign = 'center'; helperP.style.color = 'var(--text-color)'; helperP.style.padding = '20px'; helperP.style.fontStyle = 'italic'; helperP.style.opacity = '0.7';
                 helperP.textContent = 'Нет сообщений. Начните диалог!';
                 messagesBox.appendChild(helperP);
            }
        } else {
            allMessages = loadRoomChat();
            characterForBackground = null;
            if (allMessages.length === 0) {
                const helperP = document.createElement('p');
                helperP.style.textAlign = 'center'; helperP.style.color = 'var(--text-color)'; helperP.style.padding = '20px'; helperP.style.fontStyle = 'italic'; helperP.style.opacity = '0.7';
                helperP.textContent = 'Нет сообщений в групповом чате. Начните диалог!';
                messagesBox.appendChild(helperP);
            }
        }
        applyBackground(characterForBackground);

        const fragment = document.createDocumentFragment();
        allMessages.forEach((msg, i) => {
            const container = createMessageContainerDOM(msg, i);
            fragment.appendChild(container);
        });
        messagesBox.appendChild(fragment);

        if (scrollToIndex !== -1 && scrollToIndex < allMessages.length) {
            const targetMsgEl = messagesBox.children[scrollToIndex];
            if (targetMsgEl) targetMsgEl.scrollIntoView({ behavior: "smooth", block: "nearest" });
        } else if (shouldScrollToBottom) {
            scrollToBottom(true);
            shouldScrollToBottom = false;
        }
    }


    // --- Message DOM Manipulation ---
    function createMessageContainerDOM(msgData, index) {
      const container = document.createElement("div");
      container.className = "message-container";
      container.dataset.index = index;

      let senderName, msgClass, roleForButtons, avatarUrl;
      const charNameForMsg = getCurrentCharacterName();

      if (currentMode === "personal") {
        senderName = msgData.role === "user" ? "Вы" : charNameForMsg;
        msgClass = msgData.role === "user" ? "user" : (msgData.role === "system" ? "system" : (msgData.role === "api" ? "api" : ""));
        roleForButtons = msgData.role;
        if (msgData.role === "user") {
          avatarUrl = characters[charNameForMsg]?.avatarUser || "https://placehold.co/80x80/7AC5FF/FFFFFF?text=Вы";
        } else if (msgData.role === "assistant") {
          avatarUrl = characters[charNameForMsg]?.avatarCharacter || "https://placehold.co/80x80/FF7AAC/FFFFFF?text=" + (charNameForMsg ? charNameForMsg.charAt(0) : "Б");
        } else {
          avatarUrl = msgData.role === "system" ? "https://placehold.co/80x80/CCCCCC/FFFFFF?text=S" : "https://placehold.co/80x80/80D0C0/FFFFFF?text=A";
        }
      } else {
        senderName = msgData.sender || (msgData.role === "user" ? "Вы" : "Система");
        msgClass = (msgData.sender === "Вы" || msgData.role === "user") ? "user" : (msgData.role === "system" ? "system" : (msgData.role === "api" ? "api" : ""));
        roleForButtons = msgData.role;
        if (msgData.sender === "Вы") {
          const anyUserAvatar = Object.values(characters).find(c => c.avatarUser)?.avatarUser;
          avatarUrl = anyUserAvatar || "https://placehold.co/80x80/7AC5FF/FFFFFF?text=Вы";
        } else if (characters[msgData.sender]) {
          avatarUrl = characters[msgData.sender].avatarCharacter || "https://placehold.co/80x80/FF7AAC/FFFFFF?text=" + msgData.sender.charAt(0);
        } else {
          avatarUrl = msgData.role === "system" ? "https://placehold.co/80x80/CCCCCC/FFFFFF?text=S" : "https://placehold.co/80x80/80D0C0/FFFFFF?text=A";
        }
      }
      avatarUrl = msgData.avatar || avatarUrl;
      if (msgClass === "user") container.classList.add("user-container");

      const contentWrapper = document.createElement('div');
      contentWrapper.className = 'message-content-wrapper';

      const avatarImg = document.createElement("img");
      avatarImg.src = avatarUrl || "https://placehold.co/80x80/CCCCCC/FFFFFF?text=?";
      avatarImg.alt = `Аватар ${senderName}`;
      avatarImg.className = "avatar";
      avatarImg.onerror = function() { this.onerror=null; this.src='https://placehold.co/80x80/CCCCCC/FFFFFF?text=?'; };


      const messageDiv = document.createElement("div");
      messageDiv.className = `message ${msgClass}`;

      let htmlContent = "";
      let textPart = msgData.content ? marked.parse(msgData.content) : '';
      htmlContent = `<strong>${senderName}:</strong>${textPart}`;
      messageDiv.innerHTML = htmlContent;

      if (msgData.attachments && msgData.attachments.length > 0) {
        const attachmentsGrid = document.createElement('div');
        attachmentsGrid.className = 'attachments-grid';
        msgData.attachments.forEach(att => {
            if (att.type && att.type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = att.src;
                img.alt = att.name || 'Прикрепленное изображение';
                img.className = 'attached-image';
                attachmentsGrid.appendChild(img);
            } else {
                const fileLink = document.createElement('a');
                fileLink.href = att.src;
                fileLink.target = '_blank';
                fileLink.className = 'attached-file-link';
                fileLink.download = att.name || 'file';
                fileLink.innerHTML = `<span class="file-icon">📄</span> ${att.name || 'Прикрепленный файл'}`;
                attachmentsGrid.appendChild(fileLink);
            }
        });
        messageDiv.appendChild(attachmentsGrid);
      }


      contentWrapper.appendChild(avatarImg);
      contentWrapper.appendChild(messageDiv);
      container.appendChild(contentWrapper);

      if (index !== null && roleForButtons !== "system" && senderName !== "API" && senderName !== "Система") {
        const buttonsDiv = document.createElement("div");
        buttonsDiv.className = "message-buttons";

        const copyBtn = document.createElement("button");
        copyBtn.className = "copy-btn"; copyBtn.title = "Копировать";
        copyBtn.setAttribute("aria-label", "Копировать сообщение");
        copyBtn.addEventListener("click", () => copyMessageToClipboard(msgData.content || ""));
        buttonsDiv.appendChild(copyBtn);

        const editBtn = document.createElement("button");
        editBtn.className = "edit-btn"; editBtn.title = "Редактировать";
        editBtn.setAttribute("aria-label", "Редактировать сообщение");
        editBtn.addEventListener("click", () => startEditingMessage(container, index));
        buttonsDiv.appendChild(editBtn);

        if (roleForButtons === "assistant") {
          const regenBtn = document.createElement("button");
          regenBtn.className = "regen-btn"; regenBtn.title = "Регенерировать";
          regenBtn.setAttribute("aria-label", "Регенерировать ответ");
          regenBtn.addEventListener("click", () => regenerateMessage(index));
          if (isBotGenerating) regenBtn.disabled = true;
          buttonsDiv.appendChild(regenBtn);
        }

        const delBtn = document.createElement("button");
        delBtn.className = "delete-btn"; delBtn.title = "Удалить";
        delBtn.setAttribute("aria-label", "Удалить сообщение");
        delBtn.addEventListener("click", () => deleteMessage(index));
        buttonsDiv.appendChild(delBtn);

        container.appendChild(buttonsDiv);
      }
      return container;
    }

    function appendNewMessageToDOM(msgData, index) {
        const container = createMessageContainerDOM(msgData, index);
        messagesBox.appendChild(container);
        requestAnimationFrame(() => {
            container.style.opacity = 1;
            container.style.transform = 'translateY(0)';
        });
        if (shouldScrollToBottom) {
            scrollToBottom(true);
        }
    }

    function updateMessageInDOM(index, newMsgData) {
        const oldContainer = messagesBox.querySelector(`.message-container[data-index="${index}"]`);
        if (oldContainer) {
            const newContainer = createMessageContainerDOM(newMsgData, index);
            messagesBox.replaceChild(newContainer, oldContainer);
             requestAnimationFrame(() => {
                newContainer.style.opacity = 1;
                newContainer.style.transform = 'translateY(0)';
            });
        }
    }
    function removeMessageFromDOM(index) {
        const containerToRemove = messagesBox.querySelector(`.message-container[data-index="${index}"]`);
        if (containerToRemove) {
            messagesBox.removeChild(containerToRemove);
            const messageContainers = messagesBox.querySelectorAll('.message-container');
            messageContainers.forEach((container, newIdx) => {
                container.dataset.index = newIdx;
            });
        }
    }


    function scrollToBottom(force = false) {
      if (force || messagesBox.scrollTop + messagesBox.clientHeight >= messagesBox.scrollHeight - 100) {
        messagesBox.scrollTop = messagesBox.scrollHeight;
      }
    }

    // --- Message Editing ---
    function startEditingMessage(container, index) {
      const messageContentWrapper = container.querySelector(".message-content-wrapper");
      const messageButtons = container.querySelector(".message-buttons");
      if (!messageContentWrapper || container.querySelector(".message-edit-area")) return;

      let originalText = allMessages[index].content;

      messageContentWrapper.style.display = "none";
      if (messageButtons) messageButtons.style.display = "none";

      const editArea = document.createElement("textarea");
      editArea.className = "message-edit-area";
      editArea.value = originalText;
      editArea.style.height = 'auto';
      editArea.style.height = (Math.max(80, editArea.scrollHeight)) + 'px';
      editArea.addEventListener('input', () => {
          editArea.style.height = 'auto';
          editArea.style.height = (Math.max(80, editArea.scrollHeight)) + 'px';
      });

      const saveBtn = document.createElement("button");
      saveBtn.textContent = "Сохранить"; saveBtn.className = "send-button";
      saveBtn.style.marginRight = "0.5rem";

      const cancelBtn = document.createElement("button");
      cancelBtn.textContent = "Отмена"; cancelBtn.className = "send-button";
      cancelBtn.style.background = "var(--participant-bg)"; cancelBtn.style.color = "var(--text-color)";

      const btnContainer = document.createElement("div");
      btnContainer.className = "edit-button-container";
      btnContainer.appendChild(saveBtn); btnContainer.appendChild(cancelBtn);

      container.insertBefore(editArea, messageContentWrapper);
      container.insertBefore(btnContainer, editArea.nextSibling);
      editArea.focus();

      saveBtn.onclick = () => {
        const newText = editArea.value.trim();
        const currentMessageAttachments = allMessages[index]?.attachments;
        if (!newText && (!currentMessageAttachments || currentMessageAttachments.length === 0)) {
            return showCustomAlert("Сообщение не может быть пустым, если нет вложений.");
        }
        updateMessageContent(index, newText);

        if (allMessages[index].role === 'user' || allMessages[index].sender === 'Вы') {
            const charToRespondName = currentMode === 'personal' ? getCurrentCharacterName() : getLastBotSender(index);
            if (charToRespondName && characters[charToRespondName]) {
                triggerBotResponseAfterEdit(index, charToRespondName);
            }
        }
      };
      cancelBtn.onclick = () => {
        messageContentWrapper.style.display = "flex";
        if (messageButtons) messageButtons.style.display = "flex";
        container.removeChild(editArea);
        container.removeChild(btnContainer);
      };
    }

    function getLastBotSender(currentUserMsgIndex) {
        if (currentMode !== 'group') return null;
        for (let i = currentUserMsgIndex - 1; i >= 0; i--) {
            if (allMessages[i].role === 'assistant' && allMessages[i].sender && characters[allMessages[i].sender]) {
                return allMessages[i].sender;
            }
        }
        return Object.keys(characters).length > 0 ? Object.keys(characters)[0] : null;
    }

    async function triggerBotResponseAfterEdit(editedUserMessageIndex, characterNameToRespond) {
        const charDataForApi = characters[characterNameToRespond];
        if (!charDataForApi) return;

        const historyUpToEdited = allMessages.slice(0, editedUserMessageIndex + 1);
        const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
        const max_tokens = parseInt(document.getElementById("maxTokens").value) || 1024;

        if (allMessages.length > editedUserMessageIndex + 1) {
            allMessages.splice(editedUserMessageIndex + 1);
             if (currentMode === "personal") saveChat(getCurrentCharacterName(), allMessages);
             else saveRoomChat(allMessages);
            loadAndRenderMessages(editedUserMessageIndex);
        }

        const systemPromptText = getSystemContent(charDataForApi, allMessages[editedUserMessageIndex].content);

        if (useGoogleApi && googleApiKey && googleApiModel) {
            let geminiContents = [];
            historyUpToEdited.forEach(m => {
                let role = (m.sender === "Вы" || m.role === "user") ? "user" : "model";
                let textContent = (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${m.content}` : m.content;

                let parts = [];
                if (textContent) parts.push({ text: textContent });
                if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                    m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                        parts.push({ inlineData: { mimeType: att.type, data: att.src.split(',')[1] } });
                    });
                } else if (m.attachments) {
                     parts.push({ text: `[Прикреплено ${m.attachments.length} файлов]` });
                }

                if (parts.length > 0) {
                     if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                        console.warn("Consecutive roles for Gemini (after edit), appending parts:", role);
                        geminiContents[geminiContents.length - 1].parts.push(...parts);
                    } else {
                        geminiContents.push({ role: role, parts: parts });
                    }
                }
            });
            let lastValidRoleAfterEdit = null;
            geminiContents = geminiContents.filter(item => {
                if (item.role === lastValidRoleAfterEdit) return false;
                lastValidRoleAfterEdit = item.role;
                return true;
            });

            await fetchGeminiChatCompletion(
                googleApiKey, googleApiModel, systemPromptText, geminiContents,
                temperature, max_tokens, characterNameToRespond,
                allMessages, charDataForApi.avatarCharacter, true
            );

        } else {
            let messagesForAPI = [{ role: "system", content: systemPromptText }];
            messagesForAPI.push(...historyUpToEdited.map(m => {
                let apiMsgContentArray = [];
                if (m.content) apiMsgContentArray.push({ type: "text", text: m.content });
                if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                    m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                         apiMsgContentArray.push({ type: "image_url", image_url: { url: att.src } });
                    });
                } else if (m.attachments) {
                     apiMsgContentArray.push({ type: "text", text: `[Прикреплено ${m.attachments.length} файлов]` });
                }
                const finalContent = apiMsgContentArray.length === 1 && apiMsgContentArray[0].type === "text" ? apiMsgContentArray[0].text : apiMsgContentArray;

                return {
                    role: (m.sender === "Вы" || m.role === "user") ? "user" : "assistant",
                    content: (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${finalContent}` : finalContent
                };
            }));

            const apiKey = document.getElementById("apiKey").value;
            const apiUrl = document.getElementById("apiUrl").value;
            const modelForApi = charDataForApi.model || document.getElementById("model").value;

            await fetchChatCompletion(
                apiUrl, apiKey, modelForApi, messagesForAPI,
                temperature, max_tokens, characterNameToRespond,
                allMessages, charDataForApi.avatarCharacter, true
            );
        }
    }


    function updateMessageContent(index, newContent) {
      if (index < 0 || index >= allMessages.length) return;
      const msgToUpdate = allMessages[index];
      msgToUpdate.content = newContent;

      if (currentMode === "personal") {
        const name = getCurrentCharacterName();
        if (!name) return;
        saveChat(name, allMessages);
      } else {
        saveRoomChat(allMessages);
      }
      updateMessageInDOM(index, msgToUpdate);
    }

    function deleteMessage(index) {
      if (index < 0 || index >= allMessages.length) return;
      showCustomConfirm("Вы уверены, что хотите удалить это сообщение?", () => {
        allMessages.splice(index, 1);

        if (currentMode === "personal") {
          const name = getCurrentCharacterName();
          if (!name) return;
          saveChat(name, allMessages);
        } else {
          saveRoomChat(allMessages);
        }
        removeMessageFromDOM(index);
        clearVariants();
        if (allMessages.length === 0) {
            loadAndRenderMessages();
        }
      });
    }

    // --- Message Regeneration ---
    async function regenerateMessage(index) {
        if (isBotGenerating) return;
        if (index < 0 || index >= allMessages.length || allMessages[index].role !== 'assistant') {
            showCustomAlert("Можно регенерировать только ответ ассистента.");
            return;
        }

        isBotGenerating = true;
        updateRegenerateButtonsState(true);
        setStatusActive(true);

        const characterForResponse = currentMode === "personal" ? getCurrentCharacterName() : allMessages[index].sender;
        if (!characterForResponse || !characters[characterForResponse]) {
            showCustomAlert("Не удалось определить персонажа для регенерации.");
            isBotGenerating = false; updateRegenerateButtonsState(false); setStatusActive(false);
            return;
        }
        const charData = characters[characterForResponse];

        let userMsgIndex = -1;
        for (let i = index - 1; i >= 0; i--) {
            const msg = allMessages[i];
            const isUserMsg = (currentMode === "personal" && msg.role === "user") ||
                              (currentMode === "group" && (msg.sender === "Вы" || msg.role === "user"));
            if (isUserMsg) {
                userMsgIndex = i;
                break;
            }
        }
        if (userMsgIndex === -1) {
            showCustomAlert("Не найдено предыдущее сообщение пользователя для контекста регенерации.");
            isBotGenerating = false; updateRegenerateButtonsState(false); setStatusActive(false);
            return;
        }

        if (regenerateVariants.length === 0 || currentVariantIndex === -1) {
            regenerateVariants = [JSON.parse(JSON.stringify(allMessages))];
            currentVariantIndex = 0;
        }

        const historyForAPI = allMessages.slice(0, index);
        const userMessageContentForSystem = allMessages[userMsgIndex].content;

        const targetMessageContainer = messagesBox.querySelector(`.message-container[data-index="${index}"]`);
        const messageDivToUpdate = targetMessageContainer ? targetMessageContainer.querySelector('.message') : null;

        if (messageDivToUpdate) {
            messageDivToUpdate.innerHTML = `<strong>${characterForResponse}:</strong> ...регенерируется...`;
            scrollToBottom(true);
        }

        let newVariantChatState;

        try {
            let reply;
            const systemPromptText = getSystemContent(charData, userMessageContentForSystem);

            if (useGoogleApi && googleApiKey && googleApiModel) {
                let geminiContents = [];
                 historyForAPI.forEach(m => {
                    let role = (m.sender === "Вы" || m.role === "user") ? "user" : "model";
                    let textContent = (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${m.content}` : m.content;
                    let parts = [];
                    if (textContent) parts.push({ text: textContent });
                    if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                        m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                            parts.push({ inlineData: { mimeType: att.type, data: att.src.split(',')[1] } });
                        });
                    } else if (m.attachments) {
                        parts.push({ text: `[Прикреплено ${m.attachments.length} файлов]` });
                    }
                    if (parts.length > 0) {
                         if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                             console.warn("Consecutive roles for Gemini (regen), appending parts:", role);
                             geminiContents[geminiContents.length - 1].parts.push(...parts);
                         } else {
                            geminiContents.push({ role: role, parts: parts });
                         }
                    }
                });
                let lastValidRoleRegen = null;
                geminiContents = geminiContents.filter(item => {
                    if (item.role === lastValidRoleRegen) return false;
                    lastValidRoleRegen = item.role;
                    return true;
                });

                const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${googleApiModel}:generateContent?key=${googleApiKey}`;
                const geminiRequestBody = {
                    systemInstruction: { parts: [{ text: systemPromptText }] },
                    contents: geminiContents,
                    generationConfig: {
                        temperature: parseFloat(document.getElementById("temperature").value) || 0.7,
                        maxOutputTokens: parseInt(document.getElementById("maxTokens").value) || 1024
                    }
                };
                const response = await fetch(geminiUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(geminiRequestBody)
                });
                if (!response.ok) throw new Error(`Google API Ошибка: ${response.status} ${await response.text()}`);
                const result = await response.json();
                reply = result.candidates?.[0]?.content?.parts?.[0]?.text || "";
                if (!reply && !(result.candidates && result.candidates[0].finishReason === "MAX_TOKENS")) throw new Error("Пустой ответ от Google API.");

                newVariantChatState = JSON.parse(JSON.stringify(allMessages.slice(0, index)));
                const newBotMsgData = {
                    ...allMessages[index],
                    content: reply,
                    attachments: null,
                };
                newVariantChatState.push(newBotMsgData);
                if (allMessages.length > index + 1) {
                    newVariantChatState.push(...JSON.parse(JSON.stringify(allMessages.slice(index + 1))));
                }
                regenerateVariants.push(newVariantChatState);
                currentVariantIndex = regenerateVariants.length - 1;
                allMessages = [...newVariantChatState];
                if (currentMode === "personal") saveChat(getCurrentCharacterName(), allMessages);
                else saveRoomChat(allMessages);
                updateMessageInDOM(index, allMessages[index]);
                scrollToBottom(true);
                shouldScrollToBottom = false;

            } else {
                shouldScrollToBottom = true;
                let messagesForStdAPI = [{ role: "system", content: systemPromptText }];
                messagesForStdAPI.push(...historyForAPI.map(m => {
                     let apiContentArray = [];
                     if (m.content) apiContentArray.push({ type: "text", text: m.content });
                     if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                         m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                              apiContentArray.push({ type: "image_url", image_url: { url: att.src } });
                         });
                     } else if (m.attachments) {
                         apiContentArray.push({ type: "text", text: ` [Прикреплено ${m.attachments.length} файлов]` });
                     }
                     const finalContent = apiContentArray.length === 1 && apiContentArray[0].type === "text" ? apiContentArray[0].text : apiContentArray;
                    return {
                        role: (m.sender === "Вы" || m.role === "user") ? "user" : "assistant",
                        content: (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${finalContent}` : finalContent
                    };
                }));

                const apiKey = document.getElementById("apiKey").value;
                const apiUrl = document.getElementById("apiUrl").value;
                const model = charData.model || document.getElementById("model").value;
                const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
                const max_tokens = parseInt(document.getElementById("maxTokens").value) || 1024;

                const response = await fetch(apiUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "Authorization": `Bearer ${apiKey}` },
                    body: JSON.stringify({ model, messages: messagesForStdAPI, stream: true, max_tokens, temperature })
                });
                if (!response.ok) throw new Error(`HTTP ошибка! Статус: ${response.status} ${await response.text()}`);

                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let streamedContent = "";
                reply = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value);
                    const lines = chunk.split("\n").filter(line => line.trim().startsWith("data: "));
                    for (const line of lines) {
                        if (line.includes("[DONE]")) break;
                        const jsonString = line.replace(/^data: /, "");
                        try {
                            const parsed = JSON.parse(jsonString);
                            const content = parsed.choices?.[0]?.delta?.content;
                            if (content) {
                                streamedContent += content;
                                reply = removeThoughts(streamedContent);
                                if (messageDivToUpdate) {
                                    messageDivToUpdate.innerHTML = `<strong>${characterForResponse}:</strong>${marked.parse(reply)}`;
                                    scrollToBottom(true);
                                }
                            }
                        } catch (e) { /* console.warn("Stream parsing error:", e, jsonString); */ }
                    }
                }
                if (!reply && streamedContent) reply = removeThoughts(streamedContent);

                newVariantChatState = JSON.parse(JSON.stringify(allMessages.slice(0, index)));
                const newBotMsgDataStreaming = {
                    ...allMessages[index],
                    content: reply,
                    attachments: null,
                };
                newVariantChatState.push(newBotMsgDataStreaming);
                if (allMessages.length > index + 1) {
                    newVariantChatState.push(...JSON.parse(JSON.stringify(allMessages.slice(index + 1))));
                }
                regenerateVariants.push(newVariantChatState);
                currentVariantIndex = regenerateVariants.length - 1;
                allMessages = [...newVariantChatState];
                if (currentMode === "personal") saveChat(getCurrentCharacterName(), allMessages);
                else saveRoomChat(allMessages);
                if (!messageDivToUpdate) {
                    updateMessageInDOM(index, allMessages[index]);
                }
            }
        } catch (err) {
            console.error("Ошибка регенерации:", err);
            if (messageDivToUpdate) {
                 const originalMessageOfCurrentVariant = regenerateVariants[currentVariantIndex] ? regenerateVariants[currentVariantIndex][index] : null;
                 const veryFirstOriginalMessage = regenerateVariants[0] ? regenerateVariants[0][index] : null;
                 const messageToRevertTo = originalMessageOfCurrentVariant || veryFirstOriginalMessage;

                 if (messageToRevertTo) {
                    updateMessageInDOM(index, messageToRevertTo);
                    allMessages[index] = JSON.parse(JSON.stringify(messageToRevertTo));
                 } else {
                    messageDivToUpdate.innerHTML = `<strong>${characterForResponse}:</strong> Ошибка регенерации: ${err.message}`;
                 }
            } else {
                appendNewMessageToDOM({ sender: "Система", content: `Ошибка регенерации: ${err.message}`, role: "system" }, allMessages.length);
            }
        } finally {
            setStatusActive(false);
            isBotGenerating = false;
            updateRegenerateButtonsState(false);
            updateVariantControls();
            if (shouldScrollToBottom) { scrollToBottom(true); shouldScrollToBottom = false; }
            userInput.focus();
        }
    }


    function updateRegenerateButtonsState(disable) {
        const regenBtns = document.querySelectorAll('.message-buttons .regen-btn');
        regenBtns.forEach(btn => btn.disabled = disable);
    }


    function renderSpecificChatState(chatState) {
        messagesBox.innerHTML = "";
        const fragment = document.createDocumentFragment();
        chatState.forEach((msg, i) => {
            const container = createMessageContainerDOM(msg, i);
            fragment.appendChild(container);
        });
        messagesBox.appendChild(fragment);
        scrollToBottom(true);
    }


    function updateVariantControls() {
      const hasVariants = regenerateVariants.length > 1;
      [prevVariantBtn, nextVariantBtn, applyVariantBtn, variantCounter].forEach(el => {
          if (el) el.style.display = hasVariants ? "inline-block" : "none";
      });
      if (!hasVariants) {
        if (variantCounter) variantCounter.textContent = "";
        if(prevVariantBtn) prevVariantBtn.disabled = true;
        if(nextVariantBtn) nextVariantBtn.disabled = true;
        return;
      }
      if (currentVariantIndex < 0 && regenerateVariants.length > 0) currentVariantIndex = 0;
      if (currentVariantIndex >= regenerateVariants.length) currentVariantIndex = regenerateVariants.length - 1;

      if (variantCounter) variantCounter.textContent = `Вариант ${currentVariantIndex + 1} / ${regenerateVariants.length}`;
      if (prevVariantBtn) prevVariantBtn.disabled = currentVariantIndex === 0;
      if (nextVariantBtn) nextVariantBtn.disabled = currentVariantIndex === regenerateVariants.length - 1;
    }
    function prevVariant() { if (currentVariantIndex > 0) { currentVariantIndex--; renderVariant(); updateVariantControls(); } }
    function nextVariant() { if (currentVariantIndex < regenerateVariants.length - 1) { currentVariantIndex++; renderVariant(); updateVariantControls(); } }
    function applyVariant() {
      if (currentVariantIndex < 0 || currentVariantIndex >= regenerateVariants.length) return;
      const variantToApply = regenerateVariants[currentVariantIndex];
      allMessages = [...variantToApply];

      if (currentMode === "personal") {
        const name = getCurrentCharacterName();
        if (!name) return;
        saveChat(name, allMessages);
      } else {
        saveRoomChat(allMessages);
      }
      clearVariantsAndRender();
    }
    function renderVariant() {
      if (currentVariantIndex < 0 || currentVariantIndex >= regenerateVariants.length) return;
      renderSpecificChatState(regenerateVariants[currentVariantIndex]);
    }
    function clearVariants() { regenerateVariants = []; currentVariantIndex = -1; updateVariantControls(); }
    function clearVariantsAndRender() {
        clearVariants();
        shouldScrollToBottom = true;
        loadAndRenderMessages();
    }


    function getNeuralMemory() { return document.getElementById("neuralMemory").value.trim(); }

    function getSystemContent(charData, userMessage) {
        const memory = getNeuralMemory();
        const dateTime = new Date().toLocaleString('ru-RU', { dateStyle: 'full', timeStyle: 'short' });
        const dateTimeInfo = `[Текущие дата и время]: ${dateTime}`;

        // Build a comprehensive character definition string
        let characterDefinition = "";
        if (charData.description) characterDefinition += `[Описание персонажа]\n${charData.description}\n\n`;
        if (charData.personality) characterDefinition += `[Личность]\n${charData.personality}\n\n`;
        if (charData.scenario) characterDefinition += `[Сценарий]\n${charData.scenario}\n\n`;
        if (charData.mes_example) characterDefinition += `[Пример диалога]\n${charData.mes_example}\n\n`;

        // Start building the final system prompt
        let systemContent = `${characterDefinition.trim()}\n\n${dateTimeInfo}`;

        if (memory) {
            systemContent += `\n\n[Память нейросети (глобальные заметки)]:\n${memory}`;
        }

        // Add character's specific system_prompt if it exists
        if (charData.system_prompt) {
            systemContent += `\n\n[Дополнительные системные инструкции]\n${charData.system_prompt}`;
        }

        // Check lorebook entries against the user's message
        if (charData.lorebook && charData.lorebook.length > 0 && userMessage) {
            const triggeredEntries = charData.lorebook.filter(entry =>
                entry.triggers && entry.triggers.some(trigger => userMessage.toLowerCase().includes(trigger.toLowerCase().trim()))
            );
            if (triggeredEntries.length > 0) {
                const loreInfo = triggeredEntries.map(entry => {
                    let entryPrefix = "- ";
                    if (entry.entryName) {
                        entryPrefix = `- [${entry.entryName}]: `;
                    }
                    return `${entryPrefix}${entry.info}`;
                }).join("\n");
                systemContent += `\n\n[Информация из Lorebook (активировано триггерами в последнем сообщении пользователя)]:\n${loreInfo}`;
            }
        }
        return systemContent.trim();
    }


    async function sendToRestApi(userMessageContent, attachmentsArray = null) {
        if (!restApiUrlValue) {
            appendNewMessageToDOM({sender:"Система", content:"URL REST API не настроен.", role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"}, allMessages.length);
            return;
        }
        setStatusActive(true);
        const apiPlaceholderAvatar = "https://placehold.co/80x80/80D0C0/FFFFFF?text=A";
        const placeholderMsgData = {sender:"API", content:"Отправка запроса на REST API...", role:"api", avatar: apiPlaceholderAvatar, attachments: attachmentsArray};
        allMessages.push(placeholderMsgData);
        appendNewMessageToDOM(placeholderMsgData, allMessages.length -1);


        try {
            const requestBody = { message: userMessageContent, attachments: attachmentsArray };
            const response = await fetch(restApiUrlValue, {
                method: "POST",
                headers: { "Content-Type": "application/json", ...restApiHeadersValue },
                body: JSON.stringify(requestBody)
            });

            const placeholderIndex = allMessages.findIndex(m => m.content === "Отправка запроса на REST API..." && m.sender === "API");
            if (placeholderIndex > -1) {
                allMessages.splice(placeholderIndex, 1);
                removeMessageFromDOM(placeholderIndex);
            }


            const responseData = await response.json();
            if (!response.ok) throw new Error(`API Ошибка: ${response.status} - ${responseData.error || JSON.stringify(responseData)}`);

            let apiReplyText = responseData.reply || responseData.message || JSON.stringify(responseData.data) || JSON.stringify(responseData);
            const apiReplyMsgData = {sender:"API", content:apiReplyText, role:"api", avatar: apiPlaceholderAvatar, attachments: responseData.attachments};
            allMessages.push(apiReplyMsgData);
            appendNewMessageToDOM(apiReplyMsgData, allMessages.length - 1);


        } catch (error) {
            console.error("REST API Ошибка:", error);
            const placeholderIndexOnError = allMessages.findIndex(m => m.content === "Отправка запроса на REST API..." && m.sender === "API");
            if (placeholderIndexOnError > -1) {
                 allMessages.splice(placeholderIndexOnError, 1);
                removeMessageFromDOM(placeholderIndexOnError);
            }
            const errorMsgData = {sender:"Система", content:`Ошибка REST API: ${error.message}`, role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"};
            allMessages.push(errorMsgData);
            appendNewMessageToDOM(errorMsgData, allMessages.length - 1);

        } finally {
            setStatusActive(false);
            scrollToBottom(true);
            userInput.focus();
        }
    }
    function setupRestApiSwitch() {
        const enableRestApiCheckbox = document.getElementById("enableRestApi");
        enableRestApiCheckbox.addEventListener("change", () => {
            useRestApi = enableRestApiCheckbox.checked;
            saveToStorage(ENABLE_REST_API_STORAGE, useRestApi.toString());
        });
    }

    async function respondToLastMessage(characterName) {
      if (isBotGenerating) return;
      isBotGenerating = true;
      updateRegenerateButtonsState(true);

      const currentGroupMessages = [...allMessages];
      if (currentGroupMessages.length === 0) {
          showCustomAlert("Нет сообщений для ответа.");
          isBotGenerating = false; updateRegenerateButtonsState(false); return;
      }
      if (!characters[characterName]) {
          showCustomAlert(`Персонаж "${characterName}" не найден.`);
          isBotGenerating = false; updateRegenerateButtonsState(false); return;
      }

      const charData = characters[characterName];
      let lastUserMessageForContext = "";
      let lastUserMessageAttachments = null;
      for (let i = currentGroupMessages.length -1; i >= 0; i--) {
          if ((currentGroupMessages[i].sender === "Вы" || currentGroupMessages[i].role === "user")) {
              lastUserMessageForContext = currentGroupMessages[i].content;
              lastUserMessageAttachments = currentGroupMessages[i].attachments;
              break;
          }
      }

      const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
      const max_tokens = parseInt(document.getElementById("maxTokens").value) || 1024;
      const systemPromptText = getSystemContent(charData, lastUserMessageForContext);


      if (useGoogleApi && googleApiKey && googleApiModel) {
        let geminiContents = [];
        currentGroupMessages.forEach(m => {
            let role = (m.sender === "Вы" || m.role === "user") ? "user" : "model";
            let textContent = (m.sender !== "Вы" && m.role !== "user" && m.sender) ? `${m.sender}: ${m.content}` : m.content;

            let parts = [];
            if (textContent) parts.push({ text: textContent });
            if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                 m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                    parts.push({ inlineData: { mimeType: att.type, data: att.src.split(',')[1] } });
                 });
            } else if (m.attachments) {
                parts.push({ text: `[Прикреплено ${m.attachments.length} файлов]` });
            }

            if (parts.length > 0) {
                 if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                     console.warn("Consecutive roles for Gemini (respondToLast), appending parts:", role);
                     geminiContents[geminiContents.length - 1].parts.push(...parts);
                 } else {
                    geminiContents.push({ role: role, parts: parts });
                 }
            }
        });
        let lastValidRoleGroup = null;
        geminiContents = geminiContents.filter(item => {
            if (item.role === lastValidRoleGroup) return false;
            lastValidRoleGroup = item.role;
            return true;
        });

        await fetchGeminiChatCompletion(
            googleApiKey, googleApiModel, systemPromptText, geminiContents,
            temperature, max_tokens, characterName, allMessages, charData.avatarCharacter
        );

      } else {
        const model = charData.model || document.getElementById("model").value;
        const apiKey = document.getElementById("apiKey").value;
        const apiUrl = document.getElementById("apiUrl").value;
        const messagesForAPI = [
          { role: "system", content: systemPromptText },
          ...currentGroupMessages.map(m => {
              let apiContentArray = [];
              if (m.content) apiContentArray.push({ type: "text", text: m.content });
              if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                   m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                        apiContentArray.push({ type: "image_url", image_url: { url: att.src } });
                   });
              } else if (m.attachments) {
                  apiContentArray.push({ type: "text", text: ` [Прикреплено ${m.attachments.length} файлов]` });
              }

              const finalContent = apiContentArray.length === 1 && apiContentArray[0].type === "text" ? apiContentArray[0].text : apiContentArray;
              return {
                  role: (m.sender === "Вы" || m.role === "user") ? "user" : "assistant",
                  content: (m.sender !== "Вы" && m.role !== "user" && m.sender) ? `${m.sender}: ${finalContent}` : finalContent
              }
          })
        ];
        await fetchChatCompletion(apiUrl, apiKey, model, messagesForAPI, temperature, max_tokens, characterName, allMessages, charData.avatarCharacter);
      }
    }


    async function sendMessage() {
        if (isBotGenerating && !useRestApi && !(useGoogleApi && googleApiKey && googleApiModel) ) {
            return;
        }

        const messageContent = userInput.value.trim();
        if (!messageContent && attachedFiles.length === 0) return;

        clearVariants();
        const originalPlaceholder = userInput.placeholder;
        userInput.value = "";
        userInput.placeholder = "Отправка...";
        userInput.disabled = true;
        userInput.style.height = 'auto';
        userInput.style.height = (userInput.scrollHeight) + 'px';


        let userAvatarUrl;
        let activeCharNameForUserMsg = getCurrentCharacterName();
        let attachmentsDataArray = [];

        if (attachedFiles.length > 0) {
            for (const file of attachedFiles) {
                 attachmentsDataArray.push({
                    name: file.name,
                    type: file.type,
                    src: await readFileAsDataURL(file)
                });
            }
        }

        const userMsgObject = {
            role: "user",
            content: messageContent,
            attachments: attachmentsDataArray.length > 0 ? attachmentsDataArray : null
        };

        if (currentMode === "personal") {
            if (!activeCharNameForUserMsg) {
                showCustomAlert("Выберите персонажа для отправки сообщения.");
                userInput.placeholder = originalPlaceholder; userInput.disabled = false; userInput.focus(); return;
            }
            userAvatarUrl = characters[activeCharNameForUserMsg]?.avatarUser || "https://placehold.co/80x80/7AC5FF/FFFFFF?text=Вы";
            userMsgObject.avatar = userAvatarUrl;
            allMessages.push(userMsgObject);
            saveChat(activeCharNameForUserMsg, allMessages);
        } else {
            const anyUserAvatar = Object.values(characters).find(c => c.avatarUser)?.avatarUser;
            userAvatarUrl = anyUserAvatar || "https://placehold.co/80x80/7AC5FF/FFFFFF?text=Вы";
            userMsgObject.sender = "Вы";
            userMsgObject.avatar = userAvatarUrl;
            allMessages.push(userMsgObject);
            saveRoomChat(allMessages);
        }

        appendNewMessageToDOM(userMsgObject, allMessages.length - 1);
        shouldScrollToBottom = true;

        attachedFiles = [];
        renderFilePreviews();
        document.getElementById("fileInput").value = "";

        const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
        const max_tokens = parseInt(document.getElementById("maxTokens").value) || 1024;

        let charToRespondName, charDataForApi, systemContextMsgForLLM;
        if (currentMode === "personal") {
            charToRespondName = activeCharNameForUserMsg;
            charDataForApi = characters[charToRespondName];
            systemContextMsgForLLM = messageContent;
        } else {
            let lastBotSender = null;
            for (let i = allMessages.length - 2; i >= 0; i--) {
                if (allMessages[i].role === 'assistant' && allMessages[i].sender && characters[allMessages[i].sender]) {
                    lastBotSender = allMessages[i].sender; break;
                }
            }
            charToRespondName = lastBotSender || (Object.keys(characters).length > 0 ? Object.keys(characters)[0] : null);
            if (!charToRespondName || !characters[charToRespondName]) {
                const sysMsg = {sender:"Система", content:"Не удалось определить персонажа для ответа в группе.", role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"};
                allMessages.push(sysMsg); appendNewMessageToDOM(sysMsg, allMessages.length - 1);
                userInput.placeholder = originalPlaceholder; userInput.disabled = false; userInput.focus(); return;
            }
            charDataForApi = characters[charToRespondName];
            systemContextMsgForLLM = messageContent;
        }

        const systemPromptText = getSystemContent(charDataForApi, systemContextMsgForLLM);

        if (useGoogleApi && googleApiKey && googleApiModel) {
            isBotGenerating = true;
            updateRegenerateButtonsState(true);
            setStatusActive(true);
            shouldScrollToBottom = true;

            let geminiContents = [];
            allMessages.forEach(m => {
                let role = (m.sender === "Вы" || m.role === "user") ? "user" : "model";
                let textContent = (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${m.content}` : m.content;

                let parts = [];
                if (textContent) parts.push({ text: textContent });
                if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                     m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                        parts.push({ inlineData: { mimeType: att.type, data: att.src.split(',')[1] } });
                     });
                } else if (m.attachments) {
                    parts.push({ text: `[Прикреплено ${m.attachments.length} файлов]` });
                }


                if (parts.length > 0) {
                    if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                        console.warn("Consecutive roles for Gemini (send), appending parts:", role);
                         geminiContents[geminiContents.length - 1].parts.push(...parts);
                    } else {
                        geminiContents.push({ role: role, parts: parts });
                    }
                }
            });
            let lastValidRoleSend = null;
            geminiContents = geminiContents.filter(item => {
                if (item.role === lastValidRoleSend) return false;
                lastValidRoleSend = item.role;
                return true;
            });


            await fetchGeminiChatCompletion(
                googleApiKey, googleApiModel, systemPromptText, geminiContents,
                temperature, max_tokens, charToRespondName, allMessages, charDataForApi.avatarCharacter
            );


        } else if (useRestApi && restApiUrlValue) {
            shouldScrollToBottom = true;
            await sendToRestApi(messageContent, attachmentsDataArray);
        } else {
            isBotGenerating = true;
            updateRegenerateButtonsState(true);
            setStatusActive(true);
            shouldScrollToBottom = true;

            let messagesForAPI = [{ role: "system", content: systemPromptText }];
            messagesForAPI.push(...allMessages.map(m => {
                let apiMsgContentArray = [];
                if (m.content) apiMsgContentArray.push({ type: "text", text: m.content });
                if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                     m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                        apiMsgContentArray.push({ type: "image_url", image_url: { url: att.src } });
                     });
                } else if (m.attachments) {
                    apiMsgContentArray.push({ type: "text", text: `[Прикреплено ${m.attachments.length} файлов]` });
                }

                const finalContent = apiMsgContentArray.length === 1 && apiMsgContentArray[0].type === "text" ? apiMsgContentArray[0].text : apiMsgContentArray;
                return {
                    role: (m.sender === "Вы" || m.role === "user") ? "user" : "assistant",
                    content: (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${finalContent}` : finalContent
                };
            }));

            const apiKey = document.getElementById("apiKey").value;
            const apiUrl = document.getElementById("apiUrl").value;
            const modelForApi = charDataForApi.model || document.getElementById("model").value;

            await fetchChatCompletion(apiUrl, apiKey, modelForApi, messagesForAPI, temperature, max_tokens, charToRespondName, allMessages, charDataForApi.avatarCharacter);
        }
        userInput.placeholder = originalPlaceholder; userInput.disabled = false;
        userInput.focus(); // Keep focus on the input field
    }

    async function fetchGeminiChatCompletion(gApiKey, gModel, systemInstructionText, geminiContents, temperature, maxOutputTokens, apiCharacterName, chatArrayToUpdateRef, botAvatarUrl, isAfterEdit = false) {
        const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${gModel}:generateContent?key=${gApiKey}`;

        const requestBody = {
            systemInstruction: { parts: [{ text: systemInstructionText }] },
            contents: geminiContents,
            generationConfig: {
                temperature: temperature,
                maxOutputTokens: maxOutputTokens
            }
        };

        setStatusActive(true);

        const placeholderMsgData = { content: "...", role: "assistant", avatar: botAvatarUrl, attachments: null };
        if (currentMode === "group") {
            placeholderMsgData.sender = apiCharacterName;
        }

        let placeholderIndex = -1;
        if (!isAfterEdit) {
            chatArrayToUpdateRef.push(placeholderMsgData);
            placeholderIndex = chatArrayToUpdateRef.length - 1;
            appendNewMessageToDOM(placeholderMsgData, placeholderIndex);
        } else {
             chatArrayToUpdateRef.push(placeholderMsgData);
             placeholderIndex = chatArrayToUpdateRef.length - 1;
             appendNewMessageToDOM(placeholderMsgData, placeholderIndex);
        }


        try {
            const response = await fetch(geminiApiUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`Google API Ошибка: ${response.status} - ${errorBody}`);
            }
            const result = await response.json();
            const reply = result.candidates?.[0]?.content?.parts?.[0]?.text || "";

            if (!reply && !(result.candidates && result.candidates[0].finishReason === "MAX_TOKENS")) {
                 throw new Error("Пустой ответ от Google API или неожиданный формат.");
            }

            chatArrayToUpdateRef[placeholderIndex].content = reply;
            chatArrayToUpdateRef[placeholderIndex].attachments = null;
            if (currentMode === "group") {
                 chatArrayToUpdateRef[placeholderIndex].sender = apiCharacterName;
            }

            updateMessageInDOM(placeholderIndex, chatArrayToUpdateRef[placeholderIndex]);
            scrollToBottom(true);
            shouldScrollToBottom = false;

            if (currentMode === "personal") saveChat(getCurrentCharacterName(), chatArrayToUpdateRef);
            else saveRoomChat(chatArrayToUpdateRef);

        } catch (err) {
            console.error("fetchGeminiChatCompletion Ошибка:", err);
            if (chatArrayToUpdateRef[placeholderIndex] && chatArrayToUpdateRef[placeholderIndex].content === "...") {
                chatArrayToUpdateRef.splice(placeholderIndex, 1);
                removeMessageFromDOM(placeholderIndex);
            }
            const errorMsgData = {sender:"Система", content:`Ошибка Google Gemini API: ${err.message}`, role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"};
            chatArrayToUpdateRef.push(errorMsgData);
            appendNewMessageToDOM(errorMsgData, chatArrayToUpdateRef.length - 1);
        } finally {
            setStatusActive(false);
            isBotGenerating = false;
            updateRegenerateButtonsState(false);
            if (shouldScrollToBottom) { scrollToBottom(true); shouldScrollToBottom = false; }
            userInput.focus();
        }
    }


    async function fetchChatCompletion(apiUrl, apiKey, model, messagesForAPI, temperature, max_tokens, apiCharacterName, chatArrayToUpdateRef, botAvatarUrl, isAfterEdit = false) {
      const requestBody = { model, messages: messagesForAPI, stream: true, max_tokens, temperature };
      setStatusActive(true);
      shouldScrollToBottom = true;

      const placeholderMsgData = { content: "...", role: "assistant", avatar: botAvatarUrl, attachments: null };
      if (currentMode === "group") {
          placeholderMsgData.sender = apiCharacterName;
      }

      chatArrayToUpdateRef.push(placeholderMsgData);
      const placeholderIndex = chatArrayToUpdateRef.length - 1;
      appendNewMessageToDOM(placeholderMsgData, placeholderIndex);

      try {
        const response = await fetch(apiUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Authorization": `Bearer ${apiKey}` },
          body: JSON.stringify(requestBody)
        });
        if (!response.ok) throw new Error(`HTTP ошибка! Статус: ${response.status} ${await response.text()}`);

        const reader = response.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let reply = "", streamedContent = "";

        const streamingMessageContainer = messagesBox.querySelector(`.message-container[data-index="${placeholderIndex}"]`);
        const streamingMessageDiv = streamingMessageContainer?.querySelector(".message");


        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value);
          const lines = chunk.split("\n").filter(line => line.trim().startsWith("data: "));
          for (const line of lines) {
            if (line.includes("[DONE]")) break;
            const jsonString = line.replace(/^data: /, "");
            try {
              const parsed = JSON.parse(jsonString);
              const content = parsed.choices?.[0]?.delta?.content;
              if (content) {
                streamedContent += content;
                reply = removeThoughts(streamedContent);
                if (streamingMessageDiv) {
                  streamingMessageDiv.innerHTML = `<strong>${apiCharacterName}:</strong>${marked.parse(reply)}`;
                  scrollToBottom(true);
                }
              }
            } catch (e) { /* console.warn("Stream parsing error:", e, jsonString); */ }
          }
        }
        if (!reply && streamedContent) reply = removeThoughts(streamedContent);

        chatArrayToUpdateRef[placeholderIndex].content = reply;
        chatArrayToUpdateRef[placeholderIndex].attachments = null;
        if (currentMode === "group") {
            chatArrayToUpdateRef[placeholderIndex].sender = apiCharacterName;
        }

        if (!streamingMessageDiv) {
            updateMessageInDOM(placeholderIndex, chatArrayToUpdateRef[placeholderIndex]);
        }

        if (currentMode === "personal") saveChat(getCurrentCharacterName(), chatArrayToUpdateRef);
        else saveRoomChat(chatArrayToUpdateRef);


      } catch (err) {
        console.error("fetchChatCompletion Ошибка:", err);
        if (chatArrayToUpdateRef[placeholderIndex] && chatArrayToUpdateRef[placeholderIndex].content === "...") {
            chatArrayToUpdateRef.splice(placeholderIndex, 1);
            removeMessageFromDOM(placeholderIndex);
        }
        const errorMsgData = {sender:"Система", content:`Ошибка LLM: ${err.message}`, role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"};
        chatArrayToUpdateRef.push(errorMsgData);
        appendNewMessageToDOM(errorMsgData, chatArrayToUpdateRef.length - 1);

      } finally {
        setStatusActive(false);
        isBotGenerating = false;
        updateRegenerateButtonsState(false);
        if (shouldScrollToBottom) { scrollToBottom(true); shouldScrollToBottom = false; }
      }
    }


    function removeThoughts(text) { return text.replace(/<think>[\s\S]*?<\/think>/g, '').trim(); }

    function clearMessages() {
      showCustomConfirm("Вы уверены, что хотите очистить текущий чат? Это действие нельзя отменить.", () => {
        let initialMessages = [];
        if (currentMode === "personal") {
          const name = getCurrentCharacterName();
          if (!name) return;
          const charData = characters[name];
          if (charData && charData.welcomeMessage) {
              initialMessages.push({ role: "assistant", content: charData.welcomeMessage, avatar: charData.avatarCharacter, attachments: null });
          }
          saveChat(name, initialMessages);
        } else {
          saveRoomChat(initialMessages);
        }
        shouldScrollToBottom = true;
        loadAndRenderMessages();
        clearVariants();
      });
    }

    function exportCharacterData() {
      const name = getCurrentCharacterName();
      if (!name || !characters[name]) return showCustomAlert("Выберите персонажа для экспорта.");

      const charData = characters[name];
      const chatHistory = loadChat(name);

      const dataToExport = {
        spec: "chara_card_v2",
        spec_version: "2.0",
        data: {
            name: charData.name || "",
            description: charData.description || "",
            personality: charData.personality || "",
            scenario: charData.scenario || "",
            first_mes: charData.welcomeMessage || "",
            mes_example: charData.mes_example || "",
            creator_notes: charData.creator_notes || "",
            system_prompt: charData.system_prompt || "",
            post_history_instructions: charData.post_history_instructions || "",
            alternate_greetings: charData.alternate_greetings || [],
            tags: [], // Tags not implemented in UI yet
            creator: "", // Creator not implemented in UI yet
            character_version: "", // Version not implemented in UI yet
            avatar: "none", // Placeholder, actual avatar is in our app's format
            extensions: {}
        }
      };

      const fullExportData = {
          character: charData,
          messages: chatHistory,
          version: "2.0",
          format: "llm_chatbot_rp_v3_full",
          tavern_card: dataToExport
      };

      const blob = new Blob([JSON.stringify(fullExportData, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = `${name}_персонаж_и_чат.json`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showCustomAlert(`Данные персонажа "${name}" и история чата экспортированы.`);
    }

    function importCharacterData() { document.getElementById("jsonFileInput").click(); }

    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const importedJson = JSON.parse(e.target.result);
          let charDataToProcess;

          // Check for our app's full format first
          if (importedJson.format === "llm_chatbot_rp_v3_full" && importedJson.character) {
              console.log("Importing llm_chatbot_rp_v3_full format");
              charDataToProcess = {
                  character: importedJson.character,
                  messages: importedJson.messages || [],
              };
          }
          // Then check for standard TavernAI/Chub format
          else if (importedJson.spec === "chara_card_v2" && importedJson.data) {
            console.log("Importing chara_card_v2 format");
            const tavernData = importedJson.data;
            charDataToProcess = {
              character: {
                name: tavernData.name || "Безымянный",
                description: tavernData.description || "",
                personality: tavernData.personality || "",
                scenario: tavernData.scenario || "",
                mes_example: tavernData.mes_example || "",
                welcomeMessage: tavernData.first_mes || "",
                alternate_greetings: tavernData.alternate_greetings || [],
                system_prompt: tavernData.system_prompt || "",
                post_history_instructions: tavernData.post_history_instructions || "",
                creator_notes: tavernData.creator_notes || "",
                avatarCharacter: tavernData.avatar || "https://placehold.co/100x100/FF7AAC/FFFFFF?text=Бот", // Use TavernAI avatar or default
                avatarUser: document.getElementById("avatarUrl_user").value || "https://placehold.co/100x100/7AC5FF/FFFFFF?text=Вы",
                model: document.getElementById("characterModel").value || document.getElementById("model").value,
                lorebook: [],
              },
              messages: [],
              _tavernData: tavernData // Keep original data for reference
            };

            if (tavernData.character_book && tavernData.character_book.entries) {
                charDataToProcess.character.lorebook = tavernData.character_book.entries.map(entry => ({
                    entryName: entry.name || "",
                    triggers: entry.keys || [],
                    info: entry.content || ""
                })).filter(lbEntry => (lbEntry.triggers.length > 0 && lbEntry.info) || lbEntry.entryName);
            }
          } else {
            throw new Error("Неподдерживаемый или неверный формат файла JSON.");
          }

          tempImportedCharacterData = charDataToProcess;

          if (charDataToProcess._tavernData) {
            const greetings = [];
            if (charDataToProcess._tavernData.first_mes) greetings.push(charDataToProcess._tavernData.first_mes);
            if (charDataToProcess._tavernData.alternate_greetings && charDataToProcess._tavernData.alternate_greetings.length > 0) {
                greetings.push(...charDataToProcess._tavernData.alternate_greetings);
            }

            if (greetings.length > 1) {
                openGreetingModal(charDataToProcess.character.name, greetings); return;
            } else if (greetings.length === 1) {
                charDataToProcess.character.welcomeMessage = greetings[0];
            }
          }
          finalizeImport(charDataToProcess);

        } catch (err) {
          showCustomAlert(`Ошибка импорта файла: ${err.message}`); console.error("Ошибка импорта:", err);
          tempImportedCharacterData = null;
        } finally {
            event.target.value = null;
        }
      };
      reader.readAsText(file);
    }

    function finalizeImport(dataToImport) {
        if (!dataToImport || !dataToImport.character) {
            console.error("Данные для импорта неполные.");
            showCustomAlert("Ошибка: не удалось завершить импорт, данные неполные.");
            return;
        }
        const charData = dataToImport.character;
        const charName = charData.name;

        // Ensure all fields exist on the object to prevent errors
        const fullCharData = {
          name: charName,
          description: charData.description || "",
          personality: charData.personality || "",
          scenario: charData.scenario || "",
          mes_example: charData.mes_example || "",
          welcomeMessage: charData.welcomeMessage || "",
          alternate_greetings: charData.alternate_greetings || [],
          system_prompt: charData.system_prompt || "",
          post_history_instructions: charData.post_history_instructions || "",
          creator_notes: charData.creator_notes || "",
          model: charData.model || document.getElementById("model").value,
          avatarCharacter: charData.avatarCharacter || "https://placehold.co/100x100/FF7AAC/FFFFFF?text=Бот",
          avatarUser: charData.avatarUser || document.getElementById("avatarUrl_user").value || "https://placehold.co/100x100/7AC5FF/FFFFFF?text=Вы",
          lorebook: charData.lorebook || [],
          backgroundImage: charData.backgroundImage || null
        };

        characters[charName] = fullCharData;
        saveChat(charName, dataToImport.messages || []);
        localStorage.setItem("characters_v3", JSON.stringify(characters));

        populateCharacterSelect();
        setActiveCharacter(charName);
        document.getElementById("characterSelect").value = charName;

        showCustomAlert(`Персонаж "${charName}" успешно импортирован!`);
        closeSettingsModal();
        tempImportedCharacterData = null;
    }


    function setupFileAttach() {
        const hiddenFileInput = document.getElementById("fileInput");
        if(hiddenFileInput) {
            hiddenFileInput.addEventListener("change", (event) => {
                if (event.target.files.length > 0) {
                    Array.from(event.target.files).forEach(file => attachedFiles.push(file));
                    renderFilePreviews();
                    userInput.placeholder = `${attachedFiles.length} файл(ов) прикреплено. Введите текст или отправьте.`;
                }
                event.target.value = null;
            });
        }
    }

    function renderFilePreviews() {
        filePreviewsContainer.innerHTML = "";
        if (attachedFiles.length === 0) {
            filePreviewsContainer.style.display = "none";
            if (!userInput.value.trim()) {
                 userInput.placeholder = "Введите сообщение...";
            }
            return;
        }
        filePreviewsContainer.style.display = "flex";

        attachedFiles.forEach((file, index) => {
            const previewItem = document.createElement('div');
            previewItem.className = 'file-preview-item';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-file-btn';
            removeBtn.innerHTML = '&times;';
            removeBtn.title = 'Удалить файл';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                attachedFiles.splice(index, 1);
                renderFilePreviews();
                 if (attachedFiles.length > 0) {
                    userInput.placeholder = `${attachedFiles.length} файл(ов) прикреплено. Введите текст или отправьте.`;
                } else if (!userInput.value.trim()) {
                     userInput.placeholder = "Введите сообщение...";
                }
            };
            previewItem.appendChild(removeBtn);

            if (file.type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = URL.createObjectURL(file);
                img.onload = () => URL.revokeObjectURL(img.src);
                previewItem.appendChild(img);
            } else {
                const icon = document.createElement('div');
                icon.className = 'file-icon-placeholder';
                icon.textContent = '📄';
                previewItem.appendChild(icon);
            }
            const fileName = document.createElement('div');
            fileName.className = 'file-info';
            fileName.textContent = file.name;
            fileName.title = file.name;
            previewItem.appendChild(fileName);

            filePreviewsContainer.appendChild(previewItem);
        });
    }


    function readFileAsDataURL(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }


    function renderLorebookEntries(characterName) {
      const container = document.getElementById("lorebookEntries");
      container.innerHTML = "";
      const character = characters[characterName];
      if (!character || !character.lorebook || character.lorebook.length === 0) {
        container.innerHTML = "<p style='font-style:italic; opacity:0.7;'>Записей нет.</p>"; return;
      }
      character.lorebook.forEach((entry, index) => {
        const entryDiv = document.createElement("div");
        entryDiv.className = "lorebook-entry";
        entryDiv.innerHTML = `
          <div>
            <label for="lore-entryName-${index}">Название записи (Имя):</label>
            <input type="text" id="lore-entryName-${index}" value="${entry.entryName || ""}" data-index="${index}" oninput="updateLorebookField(${index}, 'entryName', this.value)" />
          </div>
          <div>
            <label for="lore-triggers-${index}">Ключевые слова (через запятую):</label>
            <input type="text" id="lore-triggers-${index}" value="${(entry.triggers || []).join(', ')}" data-index="${index}" oninput="updateLorebookField(${index}, 'triggers', this.value)" />
          </div>
          <div>
            <label for="lore-info-${index}">Информация:</label>
            <textarea id="lore-info-${index}" data-index="${index}" oninput="updateLorebookField(${index}, 'info', this.value)">${entry.info || ""}</textarea>
          </div>
          <button type="button" onclick="deleteLorebookEntry(${index})" style="background: #ffcdd2; color:#5f2120; font-size:0.9rem; padding: 0.5rem 0.8rem;">Удалить запись</button>
        `;
        container.appendChild(entryDiv);
      });
    }

    function updateLorebookField(index, field, value) {
        const charName = getCurrentCharacterName();
        if (!charName || !characters[charName] || !characters[charName].lorebook[index]) return;

        if (field === 'entryName') {
            characters[charName].lorebook[index].entryName = value.trim();
        } else if (field === 'triggers') {
            characters[charName].lorebook[index].triggers = value.split(',').map(t => t.trim()).filter(t => t);
        } else if (field === 'info') {
            characters[charName].lorebook[index].info = value.trim();
        }
        localStorage.setItem("characters_v2", JSON.stringify(characters));
    }

    function addLorebookEntry() {
      const charName = getCurrentCharacterName();
      if (!charName || !characters[charName]) return showCustomAlert("Сначала выберите персонажа.");
      characters[charName].lorebook = characters[charName].lorebook || [];
      characters[charName].lorebook.push({ entryName: "", triggers: [], info: "" }); // Add new empty entry with entryName
      localStorage.setItem("characters_v2", JSON.stringify(characters));
      renderLorebookEntries(charName);
    }

    function deleteLorebookEntry(index) {
      const charName = getCurrentCharacterName();
      if (!charName || !characters[charName] || !characters[charName].lorebook) return;
      showCustomConfirm("Удалить эту запись из Lorebook?", () => {
        characters[charName].lorebook.splice(index, 1);
        localStorage.setItem("characters_v2", JSON.stringify(characters));
        renderLorebookEntries(charName);
      });
    }

    function uploadBackground() {
      const name = getCurrentCharacterName(); // Get current character
      if (!name || !characters[name]) return showCustomAlert("Персонаж не найден.");
      const fileInput = document.getElementById("backgroundFileInput");
      const file = fileInput.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          characters[name].backgroundImage = e.target.result; // Store as dataURL
          localStorage.setItem("characters_v2", JSON.stringify(characters)); // Save
          applyBackground(name); // Apply immediately
          closeBackgroundModal(); // Close modal
        };
        reader.readAsDataURL(file);
      } else {
        showCustomAlert("Пожалуйста, выберите файл изображения.");
      }
      fileInput.value = ""; // Reset file input
    }
    function deleteBackground() {
      const name = getCurrentCharacterName();
      if (!name || !characters[name]) return showCustomAlert("Персонаж не найден.");
      delete characters[name].backgroundImage; // Remove property
      localStorage.setItem("characters_v2", JSON.stringify(characters)); // Save
      applyBackground(name); // Re-apply (will remove background)
      closeBackgroundModal();
    }

    function applyBackground(characterName) {
      const messagesDiv = document.querySelector('.messages');
      const chatContainerDiv = document.getElementById('chatContainer');
      const inputAreaContainer = document.querySelector('.input-area-container');

      if (!messagesDiv || !chatContainerDiv || !inputAreaContainer) return;

      const character = characterName ? characters[characterName] : null;
      const backgroundImage = character?.backgroundImage;

      if (backgroundImage && currentMode === "personal") {
        chatContainerDiv.style.backgroundImage = `url(${backgroundImage})`;
        chatContainerDiv.style.backgroundSize = 'cover';
        chatContainerDiv.style.backgroundPosition = 'center';
        chatContainerDiv.style.backgroundRepeat = 'no-repeat';
        chatContainerDiv.classList.add('chat-container-custom-bg'); // Add class to adjust padding

        messagesDiv.classList.add('has-custom-background');
        inputAreaContainer.classList.add('has-custom-background-too');
      } else {
        chatContainerDiv.style.backgroundImage = 'none';
        chatContainerDiv.classList.remove('chat-container-custom-bg'); // Remove class to revert padding

        messagesDiv.classList.remove('has-custom-background');
        inputAreaContainer.classList.remove('has-custom-background-too');
      }
    }


    function setupAvatarClickHandler() {
      document.addEventListener('click', function(e) {
        const targetElement = e.target;
        // Check if clicked on an avatar in a message, or an attached image in a message, or an image in file preview
        if (targetElement.classList.contains('avatar')) {
          const avatarSrc = targetElement.src;
          previewImage(avatarSrc);
        }
        else if (targetElement.classList.contains('attached-image')) { // Image inside a message bubble
          const imageSrc = targetElement.src;
          previewImage(imageSrc);
        }
        else if (targetElement.tagName === 'IMG' && targetElement.closest('.file-preview-item')) { // Image in the file preview area before sending
             const imageSrc = targetElement.src;
             previewImage(imageSrc);
        }
      });
    }

    function previewImage(src) {
        // Remove existing modal if any
        const existingModal = document.querySelector('.avatar-preview-modal');
        if (existingModal) document.body.removeChild(existingModal);

        const modal = document.createElement('div');
        modal.className = 'avatar-preview-modal';
        // Basic styling for the modal (overlay)
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.background = 'rgba(0,0,0,0.8)'; // Dark overlay
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.style.zIndex = '2000'; // High z-index to be on top
        modal.style.cursor = 'zoom-out'; // Indicate it can be closed by clicking
        // Image styling within the modal
        modal.innerHTML = `
            <img src="${src}" style="max-width:90vw; max-height:90vh; object-fit:contain; border-radius: 8px; box-shadow: 0 5px 25px rgba(0,0,0,0.5);" />
        `;
        // Close modal on click
        modal.addEventListener('click', () => document.body.removeChild(modal));
        document.body.appendChild(modal);
    }


    function setupScrollHandler() {
      messagesBox.addEventListener("scroll", () => {
        // If user scrolls up, disable auto-scroll to bottom
        const nearBottom = messagesBox.scrollTop + messagesBox.clientHeight >= messagesBox.scrollHeight - 100;
        if (!nearBottom) {
            shouldScrollToBottom = false; // User has scrolled away from the bottom
        }
        // Auto-scroll is re-enabled when a new message is sent or bot responds (by setting shouldScrollToBottom = true)
      });
    }

    function showCustomAlert(message) {
        const messageBox = document.createElement('div');
        messageBox.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--accent-color);
            color: white;
            padding: 15px 25px;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 15px rgba(var(--accent-color-rgb), 0.3);
            z-index: 3000;
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            text-align: center;
        `;
        messageBox.textContent = message;
        document.body.appendChild(messageBox);
        setTimeout(() => {
            messageBox.style.opacity = 1;
        }, 10); // Small delay to trigger transition
        setTimeout(() => {
            messageBox.style.opacity = 0;
            messageBox.addEventListener('transitionend', () => messageBox.remove());
        }, 2000); // Disappear after 2 seconds
    }

    function showCustomConfirm(message, onConfirm) {
        const confirmBox = document.createElement('div');
        confirmBox.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-bg);
            color: var(--text-color);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            z-index: 3000;
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 350px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        `;
        confirmBox.innerHTML = `
            <p>${message}</p>
            <div style="display: flex; justify-content: center; gap: 10px;">
                <button id="confirmYes" class="send-button" style="margin:0;">Да</button>
                <button id="confirmNo" class="send-button" style="background: var(--participant-bg); color:var(--text-color); margin:0;">Нет</button>
            </div>
        `;
        document.body.appendChild(confirmBox);
        setTimeout(() => {
            confirmBox.style.opacity = 1;
        }, 10);

        document.getElementById('confirmYes').onclick = () => {
            onConfirm();
            confirmBox.remove();
        };
        document.getElementById('confirmNo').onclick = () => {
            confirmBox.remove();
        };
    }


    function setStatusActive(active) {
      const currentStatusIndicator = document.getElementById("messages-status-indicator");
      // The mobile prefix container and its cloned indicator might not always exist if the DOM structure changes.
      // It's safer to query for it within the mobile prefix div if it's consistently there.
      const mobilePrefixDiv = mainInputRow.querySelector('.mobile-input-prefix');
      const clonedStatusIndicator = mobilePrefixDiv ? mobilePrefixDiv.querySelector('#messages-status-indicator') : null;


      if (currentStatusIndicator) {
        currentStatusIndicator.classList.toggle("active", active);
        currentStatusIndicator.title = active ? "Нейросеть активна..." : "Нейросеть неактивна";
      }
      if (clonedStatusIndicator) { // Also update the cloned indicator if it exists (for mobile view)
        clonedStatusIndicator.classList.toggle("active", active);
        clonedStatusIndicator.title = active ? "Нейросеть активна..." : "Нейросеть неактивна";
      }
    }

  </script>
</body>
</html>
