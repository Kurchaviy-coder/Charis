<!DOCTYPE html>

<html lang="ru">
<head>
<meta name="google-site-verification" content="EYT4iauhkHMs9bSBaXSbFaN8w72haQYJa4JE_JBFwmY" />
<link rel="icon" href="/favicon.png" type="image/png" />
<link rel="apple-touch-icon" href="/logo-1024.png" sizes="1024x1024" />

<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>

<title>Charis Chat</title>
<meta name="description" content="Charis Chat — умный чат-бот на русском и английском. Поддерживает личные и групповые беседы.">

<!-- Open Graph -->
<meta property="og:title" content="Charis Chat – Личный и групповой чат с ИИ" />
<meta property="og:description" content="Charis Chat — умный чат-бот на русском и английском. Поддерживает личные и групповые беседы." />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://charis-chat.vercel.app/" />
<meta property="og:image" content="https://charis-chat.vercel.app/logo-1024.png" />
<meta property="og:image:width" content="1024" />
<meta property="og:image:height" content="1024" />
<meta property="og:locale" content="ru_RU" />
<meta property="og:locale:alternate" content="en_US" />

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Charis Chat" />
<meta name="twitter:description" content="Charis Chat — умный чат-бот на русском и английском. Поддерживает личные и групповые беседы." />
<meta name="twitter:image" content="https://charis-chat.vercel.app/logo-1024.png" />

<!-- JSON-LD: Организация -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "Organization",
      "name": "Charis Chat",
      "url": "https://charis-chat.vercel.app",
      "logo": "https://charis-chat.vercel.app/logo-1024.png"
    },
    {
      "@type": "WebSite",
      "url": "https://charis-chat.vercel.app",
      "name": "Charis Chat"
    }
  ]
}
</script>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>
<style>
    :root {
      --bg-color: #fdeef5;
      --accent-color: #ff7aac;
      --accent-gradient: linear-gradient(135deg, #ff7aac 0%, #ffb6d5 100%);
      --text-color: #E91E63; /* Default pink text color */
      --italic-text-color: #9E9E9E; /* Default light gray for italics */
      --bold-text-color: #E91E63; /* Default pink for bold (as per user, can be same as text-color) */
      --card-bg: #fff8fb;
      --card-bg-rgb: 255, 248, 251; /* RGB for --card-bg */
      --input-bg: #ffe8f2;
      --input-bg-rgb: 255, 232, 242; /* RGB for --input-bg */
      --border-radius: 16px;
      --participant-bg: #fff0f7;
      --participant-active-bg: #ff7aac;
      --shadow: 0 10px 35px 0 rgba(255, 122, 172, 0.15);
      --transition-fast: 0.2s ease-out;
      --transition-normal: 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      --bubble-user: #ffe8f2;
      --bubble-user-rgb: 255, 232, 242;
      --bubble-bot: #f0f8ff;
      --bubble-bot-rgb: 240, 248, 255;
      --bubble-system: #f5f5f5;
      --bubble-system-rgb: 245, 245, 245;
      --bubble-api: #e6fff5;
      --bubble-api-rgb: 230, 255, 245;
      --sidebar-bg: #fff5fa;
      --sidebar-accent: #ff6fa8;
      --sidebar-hover-bg: #ffe0ef;
      --sidebar-active-bg: #ff7aac;
      --button-hover-brightness: 1.08;
      --button-active-scale: 0.97;
      --accent-color-rgb: 255, 122, 172;
      --chat-font-size-multiplier: 1;
      --app-height: 100vh; /* Variable for dynamic viewport height */
      --sidebar-width: 280px;
      --sidebar-width-collapsed: 0px;
    }

    .dark-theme {
      --bg-color: #2c1d27;
      --accent-color: #ff8fbc;
      --accent-gradient: linear-gradient(135deg, #ff8fbc 0%, #ff6099 100%);
      --card-bg: #3b2a36;
      --card-bg-rgb: 59, 42, 54; /* RGB for dark --card-bg */
      --input-bg: #4f3548;
      --input-bg-rgb: 79, 53, 72; /* RGB for dark --input-bg */
      --participant-bg: #5c4055;
      --participant-active-bg: #ff6099;
      --bubble-user: #4f3548;
      --bubble-user-rgb: 79, 53, 72;
      --bubble-bot: #30404f;
      --bubble-bot-rgb: 48, 64, 79;
      --bubble-system: #4a4a4a;
      --bubble-system-rgb: 74, 74, 74;
      --bubble-api: #2a4f40;
      --bubble-api-rgb: 42, 79, 64;
      --sidebar-bg: #3b2a36;
      --sidebar-accent: #ff6099;
      --sidebar-hover-bg: #603050;
      --sidebar-active-bg: #ff6099;
      --shadow: 0 10px 35px 0 rgba(255, 96, 153, 0.3);
      --accent-color-rgb: 255, 143, 188;
    }

    html {
      height: -webkit-fill-available;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Montserrat', 'Segoe UI', sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      width: 100vw;
      overflow: hidden;
      transition: background 0.4s var(--transition-normal), color 0.4s var(--transition-normal);
      scroll-behavior: smooth;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      height: var(--app-height);
      min-height: var(--app-height);
    }

    body {
      display: flex;
      flex-direction: row;
    }

    .hamburger-btn {
        display: none;
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 1005;
        background: var(--accent-gradient);
        border: none;
        border-radius: 50%;
        width: 44px;
        height: 44px;
        cursor: pointer;
        box-shadow: 0 2px 10px rgba(var(--accent-color-rgb),0.3);
        align-items: center;
        justify-content: center;
        padding: 0;
    }
    .hamburger-btn span {
        display: block;
        width: 22px;
        height: 3px;
        background-color: white;
        border-radius: 3px;
        position: relative;
        transition: all 0.3s ease-in-out;
    }
    .hamburger-btn span::before,
    .hamburger-btn span::after {
        content: '';
        position: absolute;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: white;
        border-radius: 3px;
        transition: all 0.3s ease-in-out;
    }
    .hamburger-btn span::before { transform: translateY(-7px); }
    .hamburger-btn span::after { transform: translateY(7px); }

    .hamburger-btn.open span { background-color: transparent; }
    .hamburger-btn.open span::before { transform: rotate(45deg) translateY(0px); }
    .hamburger-btn.open span::after { transform: rotate(-45deg) translateY(0px); }


    .mobile-menu-container {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 280px;
        max-width: 80vw;
        height: var(--app-height);
        background-color: var(--sidebar-bg);
        box-shadow: 3px 0 15px rgba(0,0,0,0.2);
        z-index: 1000;
        transform: translateX(-100%);
        transition: transform 0.3s var(--transition-normal);
        overflow-y: auto;
        flex-direction: column;
    }
    .mobile-menu-container.open {
        transform: translateX(0);
    }
    .mobile-menu-header {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 1rem 1.2rem;
        border-bottom: 1px solid rgba(var(--accent-color-rgb),0.2);
        position: relative;
    }
    .mobile-menu-title {
        font-size: 1.3rem;
        font-weight: 600;
        color: var(--sidebar-accent);
    }
    .close-mobile-menu-btn {
        background: transparent;
        border: none;
        font-size: 2rem;
        color: var(--text-color);
        cursor: pointer;
        padding: 0.2rem;
        line-height: 1;
    }
    .mobile-menu-header .close-mobile-menu-btn {
        display: none;
    }

    #mobileMenuItemsPlaceholder {
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }
    #mobileMenuItemsPlaceholder .sidebar-header {
        text-align: left; padding: 0 0 0.5rem 0; border-bottom: none; font-size: 1.2rem;
    }
    #mobileMenuItemsPlaceholder .chat-list {
        flex-direction: column; gap: 0.5rem; padding: 0; max-height: 250px; overflow-y: auto;
    }
    #mobileMenuItemsPlaceholder .chat-item {
        width: 100%; box-sizing: border-box;
    }

    #mobileMenuItemsPlaceholder #themeToggle,
    #mobileMenuItemsPlaceholder #toggleSettingsBtn {
        position: static;
        width: 100%;
        border-radius: var(--border-radius);
        display: flex !important;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        padding: 0.8rem;
        font-size: 1rem;
    }
     #mobileMenuItemsPlaceholder #themeToggle svg { margin-right: 8px; }

    #mobileMenuItemsPlaceholder #themeToggle:hover,
    #mobileMenuItemsPlaceholder #toggleSettingsBtn:hover {
        transform: scale(1.02);
        filter: brightness(var(--button-hover-brightness));
        box-shadow: 0 4px 12px rgba(var(--accent-color-rgb),0.2);
    }

    #mobileMenuItemsPlaceholder #themeToggle:active,
    #mobileMenuItemsPlaceholder #toggleSettingsBtn:active {
        transform: scale(0.98);
        filter: brightness(0.95);
    }

    #sidebarToggleButton {
        background: var(--accent-gradient);
        color: white;
        border: none;
        cursor: pointer;
        width: 40px;
        height: 40px;
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 1001;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 1.1rem;
        font-weight: bold;
        box-shadow: 0 2px 10px rgba(var(--accent-color-rgb),0.25);
        border-radius: 50%;
        transition: background 0.2s var(--transition-fast), transform 0.2s var(--transition-fast), opacity 0.3s var(--transition-normal), filter 0.2s var(--transition-fast);
    }
    #sidebarToggleButton:hover {
        filter: brightness(var(--button-hover-brightness));
        transform: scale(1.05);
    }
    #sidebarToggleButton:active {
        transform: scale(var(--button-active-scale));
    }


    .sidebar {
      width: var(--sidebar-width);
      background-color: var(--sidebar-bg);
      border-right: 1px solid rgba(var(--accent-color-rgb),0.2);
      display: flex;
      flex-direction: column;
      padding: 1rem 0;
      box-shadow: 3px 0 15px rgba(var(--accent-color-rgb),0.05);
      overflow-y: auto;
      overflow-x: hidden;
      user-select: none;
      transition: width 0.3s var(--transition-normal), background 0.4s var(--transition-normal), border-color 0.4s var(--transition-normal), padding 0.3s var(--transition-normal);
      flex-shrink: 0;
      height: var(--app-height);
      position: sticky;
      top: 0;
    }
    .sidebar.collapsed {
      width: var(--sidebar-width-collapsed);
      padding: 1rem 0;
      border-right-width: 0;
    }
    .sidebar.collapsed .sidebar-header,
    .sidebar.collapsed .chat-list,
    .sidebar.collapsed .sidebar-footer {
        display: none;
    }

    .dark-theme .sidebar {
      border-color: rgba(var(--accent-color-rgb),0.3);
      box-shadow: 3px 0 15px rgba(var(--accent-color-rgb),0.15);
    }
    .sidebar-header {
      font-weight: 700;
      font-size: 1.5rem;
      color: var(--sidebar-accent);
      text-align: center;
      padding: 0 1rem 1.2rem 1rem;
      border-bottom: 1px solid rgba(var(--accent-color-rgb),0.2);
      transition: border-color 0.4s var(--transition-normal), color 0.4s var(--transition-normal);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      letter-spacing: 0.02em;
    }
    .dark-theme .sidebar-header {
      border-bottom: 1px solid rgba(var(--accent-color-rgb),0.3);
    }
    .chat-list {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      padding: 1rem;
    }
    .chat-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1.2rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      background: transparent;
      box-shadow: none;
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast), border-color var(--transition-fast);
      color: var(--text-color);
      position: relative;
      font-weight: 500;
      font-size: 1rem;
      border: 1px solid transparent;
    }
    .chat-item:hover {
      background: var(--sidebar-hover-bg);
      box-shadow: 0 4px 12px rgba(var(--accent-color-rgb),0.1);
      transform: translateX(4px);
      border-color: rgba(var(--accent-color-rgb),0.3);
    }
    .chat-item.active {
      background: var(--sidebar-active-bg);
      color: #fff;
      box-shadow: 0 6px 18px rgba(var(--accent-color-rgb),0.25);
      transform: translateX(0);
      font-weight: 600;
      border-color: transparent;
    }
    .chat-item img {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      flex-shrink: 0;
      transition: border-color 0.4s var(--transition-normal);
    }
    .dark-theme .chat-item img {
      border-color: var(--accent-color);
    }
    .chat-item .chat-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-grow: 1;
    }
    .delete-char-btn {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: transparent;
      border: none;
      color: var(--text-color);
      opacity: 0.6;
      font-weight: 700;
      cursor: pointer;
      font-size: 18px;
      padding: 0;
      line-height: 1;
      transition: color var(--transition-fast), opacity var(--transition-fast);
    }
    .delete-char-btn:hover {
      color: #ff0055;
      opacity: 1;
    }

    .main-content {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      background: var(--bg-color);
      position: relative;
      height: var(--app-height);
      max-height: var(--app-height);
      overflow: hidden;
      transition: background 0.4s var(--transition-normal), width 0.3s var(--transition-normal);
      width: calc(100% - var(--sidebar-width));
    }
    .sidebar.collapsed + .main-content {
        width: calc(100% - var(--sidebar-width-collapsed));
    }


    .chat-container {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      min-height: 0;
      padding: 1rem 0 0.2rem 1.5rem;
      overflow: hidden;
      position: relative;
      background: var(--card-bg);
      transition: background-image 0.4s var(--transition-normal), background-color 0.4s var(--transition-normal), padding 0.4s var(--transition-normal);
    }
    .chat-container.chat-container-custom-bg {
        padding-left: 0px;
        padding-bottom: 0px;
    }


    .toggle-mode {
      margin-bottom: 1.5rem;
      text-align: center;
      user-select: none;
      display: flex;
      justify-content: center;
      gap: 1rem;
      padding: 0.5rem 0;
      flex-shrink: 0;
    }
    .toggle-mode button {
      background: transparent;
      color: var(--accent-color);
      border: 2px solid var(--accent-color);
      padding: 0.6rem 1.8rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: background var(--transition-fast), color var(--transition-fast), box-shadow var(--transition-fast), transform 0.1s ease-out;
      outline: none;
      letter-spacing: 0.01em;
    }
    .toggle-mode button.selected, .toggle-mode button:hover {
      background: var(--accent-gradient);
      color: #fff;
      box-shadow: 0 3px 12px rgba(var(--accent-color-rgb),0.2);
      border-color: transparent;
    }
    .toggle-mode button:active {
      transform: scale(var(--button-active-scale));
      transition-duration: 0.05s;
    }

    #groupParticipants {
      display: none;
      margin-bottom: 1.5rem;
      padding: 0.75rem;
      background: var(--participant-bg);
      border-radius: var(--border-radius);
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05), var(--shadow);
      overflow-x: auto;
      white-space: nowrap;
      user-select: none;
      transition: background 0.4s var(--transition-normal), box-shadow 0.4s var(--transition-normal);
      flex-shrink: 0;
      animation: slideDownFadeIn 0.4s var(--transition-normal) forwards;
    }
    .dark-theme #groupParticipants {
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1), var(--shadow);
    }
    #groupParticipants .participant {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0.5rem 0.8rem;
      border-radius: calc(var(--border-radius) - 4px);
      background: rgba(255,255,255,0.8);
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      margin-right: 0.8rem;
      min-width: 75px;
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
      color: var(--text-color);
      font-weight: 500;
      font-size: 0.9rem;
    }
    .dark-theme #groupParticipants .participant {
      background: rgba(255,255,255,0.1);
    }
    #groupParticipants .participant:hover {
      background: #fff;
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .dark-theme #groupParticipants .participant:hover {
      background: rgba(255,255,255,0.2);
    }
    #groupParticipants .participant.active {
      background: var(--participant-active-bg);
      color: #fff;
      box-shadow: 0 5px 15px rgba(var(--accent-color-rgb),0.3);
      transform: scale(1.08);
      font-weight: 600;
    }
    #groupParticipants .participant img {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      object-fit: cover;
      margin-bottom: 0.3rem;
      border: 2px solid #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .dark-theme #groupParticipants .participant img {
      border-color: var(--accent-color);
    }

    #settingsModal, #lorebookModal, #backgroundModal, #greetingSelectModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.65);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.25s ease-out;
      padding: 1rem;
      box-sizing: border-box;
    }
    #settingsModal.above-hamburger,
    #lorebookModal.above-hamburger,
    #backgroundModal.above-hamburger,
    #greetingSelectModal.above-hamburger {
        z-index: 1010;
    }

    #settingsModal[style*="display: flex"],
    #lorebookModal[style*="display: flex"],
    #backgroundModal[style*="display: flex"],
    #greetingSelectModal[style*="display: flex"] {
      opacity: 1;
    }
    .settings-content, 
@keyframes slideUpFadeInModal {
      from { opacity: 0.5; transform: translateY(20px) scale(0.98); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    .dark-theme .settings-content, .dark-theme .greeting-select-content {
      background: var(--card-bg);
    }
    .settings-content .close-btn, .greeting-select-content .close-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      background: transparent;
      border: none;
      font-size: 28px;
      line-height: 1;
      padding: 5px;
      cursor: pointer;
      color: var(--text-color);
      opacity: 0.7;
      transition: opacity var(--transition-fast), transform var(--transition-fast);
      transform-origin: center;
    }
    .settings-content .close-btn:hover, .greeting-select-content .close-btn:hover {
      opacity: 1;
      transform: rotate(90deg);
    }

    .settings {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem 1.5rem;
    }

    .settings-content fieldset {
      border: 1px solid rgba(var(--accent-color-rgb), 0.3);
      border-radius: var(--border-radius);
      padding: 1rem 1.2rem;
      margin-bottom: 1rem;
      background: rgba(var(--accent-color-rgb), 0.03);
    }
    .dark-theme .settings-content fieldset {
      border-color: rgba(var(--accent-color-rgb), 0.4);
      background: rgba(var(--accent-color-rgb), 0.06);
    }
    .settings-content legend {
      font-weight: 600;
      color: var(--accent-color);
      padding: 0 0.5rem;
      font-size: 1.1rem;
    }

    .settings-content .settings > fieldset {
      grid-column: span 2;
    }

    .settings-content .settings > .fieldset-span-1 {
      grid-column: span 1;
    }

    .settings-content label {
        color: var(--text-color);
        display: block;
        margin-bottom: 0.3rem;
        font-weight: 500;
    }
    .settings-content input, .settings-content textarea, .settings-content select, .settings-content input[type="color"] {
      width: 100%;
      margin-bottom: 0.5rem;
      padding: 0.8rem 1rem;
      font-size: 0.95rem;
      background-color: var(--input-bg);
      border: 1px solid transparent;
      border-radius: calc(var(--border-radius) - 6px);
      color: var(--text-color);
      transition: box-shadow var(--transition-fast), background var(--transition-fast), border-color var(--transition-fast);
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
      font-family: inherit;
      outline: none;
      font-weight: 500;
      box-sizing: border-box;
    }
     .settings-content input[type="color"] {
        padding: 0.2rem;
        height: 40px;
    }
    .settings-content input[type="range"] {
        padding: 0.2rem 0;
    }
    .settings-content .font-size-indicator {
        display: inline-block;
        margin-left: 10px;
        font-weight: 500;
        color: var(--text-color);
    }
    .settings-content input:focus, .settings-content textarea:focus, .settings-content select:focus, .settings-content input[type="color"]:focus {
      box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb), 0.3);
      border-color: var(--accent-color);
      background: #fff;
    }
    .dark-theme .settings-content input:focus, .dark-theme .settings-content textarea:focus, .dark-theme .settings-content select:focus, .dark-theme .settings-content input[type="color"]:focus {
      background: var(--sidebar-hover-bg);
      border-color: var(--accent-color);
    }
    .settings-content textarea {
      min-height: 100px;
      max-height: 250px;
      resize: vertical;
    }
    .settings-content .avatar-selection {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .settings-content .settings .avatar-selection {
        grid-column: span 1;
    }

    .settings-content button,
    #lorebookModal button[type="button"],
    #backgroundModal button[type="button"],
    .greeting-select-content button {
      background: var(--accent-gradient);
      color: #fff;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(var(--accent-color-rgb),0.15);
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast), filter var(--transition-fast);
      outline: none;
      letter-spacing: 0.01em;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .settings-content button:hover,
    #lorebookModal button[type="button"]:hover,
    #backgroundModal button[type="button"]:hover,
    .greeting-select-content button:hover {
      filter: brightness(var(--button-hover-brightness));
      box-shadow: 0 4px 15px rgba(var(--accent-color-rgb),0.25);
      transform: translateY(-1px);
    }
    .settings-content button:active,
    #lorebookModal button[type="button"]:active,
    #backgroundModal button[type="button"]:active,
    .greeting-select-content button:active {
      transform: scale(var(--button-active-scale)) translateY(0);
      filter: brightness(0.95);
    }
    .settings-content .avatar-selection button {
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
    }

    .switch { position: relative; display: inline-block; width: 50px; height: 28px; margin-bottom: 0.4rem;}
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .3s var(--transition-normal); border-radius: 28px; }
    .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .3s var(--transition-normal); border-radius: 50%; }
    input:checked + .slider { background-color: var(--accent-color); }
    input:focus + .slider { box-shadow: 0 0 1px var(--accent-color); }
    input:checked + .slider:before { transform: translateX(22px); }

    .messages {
      flex-grow: 1;
      overflow-y: auto;
      padding: 1rem 0.5rem;
      background-color: transparent;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      transition: background 0.4s var(--transition-normal), background-color 0.4s var(--transition-normal);
      scroll-behavior: smooth;
      position: relative;
      white-space: pre-wrap;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      font-size: calc(1.05rem * var(--chat-font-size-multiplier));
      line-height: calc(1.5 * var(--chat-font-size-multiplier));
      color: var(--text-color);
      user-select: text;
      min-height: 150px;
    }
    .messages.has-custom-background .message {
        background-color: rgba(var(--bubble-bot-rgb), 0.85);
    }
    .messages.has-custom-background .message.user {
        background-color: rgba(var(--bubble-user-rgb), 0.85);
    }
    .messages.has-custom-background .message.api {
        background-color: rgba(var(--bubble-api-rgb), 0.85);
    }
    .messages.has-custom-background .message.system {
        background-color: rgba(var(--bubble-system-rgb), 0.85);
        color: var(--text-color);
    }
    .dark-theme .messages.has-custom-background .message.system {
        color: var(--text-color);
    }


    .dark-theme .messages {
      color: var(--text-color);
    }
    .message-container {
      display: flex;
      flex-direction: column;
      margin-bottom: 1.2rem;
      opacity: 0;
      animation: messageFadeInUp 0.4s var(--transition-normal) forwards;
      position: relative;
      width: 100%;
      box-sizing: border-box;
    }
    .message-content-wrapper {
        display: flex;
        align-items: flex-start;
        width: 100%;
    }
    .message-container.user-container .message-content-wrapper {
        justify-content: flex-end;
    }

    @keyframes messageFadeInUp {
      0% { opacity: 0; transform: translateY(15px); }
      100% { opacity: 1; transform: translateY(0); }
    }
    .avatar {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      object-fit: cover;
      margin-right: 0.8rem;
      border: 2px solid var(--accent-color);
      box-shadow: 0 2px 10px rgba(var(--accent-color-rgb),0.1);
      transition: border-color 0.4s var(--transition-normal);
      background: #fff;
      flex-shrink: 0;
      cursor: pointer;
    }
    .dark-theme .avatar {
      border-color: var(--accent-color);
      box-shadow: 0 2px 10px rgba(var(--accent-color-rgb),0.4);
      background: var(--card-bg);
    }
    .message {
      word-wrap: break-word;
      flex: 0 1 auto;
      max-width: calc(75% - 40px);
      background: var(--bubble-bot);
      padding: 0.75rem 1.1rem;
      border-radius: 1.2em 1.2em 1.2em 0.5em;
      line-height: 1.45;
      box-shadow: 0 2px 5px rgba(0,0,0,0.08);
      transition: background 0.3s var(--transition-normal), color 0.3s var(--transition-normal);
      position: relative;
      color: var(--text-color);
      white-space: pre-wrap;
    }

    .message em, .message i {
        color: var(--italic-text-color);
        font-style: italic;
    }
    .message strong, .message b {
        color: var(--bold-text-color);
        font-weight: bold;
    }
    .dark-theme .message em, .dark-theme .message i {
        color: var(--italic-text-color);
    }
    .dark-theme .message strong, .dark-theme .message b {
        color: var(--bold-text-color);
    }

    .message .attachments-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 0.5rem;
        margin-top: 0.5rem;
    }
    .message img.attached-image, .message .attached-file-preview {
        max-width: 100%;
        height: auto;
        max-height: 120px;
        border-radius: calc(var(--border-radius) - 8px);
        display: block;
        cursor: zoom-in;
        object-fit: cover;
    }
    .message a.attached-file-link {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        margin-top: 0.5rem;
        padding: 0.5rem;
        background-color: rgba(var(--accent-color-rgb), 0.1);
        color: var(--accent-color);
        border-radius: calc(var(--border-radius) - 8px);
        text-decoration: none;
        font-size: 0.9em;
        font-weight: 500;
        word-break: break-all;
        height: 100px;
    }
    .message a.attached-file-link:hover {
        background-color: rgba(var(--accent-color-rgb), 0.2);
    }
    .message a.attached-file-link .file-icon {
        font-size: 2rem;
        margin-bottom: 0.3rem;
    }


    .dark-theme .message {
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .message p { margin: 0.3em 0; padding: 0; }
    .message h1, .message h2, .message h3, .message h4, .message h5, .message h6 { display: block; font-size: 1.1em; font-weight: bold; margin-top: 0.5em; margin-bottom: 0.2em;}
    .message ul, .message ol { margin: 0.5em 0; padding-left: 1.8em; }
    .message.user {
      background: var(--bubble-user);
      border-radius: 1.2em 1.2em 0.5em 1.2em;
      font-weight: 500;
    }
    .message-container.user-container .message-content-wrapper .avatar {
        order: 1;
        margin-left: 0.8rem;
        margin-right: 0;
    }
    .message.api { background: var(--bubble-api); }
    .message.system { background: var(--bubble-system); color: #777; font-style: italic; font-size: 0.9em; max-width: 100%; text-align: center; }
    .dark-theme .message.system { color: #bbb; }

    .message-buttons {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      margin-top: 0.5rem;
      padding-left: calc(44px + 0.8rem);
      width: fit-content;
    }
    .message-container.user-container .message-buttons {
      padding-left: 0;
      padding-right: calc(44px + 0.8rem);
      margin-left: auto;
    }

    .message-buttons button {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      background: var(--accent-gradient);
      color: #fff;
      font-size: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast), filter var(--transition-fast);
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .message-buttons button:hover {
      filter: brightness(var(--button-hover-brightness));
      box-shadow: 0 2px 6px rgba(var(--accent-color-rgb),0.2);
      transform: scale(1.1);
    }
    .message-buttons button:active {
      transform: scale(var(--button-active-scale)) translateY(0);
    }
    .message-buttons button:disabled {
        background: #ccc;
        cursor: not-allowed;
        filter: grayscale(50%);
    }
    .message-buttons .delete-btn::before { content: "🗑️"; }
    .message-buttons .regen-btn::before { content: "🔄"; }
    .message-buttons .edit-btn::before { content: "✏️"; }
    .message-buttons .copy-btn::before { content: "📋"; }

    /* --- СТИЛИ ДЛЯ РЕДАКТИРОВАНИЯ СООБЩЕНИЙ (ИСПРАВЛЕНО) --- */
    .message-edit-area {
      width: 100%; /* Заполняет родительский элемент, но ограничивается max-width */
      max-width: 75%; /* Ограничение ширины, как у обычного сообщения */
      box-sizing: border-box; /* Чтобы padding не влиял на общую ширину */
      min-height: 80px;
      max-height: 200px;
      resize: vertical;
      font-size: inherit;
      padding: 0.7rem 1rem;
      border-radius: var(--border-radius);
      border: 1px solid var(--accent-color);
      background: var(--input-bg);
      color: var(--text-color);
      font-family: inherit;
      box-shadow: 0 2px 8px rgba(var(--accent-color-rgb),0.2);
      margin-bottom: 0.5rem;
      outline: none;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .message-container:not(.user-container) .message-edit-area {
        margin-left: calc(44px + 0.8rem); /* Отступ слева для сообщений бота */
    }
    .message-container.user-container .message-edit-area {
        margin-left: auto; /* Авто-отступ слева для выравнивания по правому краю */
        margin-right: calc(44px + 0.8rem); /* Отступ справа для сообщений пользователя */
    }
    .dark-theme .message-edit-area {
      box-shadow: 0 2px 8px rgba(var(--accent-color-rgb),0.5);
    }
    .edit-button-container {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem;
        padding-left: calc(44px + 0.8rem);
    }
    .message-container.user-container .edit-button-container {
        padding-left: 0;
        padding-right: calc(44px + 0.8rem);
        justify-content: flex-end;
    }


    .input-area-container {
        padding: 0.3rem 0;
        border-top: 1px solid rgba(var(--accent-color-rgb),0.2);
        background: var(--card-bg);
        flex-shrink: 0;
        transition: border-color 0.4s var(--transition-normal), background-color 0.4s var(--transition-normal);
    }
    .dark-theme .input-area-container {
        border-top: 1px solid rgba(var(--accent-color-rgb),0.3);
    }
    /* --- СТИЛИ ДЛЯ ПРОЗРАЧНОГО ВВОДА (ИСПРАВЛЕНО) --- */
    .input-area-container.has-custom-background-too {
        background-color: rgba(var(--card-bg-rgb), 0.65) !important;
        border-top-color: rgba(var(--accent-color-rgb), 0.2) !important;
        -webkit-backdrop-filter: blur(4px);
        backdrop-filter: blur(4px);
    }
    .input-area-container.has-custom-background-too #userInput {
        background-color: rgba(var(--input-bg-rgb), 0.7) !important;
        color: var(--text-color);
    }
    .dark-theme .input-area-container.has-custom-background-too #userInput {
        background-color: rgba(var(--input-bg-rgb), 0.7) !important;
    }


    #filePreviewsContainer {
        display: none;
        flex-wrap: wrap;
        gap: 0.5rem;
        padding: 0.5rem 0.5rem 0.3rem 0.5rem;
        max-height: 120px;
        overflow-y: auto;
        border-bottom: 1px solid rgba(var(--accent-color-rgb),0.1);
    }
    .file-preview-item {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: var(--input-bg);
        border-radius: calc(var(--border-radius) - 8px);
        padding: 0.3rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        width: 80px;
        height: 80px;
    }
    .file-preview-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: calc(var(--border-radius) - 10px);
    }
    .file-preview-item .file-info {
        font-size: 0.7rem;
        color: var(--text-color);
        text-align: center;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        width: 100%;
        margin-top: 0.2rem;
    }
    .file-preview-item .file-icon-placeholder {
        font-size: 2rem;
        color: var(--accent-color);
        flex-grow: 1;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .remove-file-btn {
        position: absolute;
        top: -5px;
        right: -5px;
        background: rgba(0,0,0,0.6);
        color: white;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        font-size: 12px;
        line-height: 20px;
        text-align: center;
        cursor: pointer;
        z-index: 1;
    }


    .input-row {
      display: flex;
      align-items: flex-end; /* ИСПРАВЛЕНО: выравнивание по нижнему краю */
      gap: 0.5rem;
      position: relative;
      padding: 0 0.5rem;
    }

    .mobile-input-prefix {
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 0.4rem;
        flex-shrink: 0;
    }

    #userInput {
      flex-grow: 1;
      padding: 0.8rem 1rem;
      font-size: 1rem;
      border-radius: var(--border-radius);
      border: 1px solid transparent;
      background-color: var(--input-bg);
      color: var(--text-color);
      resize: none;
      transition: box-shadow var(--transition-fast), background var(--transition-fast), border-color var(--transition-fast);
      font-family: inherit;
      min-height: 44px;
      max-height: 150px;
      outline: none;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
      overflow-y: auto;
      line-height: 1.4;
      box-sizing: border-box; /* Добавлено для предсказуемости размеров */
    }
    #userInput:focus {
      box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb), 0.3);
      border-color: var(--accent-color);
      background: #fff;
    }
    .dark-theme #userInput:focus {
      background: var(--sidebar-hover-bg);
    }
    button.send-button, .file-attach-button {
      background: var(--accent-gradient);
      color: #fff;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-weight: 600;
      transition: filter var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
      outline: none;
      white-space: nowrap;
      user-select: none;
      box-shadow: 0 2px 8px rgba(var(--accent-color-rgb),0.15);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      box-sizing: border-box; /* Добавлено для предсказуемости размеров */
    }
    button.send-button:hover, .file-attach-button:hover {
      filter: brightness(var(--button-hover-brightness));
      box-shadow: 0 4px 15px rgba(var(--accent-color-rgb),0.25);
      transform: translateY(-1px);
    }
    button.send-button:active, .file-attach-button:active {
      transform: scale(var(--button-active-scale)) translateY(0);
      filter: brightness(0.95);
    }
    button.send-button#sendButton {
      padding: 0.8rem 1.5rem; /* Скорректировано для соответствия высоте textarea */
      height: 44px; /* Явная высота */
      font-size: 1rem;
      letter-spacing: 0.02em;
    }
    .file-attach-button {
      width: 44px;
      height: 44px;
      font-size: 18px;
    }
    input#fileInput { display: none; }

    .status-container {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.3rem;
      padding: 0 0.5rem;
      flex-wrap: wrap;
    }
    #messages-status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ccc;
      box-shadow: 0 0 8px #ccc;
      transition: background 0.3s var(--transition-normal), box-shadow 0.3s var(--transition-normal);
      flex-shrink: 0;
      margin-bottom: 16px; /* Выравнивание с кнопками */
    }
    #messages-status-indicator.active {
      background: #4CAF50;
      box-shadow: 0 0 12px #4CAF50;
      animation: pulseIndicator 1.8s infinite ease-in-out;
    }
    @keyframes pulseIndicator {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
    }
    .status-container button {
        padding: 0.5rem 1rem;
        font-size: 0.85rem;
        background: var(--participant-bg);
        color: var(--text-color);
        border: 1px solid var(--accent-color);
    }
    .status-container button:hover {
        background: var(--sidebar-hover-bg);
    }
    .status-container button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    #variantCounter {
        font-weight: 600;
        font-size: 0.9rem;
        user-select: none;
        color: var(--accent-color);
    }

    .memory-box {
      background: var(--input-bg);
      border-radius: calc(var(--border-radius) - 6px);
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
      padding: 0.8rem 1rem;
      font-size: 0.95rem;
      color: var(--text-color);
      resize: vertical;
      min-height: 80px;
      max-height: 150px;
      width: 100%;
      font-family: inherit;
      border: 1px solid transparent;
      outline: none;
      transition: box-shadow var(--transition-fast), background var(--transition-fast), border-color var(--transition-fast);
      font-weight: 500;
      box-sizing: border-box;
    }
    .memory-box:focus {
      box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb), 0.3);
      border-color: var(--accent-color);
      background: #fff;
    }
    .dark-theme .memory-box {
      background: var(--input-bg);
    }
    .dark-theme .memory-box:focus {
      background: var(--sidebar-hover-bg);
    }

    #themeToggle, #toggleSettingsBtn {
      position: fixed;
      background: var(--accent-gradient);
      border: none;
      border-radius: 50%;
      width: 52px;
      height: 52px;
      cursor: pointer;
      box-shadow: 0 4px 18px rgba(var(--accent-color-rgb),0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s var(--transition-normal), transform 0.2s var(--transition-fast), box-shadow 0.3s var(--transition-normal), filter 0.2s var(--transition-fast);
      z-index: 100;
      outline: none;
    }
    #themeToggle:hover, #toggleSettingsBtn:hover {
      filter: brightness(var(--button-hover-brightness));
      transform: scale(1.1) rotate(5deg);
      box-shadow: 0 6px 22px rgba(var(--accent-color-rgb),0.4);
    }
    #themeToggle:active, #toggleSettingsBtn:active {
      transform: scale(var(--button-active-scale));
    }
    #themeToggle { top: 20px; right: 20px; }
    #toggleSettingsBtn { top: 85px; right: 20px; }
    #themeToggle svg { fill: white; width: 24px; height: 24px; transition: transform 0.4s ease-in-out; }
    .dark-theme #themeToggle svg { transform: rotate(180deg); }
    #toggleSettingsBtn span { font-size: 22px; color: white; }

    #lorebookModal .settings-content { max-width: 600px; }
    .lorebook-entry {
      margin-bottom: 1rem;
      padding: 1rem;
      background: rgba(0,0,0,0.03);
      border-radius: calc(var(--border-radius) - 4px);
      border: 1px solid rgba(var(--accent-color-rgb),0.2);
    }
    .dark-theme .lorebook-entry {
        background: rgba(255,255,255,0.04);
        border-color: rgba(var(--accent-color-rgb),0.3);
    }
    .lorebook-entry label { display: block; font-weight: 500; margin-bottom: 0.3rem; font-size: 0.9rem; color: var(--accent-color); }
    .lorebook-entry input, .lorebook-entry textarea {
      width: 100%;
      margin-bottom: 0.5rem;
      box-sizing: border-box;
    }
    .lorebook-entry textarea { min-height: 80px; }

    #backgroundModal .settings-content { max-width: 450px; text-align: center; }
    #backgroundModal input[type="file"] { display: block; margin: 1rem auto; }

    @keyframes slideDownFadeIn {
      from { opacity: 0; transform: translateY(-15px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes slideUpFadeIn {
      from { opacity: 0; transform: translateY(15px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    @media (max-width: 900px) {
      body {
        flex-direction: column;
        overflow-y: hidden;
        height: var(--app-height);
      }

      .hamburger-btn { display: flex; }
      .mobile-menu-container { display: flex; }

      #sidebarToggleButton { display: none !important; }
      .sidebar { display: none !important; }

      body > #themeToggle, body > #toggleSettingsBtn { display: none !important; }


      .main-content {
          width: 100% !important;
          min-height: 0;
          flex-grow: 1;
          overflow: hidden;
          height: 100%;
      }
      .chat-container {
          padding: 0.8rem 0 0.3rem 0.8rem;
      }
      .chat-container.chat-container-custom-bg {
          padding-left: 0px;
          padding-bottom: 0px;
      }

      .messages {
          padding-left: 0.1rem;
          padding-right: 0.8rem;
      }

      .message-content-wrapper {
          flex-direction: column;
      }
      .message-container .message-content-wrapper {
          align-items: flex-start;
      }
      .message-container.user-container .message-content-wrapper {
          align-items: flex-end;
      }

      .avatar {
          width: 30px;
          height: 30px;
          margin-right: 0;
          margin-left: 0;
          margin-bottom: 0.3rem;
      }
      .message-container.user-container .message-content-wrapper .avatar {
          order: 0;
      }

      .message {
          max-width: 100%;
          padding: 0.5rem 0.8rem;
      }

      .message-buttons {
          padding: 0 0.8rem;
          box-sizing: border-box;
          width: 100%;
          margin-left: 0;
          margin-right: 0;
      }
      .message-container .message-buttons {
          justify-content: flex-start;
      }
      .message-container.user-container .message-buttons {
          justify-content: flex-end;
          padding-right: 0 !important;
      }

      .edit-button-container {
          padding: 0 0.8rem;
          box-sizing: border-box;
          width: 100%;
          margin-left: 0;
          margin-right: 0;
      }
      .message-container .edit-button-container {
          justify-content: flex-start;
      }
      .message-container.user-container .edit-button-container {
          justify-content: flex-end;
          padding-right: 0 !important;
      }

      #groupParticipants { margin-bottom: 1rem; }


      .input-area-container {
        padding: 0.5rem;
      }
      .input-row {
        flex-wrap: nowrap;
        align-items: center; /* На мобильных вернем центрирование */
        gap: 0.4rem;
        padding: 0;
      }
      .mobile-input-prefix {
        display: flex;
      }

      .input-row > .file-attach-button:not(.mobile-input-prefix .file-attach-button),
      .input-row > #messages-status-indicator:not(.mobile-input-prefix #messages-status-indicator) {
        display: none !important;
      }


      #userInput {
        font-size: 0.95rem;
        padding: 0.7rem 0.9rem;
        min-height: 80px;
      }
      button.send-button#sendButton {
        width: 40px;
        height: 40px;
        padding: 0;
        font-size: 1.2rem;
        line-height: 1;
        border-radius: 50%;
        flex-shrink: 0;
        margin-left: 0.4rem;
      }

      .mobile-input-prefix .file-attach-button {
        width: 40px;
        height: 40px;
        font-size: 1.1rem;
        flex-shrink: 0;
      }
      .mobile-input-prefix #messages-status-indicator {
          margin: 0;
          flex-shrink: 0;
          width: 12px;
          height: 12px;
      }
      #messages-status-indicator {
        margin-bottom: 0;
      }

      .settings-content .settings {
        grid-template-columns: 1fr;
      }
      .settings-content .settings > .fieldset-span-1 {
        grid-column: span 1;
      }
      .settings-content .settings .avatar-selection {
        flex-direction: column;
        align-items: stretch;
        grid-column: span 1;
      }
      .settings-content .settings .avatar-selection button {
        width: 100%;
        margin-bottom: 0.5rem;
      }
      .settings-content { padding: 1rem 1.2rem; max-height: 80vh; }


      .message-buttons button { width: 28px; height: 28px; font-size: 14px; }
    }
    @media (min-width: 901px) {
        .hamburger-btn {
            display: none !important;
        }
        #sidebarToggleButton {
            display: flex !important;
        }
        .sidebar {
            display: flex !important;
        }
    }


    @media (max-width: 480px) {
      .avatar {
          width: 28px;
          height: 28px;
          margin-bottom: 0.2rem;
      }
      .message {
          padding: 0.4rem 0.7rem;
      }

      .input-row { gap: 0.2rem; }
      #userInput { min-height: 70px; padding: 0.6rem 0.8rem; font-size: 0.9rem; }
      button.send-button#sendButton,
      .mobile-input-prefix .file-attach-button {
        width: 38px;
        height: 38px;
      }
      .mobile-input-prefix { margin-right: 0.3rem; }


      .memory-box { font-size: 0.9rem; padding: 0.7rem; }
      .settings-content { padding: 1rem; }
      .settings-content legend {font-size: 1rem;}
      .settings-content input, .settings-content textarea, .settings-content select {font-size: 0.9rem; padding: 0.7rem 0.9rem;}
      .settings-content button {font-size: 0.9rem; padding: 0.7rem 1.2rem;}


      .hamburger-btn { top: 10px; left: 10px; width: 40px; height: 40px; }
      .hamburger-btn span { width: 20px; height: 2.5px;}
      .hamburger-btn span::before { transform: translateY(-6px); }
      .hamburger-btn span::after { transform: translateY(6px); }
    }

  </style>
<meta content="Charis — это умный чат-бот на русском и английском, поддерживающий личные и групповые беседы. Работает на LLM с поддержкой API." name="description"/><meta content="чат-бот, ИИ, Charis, AI chatbot, русская нейросеть, group chat, personal assistant" name="keywords"/><meta content="Charis" name="author"/><meta content="Чат-бот Charis – Личный и групповой чат" property="og:title"/><meta content="Умный AI чат-бот для личного и группового общения. Работает на русском и английском языках." property="og:description"/><meta content="website" property="og:type"/><meta content="https://charis.vercel.app" property="og:url"/><meta content="ru_RU" property="og:locale"/><meta content="en_US" property="og:locale:alternate"/><meta content="summary" name="twitter:card"/><meta content="Чат-бот Charis" name="twitter:title"/><meta content="Умный AI чат-бот с поддержкой русского и английского. Подходит для общения и тестирования LLM." name="twitter:description"/></meta>
<style>
/* Mobile tab styles - hidden by default (so PC is unaffected) */
.settings-content .tab-buttons { display: none; }
.settings-content .tab-page { display: block; }

@media (max-width: 900px) {
  .settings-content .tab-buttons {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    overflow-x: auto;
  }
  .settings-content .tab-buttons button {
    flex: 1;
    padding: 0.6rem;
    font-size: 0.9rem;
    border: 1px solid var(--accent-color);
    border-radius: var(--border-radius);
    background: var(--card-bg);
    color: var(--text-color);
    white-space: nowrap;
  }
  .settings-content .tab-buttons button.active {
    background: var(--accent-gradient);
    color: #fff;
    border-color: transparent;
  }
  .settings-content .tab-page {
    display: none;
    flex-direction: column;
    gap: 1rem;
  }
  .settings-content .tab-page.active {
    display: flex;
  }
  /* Ensure settings grid becomes single column on mobile (for compatibility) */
  .settings-content .settings { display: block; }
}
</style>
<style>
/* Mobile actions panel - hidden on desktop */
.settings-content .mobile-actions { display: none; }

/* buttons look compact on mobile */
.settings-content .mobile-actions .mobile-action-btn {
  padding: 0.6rem 0.8rem;
  border-radius: 10px;
  border: 1px solid rgba(var(--accent-color-rgb),0.12);
  background: var(--input-bg);
  color: var(--text-color);
  font-weight: 600;
  width: 100%;
  box-sizing: border-box;
}

/* two-column small screens */
@media (max-width: 480px) {
  .settings-content .mobile-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 0.4rem; }
}
@media (min-width: 481px) and (max-width:900px) {
  .settings-content .mobile-actions { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; }
  .settings-content .mobile-actions .mobile-action-btn { padding: 0.6rem; }
}
/* Keep hidden on desktop explicitly */
@media (min-width: 901px) {
  .settings-content .mobile-actions { display: none !important; }
}
</style><style>
@media (min-width: 901px) {
  .settings-content .tab-buttons { display: none !important; }
}
</style><style>
@media (max-width: 900px) {
  .settings-content .mobile-actions { 
    display: flex !important; 
  }
  .settings-content .mobile-actions button {
    flex: 1 1 calc(50% - 0.5rem);
    min-width: 120px;
  }
}
@media (max-width: 480px) {
  .settings-content .mobile-actions button {
    flex: 1 1 100%;
  }
}
@media (min-width: 901px) {
  .settings-content .mobile-actions {
    display: none !important;
  }
}
</style>
<style>
/* show mobile color picker only on mobile */
.settings-content .mobile-color-picker { display: none; }
@media (max-width: 900px) {
  .settings-content .mobile-color-picker { display: block !important; }
  .settings-content .mobile-actions { display: grid !important; grid-template-columns: repeat(2, 1fr); gap:0.5rem; }
  .settings-content .mobile-actions .mobile-action-btn { width:100%; }
}
</style>

<!-- MODAL STYLES IMPORTED FROM index_animation_fixed.html -->
<style>
    :root {
      --bg-color: #fdeef5;
      --accent-color: #ff7aac;
      --accent-gradient: linear-gradient(135deg, #ff7aac 0%, #ffb6d5 100%);
      --text-color: #E91E63; /* Default pink text color */
      --italic-text-color: #9E9E9E; /* Default light gray for italics */
      --bold-text-color: #E91E63; /* Default pink for bold (as per user, can be same as text-color) */
      --card-bg: #fff8fb;
      --card-bg-rgb: 255, 248, 251; /* RGB for --card-bg */
      --input-bg: #ffe8f2;
      --input-bg-rgb: 255, 232, 242; /* RGB for --input-bg */
      --border-radius: 16px;
      --participant-bg: #fff0f7;
      --participant-active-bg: #ff7aac;
      --shadow: 0 10px 35px 0 rgba(255, 122, 172, 0.15);
      --transition-fast: 0.2s ease-out;
      --transition-normal: 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      --bubble-user: #ffe8f2;
      --bubble-user-rgb: 255, 232, 242;
      --bubble-bot: #f0f8ff;
      --bubble-bot-rgb: 240, 248, 255;
      --bubble-system: #f5f5f5;
      --bubble-system-rgb: 245, 245, 245;
      --bubble-api: #e6fff5;
      --bubble-api-rgb: 230, 255, 245;
      --sidebar-bg: #fff5fa;
      --sidebar-accent: #ff6fa8;
      --sidebar-hover-bg: #ffe0ef;
      --sidebar-active-bg: #ff7aac;
      --button-hover-brightness: 1.08;
      --button-active-scale: 0.97;
      --accent-color-rgb: 255, 122, 172;
      --chat-font-size-multiplier: 1;
      --app-height: 100vh; /* Variable for dynamic viewport height */
      --sidebar-width: 280px;
      --sidebar-width-collapsed: 0px;
    }

    .dark-theme {
      --bg-color: #2c1d27;
      --accent-color: #ff8fbc;
      --accent-gradient: linear-gradient(135deg, #ff8fbc 0%, #ff6099 100%);
      --card-bg: #3b2a36;
      --card-bg-rgb: 59, 42, 54; /* RGB for dark --card-bg */
      --input-bg: #4f3548;
      --input-bg-rgb: 79, 53, 72; /* RGB for dark --input-bg */
      --participant-bg: #5c4055;
      --participant-active-bg: #ff6099;
      --bubble-user: #4f3548;
      --bubble-user-rgb: 79, 53, 72;
      --bubble-bot: #30404f;
      --bubble-bot-rgb: 48, 64, 79;
      --bubble-system: #4a4a4a;
      --bubble-system-rgb: 74, 74, 74;
      --bubble-api: #2a4f40;
      --bubble-api-rgb: 42, 79, 64;
      --sidebar-bg: #3b2a36;
      --sidebar-accent: #ff6099;
      --sidebar-hover-bg: #603050;
      --sidebar-active-bg: #ff6099;
      --shadow: 0 10px 35px 0 rgba(255, 96, 153, 0.3);
      --accent-color-rgb: 255, 143, 188;
    }

    html {
      height: -webkit-fill-available;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Montserrat', 'Segoe UI', sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      width: 100vw;
      overflow: hidden;
      transition: background 0.4s var(--transition-normal), color 0.4s var(--transition-normal);
      scroll-behavior: smooth;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      height: var(--app-height);
      min-height: var(--app-height);
    }

    body {
      display: flex;
      flex-direction: row;
    }

    .hamburger-btn {
        display: none;
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 1005;
        background: var(--accent-gradient);
        border: none;
        border-radius: 50%;
        width: 44px;
        height: 44px;
        cursor: pointer;
        box-shadow: 0 2px 10px rgba(var(--accent-color-rgb),0.3);
        align-items: center;
        justify-content: center;
        padding: 0;
    }
    .hamburger-btn span {
        display: block;
        width: 22px;
        height: 3px;
        background-color: white;
        border-radius: 3px;
        position: relative;
        transition: all 0.3s ease-in-out;
    }
    .hamburger-btn span::before,
    .hamburger-btn span::after {
        content: '';
        position: absolute;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: white;
        border-radius: 3px;
        transition: all 0.3s ease-in-out;
    }
    .hamburger-btn span::before { transform: translateY(-7px); }
    .hamburger-btn span::after { transform: translateY(7px); }

    .hamburger-btn.open span { background-color: transparent; }
    .hamburger-btn.open span::before { transform: rotate(45deg) translateY(0px); }
    .hamburger-btn.open span::after { transform: rotate(-45deg) translateY(0px); }


    .mobile-menu-container {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 280px;
        max-width: 80vw;
        height: var(--app-height);
        background-color: var(--sidebar-bg);
        box-shadow: 3px 0 15px rgba(0,0,0,0.2);
        z-index: 1000;
        transform: translateX(-100%);
        transition: transform 0.3s var(--transition-normal);
        overflow-y: auto;
        flex-direction: column;
    }
    .mobile-menu-container.open {
        transform: translateX(0);
    }
    .mobile-menu-header {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 1rem 1.2rem;
        border-bottom: 1px solid rgba(var(--accent-color-rgb),0.2);
        position: relative;
    }
    .mobile-menu-title {
        font-size: 1.3rem;
        font-weight: 600;
        color: var(--sidebar-accent);
    }
    .close-mobile-menu-btn {
        background: transparent;
        border: none;
        font-size: 2rem;
        color: var(--text-color);
        cursor: pointer;
        padding: 0.2rem;
        line-height: 1;
    }
    .mobile-menu-header .close-mobile-menu-btn {
        display: none;
    }

    #mobileMenuItemsPlaceholder {
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }
    #mobileMenuItemsPlaceholder .sidebar-header {
        text-align: left; padding: 0 0 0.5rem 0; border-bottom: none; font-size: 1.2rem;
    }
    #mobileMenuItemsPlaceholder .chat-list {
        flex-direction: column; gap: 0.5rem; padding: 0; max-height: 250px; overflow-y: auto;
    }
    #mobileMenuItemsPlaceholder .chat-item {
        width: 100%; box-sizing: border-box;
    }

    #mobileMenuItemsPlaceholder #themeToggle,
    #mobileMenuItemsPlaceholder #toggleSettingsBtn {
        position: static;
        width: 100%;
        border-radius: var(--border-radius);
        display: flex !important;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        padding: 0.8rem;
        font-size: 1rem;
    }
     #mobileMenuItemsPlaceholder #themeToggle svg { margin-right: 8px; }

    #mobileMenuItemsPlaceholder #themeToggle:hover,
    #mobileMenuItemsPlaceholder #toggleSettingsBtn:hover {
        transform: scale(1.02);
        filter: brightness(var(--button-hover-brightness));
        box-shadow: 0 4px 12px rgba(var(--accent-color-rgb),0.2);
    }

    #mobileMenuItemsPlaceholder #themeToggle:active,
    #mobileMenuItemsPlaceholder #toggleSettingsBtn:active {
        transform: scale(0.98);
        filter: brightness(0.95);
    }

    #sidebarToggleButton {
        background: var(--accent-gradient);
        color: white;
        border: none;
        cursor: pointer;
        width: 40px;
        height: 40px;
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 1001;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 1.1rem;
        font-weight: bold;
        box-shadow: 0 2px 10px rgba(var(--accent-color-rgb),0.25);
        border-radius: 50%;
        transition: background 0.2s var(--transition-fast), transform 0.2s var(--transition-fast), opacity 0.3s var(--transition-normal), filter 0.2s var(--transition-fast);
    }
    #sidebarToggleButton:hover {
        filter: brightness(var(--button-hover-brightness));
        transform: scale(1.05);
    }
    #sidebarToggleButton:active {
        transform: scale(var(--button-active-scale));
    }


    .sidebar {
      width: var(--sidebar-width);
      background-color: var(--sidebar-bg);
      border-right: 1px solid rgba(var(--accent-color-rgb),0.2);
      display: flex;
      flex-direction: column;
      padding: 1rem 0;
      box-shadow: 3px 0 15px rgba(var(--accent-color-rgb),0.05);
      overflow-y: auto;
      overflow-x: hidden;
      user-select: none;
      transition: width 0.3s var(--transition-normal), background 0.4s var(--transition-normal), border-color 0.4s var(--transition-normal), padding 0.3s var(--transition-normal);
      flex-shrink: 0;
      height: var(--app-height);
      position: sticky;
      top: 0;
    }
    .sidebar.collapsed {
      width: var(--sidebar-width-collapsed);
      padding: 1rem 0;
      border-right-width: 0;
    }
    .sidebar.collapsed .sidebar-header,
    .sidebar.collapsed .chat-list,
    .sidebar.collapsed .sidebar-footer {
        display: none;
    }

    .dark-theme .sidebar {
      border-color: rgba(var(--accent-color-rgb),0.3);
      box-shadow: 3px 0 15px rgba(var(--accent-color-rgb),0.15);
    }
    .sidebar-header {
      font-weight: 700;
      font-size: 1.5rem;
      color: var(--sidebar-accent);
      text-align: center;
      padding: 0 1rem 1.2rem 1rem;
      border-bottom: 1px solid rgba(var(--accent-color-rgb),0.2);
      transition: border-color 0.4s var(--transition-normal), color 0.4s var(--transition-normal);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      letter-spacing: 0.02em;
    }
    .dark-theme .sidebar-header {
      border-bottom: 1px solid rgba(var(--accent-color-rgb),0.3);
    }
    .chat-list {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      padding: 1rem;
    }
    .chat-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1.2rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      background: transparent;
      box-shadow: none;
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast), border-color var(--transition-fast);
      color: var(--text-color);
      position: relative;
      font-weight: 500;
      font-size: 1rem;
      border: 1px solid transparent;
    }
    .chat-item:hover {
      background: var(--sidebar-hover-bg);
      box-shadow: 0 4px 12px rgba(var(--accent-color-rgb),0.1);
      transform: translateX(4px);
      border-color: rgba(var(--accent-color-rgb),0.3);
    }
    .chat-item.active {
      background: var(--sidebar-active-bg);
      color: #fff;
      box-shadow: 0 6px 18px rgba(var(--accent-color-rgb),0.25);
      transform: translateX(0);
      font-weight: 600;
      border-color: transparent;
    }
    .chat-item img {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      flex-shrink: 0;
      transition: border-color 0.4s var(--transition-normal);
    }
    .dark-theme .chat-item img {
      border-color: var(--accent-color);
    }
    .chat-item .chat-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-grow: 1;
    }
    .delete-char-btn {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: transparent;
      border: none;
      color: var(--text-color);
      opacity: 0.6;
      font-weight: 700;
      cursor: pointer;
      font-size: 18px;
      padding: 0;
      line-height: 1;
      transition: color var(--transition-fast), opacity var(--transition-fast);
    }
    .delete-char-btn:hover {
      color: #ff0055;
      opacity: 1;
    }

    .main-content {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      background: var(--bg-color);
      position: relative;
      height: var(--app-height);
      max-height: var(--app-height);
      overflow: hidden;
      transition: background 0.4s var(--transition-normal), width 0.3s var(--transition-normal);
      width: calc(100% - var(--sidebar-width));
    }
    .sidebar.collapsed + .main-content {
        width: calc(100% - var(--sidebar-width-collapsed));
    }


    .chat-container {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      min-height: 0;
      padding: 1rem 0 0.2rem 1.5rem;
      overflow: hidden;
      position: relative;
      background: var(--card-bg);
      transition: background-image 0.4s var(--transition-normal), background-color 0.4s var(--transition-normal), padding 0.4s var(--transition-normal);
    }
    .chat-container.chat-container-custom-bg {
        padding-left: 0px;
        padding-bottom: 0px;
    }


    .toggle-mode {
      margin-bottom: 1.5rem;
      text-align: center;
      user-select: none;
      display: flex;
      justify-content: center;
      gap: 1rem;
      padding: 0.5rem 0;
      flex-shrink: 0;
    }
    .toggle-mode button {
      background: transparent;
      color: var(--accent-color);
      border: 2px solid var(--accent-color);
      padding: 0.6rem 1.8rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: background var(--transition-fast), color var(--transition-fast), box-shadow var(--transition-fast), transform 0.1s ease-out;
      outline: none;
      letter-spacing: 0.01em;
    }
    .toggle-mode button.selected, .toggle-mode button:hover {
      background: var(--accent-gradient);
      color: #fff;
      box-shadow: 0 3px 12px rgba(var(--accent-color-rgb),0.2);
      border-color: transparent;
    }
    .toggle-mode button:active {
      transform: scale(var(--button-active-scale));
      transition-duration: 0.05s;
    }

    #groupParticipants {
      display: none;
      margin-bottom: 1.5rem;
      padding: 0.75rem;
      background: var(--participant-bg);
      border-radius: var(--border-radius);
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05), var(--shadow);
      overflow-x: auto;
      white-space: nowrap;
      user-select: none;
      transition: background 0.4s var(--transition-normal), box-shadow 0.4s var(--transition-normal);
      flex-shrink: 0;
      animation: slideDownFadeIn 0.4s var(--transition-normal) forwards;
    }
    .dark-theme #groupParticipants {
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1), var(--shadow);
    }
    #groupParticipants .participant {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0.5rem 0.8rem;
      border-radius: calc(var(--border-radius) - 4px);
      background: rgba(255,255,255,0.8);
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      margin-right: 0.8rem;
      min-width: 75px;
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
      color: var(--text-color);
      font-weight: 500;
      font-size: 0.9rem;
    }
    .dark-theme #groupParticipants .participant {
      background: rgba(255,255,255,0.1);
    }
    #groupParticipants .participant:hover {
      background: #fff;
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .dark-theme #groupParticipants .participant:hover {
      background: rgba(255,255,255,0.2);
    }
    #groupParticipants .participant.active {
      background: var(--participant-active-bg);
      color: #fff;
      box-shadow: 0 5px 15px rgba(var(--accent-color-rgb),0.3);
      transform: scale(1.08);
      font-weight: 600;
    }
    #groupParticipants .participant img {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      object-fit: cover;
      margin-bottom: 0.3rem;
      border: 2px solid #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .dark-theme #groupParticipants .participant img {
      border-color: var(--accent-color);
    }

    #settingsModal, #lorebookModal, #backgroundModal, #greetingSelectModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.65);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.25s ease-out;
      padding: 1rem;
      box-sizing: border-box;
    }
    #settingsModal.above-hamburger,
    #lorebookModal.above-hamburger,
    #backgroundModal.above-hamburger,
    #greetingSelectModal.above-hamburger {
        z-index: 1010;
    }

    #settingsModal[style*="display: flex"],
    #lorebookModal[style*="display: flex"],
    #backgroundModal[style*="display: flex"],
    #greetingSelectModal[style*="display: flex"] {
      opacity: 1;
    }
    .settings-content, .greeting-select-content {
      background: var(--card-bg);
      padding: 1.5rem 2rem;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      max-width: 900px;
      width: 95%;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
      animation: slideUpFadeInModal 0.3s var(--transition-normal) forwards;
    }
    .greeting-select-content { max-width: 500px; }
    .greeting-select-content h2 { margin-top: 0;}
    .greeting-options { display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 1rem; }
    .greeting-option {
        padding: 0.75rem;
        border: 1px solid rgba(var(--accent-color-rgb), 0.3);
        border-radius: calc(var(--border-radius) - 4px);
        cursor: pointer;
        transition: background-color var(--transition-fast), border-color var(--transition-fast);
        font-size: 0.9rem;
        white-space: pre-wrap;
        word-break: break-word;
    }
    .greeting-option:hover {
        background-color: var(--sidebar-hover-bg);
        border-color: var(--accent-color);
    }
    .greeting-option.selected {
        background-color: var(--accent-color);
        color: white;
        border-color: var(--accent-color);
    }


    @keyframes slideUpFadeInModal {
      from { opacity: 0.5; transform: translateY(20px) scale(0.98); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    .dark-theme .settings-content, .dark-theme .greeting-select-content {
      background: var(--card-bg);
    }
    .settings-content .close-btn, .greeting-select-content .close-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      background: transparent;
      border: none;
      font-size: 28px;
      line-height: 1;
      padding: 5px;
      cursor: pointer;
      color: var(--text-color);
      opacity: 0.7;
      transition: opacity var(--transition-fast), transform var(--transition-fast);
      transform-origin: center;
    }
    .settings-content .close-btn:hover, .greeting-select-content .close-btn:hover {
      opacity: 1;
      transform: rotate(90deg);
    }

    .settings {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem 1.5rem;
    }

    .settings-content fieldset {
      border: 1px solid rgba(var(--accent-color-rgb), 0.3);
      border-radius: var(--border-radius);
      padding: 1rem 1.2rem;
      margin-bottom: 1rem;
      background: rgba(var(--accent-color-rgb), 0.03);
    }
    .dark-theme .settings-content fieldset {
      border-color: rgba(var(--accent-color-rgb), 0.4);
      background: rgba(var(--accent-color-rgb), 0.06);
    }
    .settings-content legend {
      font-weight: 600;
      color: var(--accent-color);
      padding: 0 0.5rem;
      font-size: 1.1rem;
    }

    .settings-content .settings > fieldset {
      grid-column: span 2;
    }

    .settings-content .settings > .fieldset-span-1 {
      grid-column: span 1;
    }

    .settings-content label {
        color: var(--text-color);
        display: block;
        margin-bottom: 0.3rem;
        font-weight: 500;
    }
    .settings-content input, .settings-content textarea, .settings-content select, .settings-content input[type="color"] {
      width: 100%;
      margin-bottom: 0.5rem;
      padding: 0.8rem 1rem;
      font-size: 0.95rem;
      background-color: var(--input-bg);
      border: 1px solid transparent;
      border-radius: calc(var(--border-radius) - 6px);
      color: var(--text-color);
      transition: box-shadow var(--transition-fast), background var(--transition-fast), border-color var(--transition-fast);
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
      font-family: inherit;
      outline: none;
      font-weight: 500;
      box-sizing: border-box;
    }
     .settings-content input[type="color"] {
        padding: 0.2rem;
        height: 40px;
    }
    .settings-content input[type="range"] {
        padding: 0.2rem 0;
    }
    .settings-content .font-size-indicator {
        display: inline-block;
        margin-left: 10px;
        font-weight: 500;
        color: var(--text-color);
    }
    .settings-content input:focus, .settings-content textarea:focus, .settings-content select:focus, .settings-content input[type="color"]:focus {
      box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb), 0.3);
      border-color: var(--accent-color);
      background: #fff;
    }
    .dark-theme .settings-content input:focus, .dark-theme .settings-content textarea:focus, .dark-theme .settings-content select:focus, .dark-theme .settings-content input[type="color"]:focus {
      background: var(--sidebar-hover-bg);
      border-color: var(--accent-color);
    }
    .settings-content textarea {
      min-height: 100px;
      max-height: 250px;
      resize: vertical;
    }
    .settings-content .avatar-selection {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .settings-content .settings .avatar-selection {
        grid-column: span 1;
    }

    .settings-content button,
    #lorebookModal button[type="button"],
    #backgroundModal button[type="button"],
    .greeting-select-content button {
      background: var(--accent-gradient);
      color: #fff;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(var(--accent-color-rgb),0.15);
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast), filter var(--transition-fast);
      outline: none;
      letter-spacing: 0.01em;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .settings-content button:hover,
    #lorebookModal button[type="button"]:hover,
    #backgroundModal button[type="button"]:hover,
    .greeting-select-content button:hover {
      filter: brightness(var(--button-hover-brightness));
      box-shadow: 0 4px 15px rgba(var(--accent-color-rgb),0.25);
      transform: translateY(-1px);
    }
    .settings-content button:active,
    #lorebookModal button[type="button"]:active,
    #backgroundModal button[type="button"]:active,
    .greeting-select-content button:active {
      transform: scale(var(--button-active-scale)) translateY(0);
      filter: brightness(0.95);
    }
    .settings-content .avatar-selection button {
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
    }

    .switch { position: relative; display: inline-block; width: 50px; height: 28px; margin-bottom: 0.4rem;}
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .3s var(--transition-normal); border-radius: 28px; }
    .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .3s var(--transition-normal); border-radius: 50%; }
    input:checked + .slider { background-color: var(--accent-color); }
    input:focus + .slider { box-shadow: 0 0 1px var(--accent-color); }
    input:checked + .slider:before { transform: translateX(22px); }

    .messages {
      flex-grow: 1;
      overflow-y: auto;
      padding: 1rem 0.5rem;
      background-color: transparent;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      transition: background 0.4s var(--transition-normal), background-color 0.4s var(--transition-normal);
      scroll-behavior: smooth;
      position: relative;
      white-space: pre-wrap;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      font-size: calc(1.05rem * var(--chat-font-size-multiplier));
      line-height: calc(1.5 * var(--chat-font-size-multiplier));
      color: var(--text-color);
      user-select: text;
      min-height: 150px;
    }
    .messages.has-custom-background .message {
        background-color: rgba(var(--bubble-bot-rgb), 0.85);
    }
    .messages.has-custom-background .message.user {
        background-color: rgba(var(--bubble-user-rgb), 0.85);
    }
    .messages.has-custom-background .message.api {
        background-color: rgba(var(--bubble-api-rgb), 0.85);
    }
    .messages.has-custom-background .message.system {
        background-color: rgba(var(--bubble-system-rgb), 0.85);
        color: var(--text-color);
    }
    .dark-theme .messages.has-custom-background .message.system {
        color: var(--text-color);
    }


    .dark-theme .messages {
      color: var(--text-color);
    }
    .message-container {
      display: flex;
      flex-direction: column;
      margin-bottom: 1.2rem;
      opacity: 0;
      animation: messageFadeInUp 0.4s var(--transition-normal) forwards;
      position: relative;
      width: 100%;
      box-sizing: border-box;
    }
    .message-content-wrapper {
        display: flex;
        align-items: flex-start;
        width: 100%;
    }
    .message-container.user-container .message-content-wrapper {
        justify-content: flex-end;
    }

    @keyframes messageFadeInUp {
      0% { opacity: 0; transform: translateY(15px); }
      100% { opacity: 1; transform: translateY(0); }
    }
    .avatar {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      object-fit: cover;
      margin-right: 0.8rem;
      border: 2px solid var(--accent-color);
      box-shadow: 0 2px 10px rgba(var(--accent-color-rgb),0.1);
      transition: border-color 0.4s var(--transition-normal);
      background: #fff;
      flex-shrink: 0;
      cursor: pointer;
    }
    .dark-theme .avatar {
      border-color: var(--accent-color);
      box-shadow: 0 2px 10px rgba(var(--accent-color-rgb),0.4);
      background: var(--card-bg);
    }
    .message {
      word-wrap: break-word;
      flex: 0 1 auto;
      max-width: calc(75% - 40px);
      background: var(--bubble-bot);
      padding: 0.75rem 1.1rem;
      border-radius: 1.2em 1.2em 1.2em 0.5em;
      line-height: 1.45;
      box-shadow: 0 2px 5px rgba(0,0,0,0.08);
      transition: background 0.3s var(--transition-normal), color 0.3s var(--transition-normal);
      position: relative;
      color: var(--text-color);
      white-space: pre-wrap;
    }

    .message em, .message i {
        color: var(--italic-text-color);
        font-style: italic;
    }
    .message strong, .message b {
        color: var(--bold-text-color);
        font-weight: bold;
    }
    .dark-theme .message em, .dark-theme .message i {
        color: var(--italic-text-color);
    }
    .dark-theme .message strong, .dark-theme .message b {
        color: var(--bold-text-color);
    }

    .message .attachments-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 0.5rem;
        margin-top: 0.5rem;
    }
    .message img.attached-image, .message .attached-file-preview {
        max-width: 100%;
        height: auto;
        max-height: 120px;
        border-radius: calc(var(--border-radius) - 8px);
        display: block;
        cursor: zoom-in;
        object-fit: cover;
    }
    .message a.attached-file-link {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        margin-top: 0.5rem;
        padding: 0.5rem;
        background-color: rgba(var(--accent-color-rgb), 0.1);
        color: var(--accent-color);
        border-radius: calc(var(--border-radius) - 8px);
        text-decoration: none;
        font-size: 0.9em;
        font-weight: 500;
        word-break: break-all;
        height: 100px;
    }
    .message a.attached-file-link:hover {
        background-color: rgba(var(--accent-color-rgb), 0.2);
    }
    .message a.attached-file-link .file-icon {
        font-size: 2rem;
        margin-bottom: 0.3rem;
    }


    .dark-theme .message {
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .message p { margin: 0.3em 0; padding: 0; }
    .message h1, .message h2, .message h3, .message h4, .message h5, .message h6 { display: block; font-size: 1.1em; font-weight: bold; margin-top: 0.5em; margin-bottom: 0.2em;}
    .message ul, .message ol { margin: 0.5em 0; padding-left: 1.8em; }
    .message.user {
      background: var(--bubble-user);
      border-radius: 1.2em 1.2em 0.5em 1.2em;
      font-weight: 500;
    }
    .message-container.user-container .message-content-wrapper .avatar {
        order: 1;
        margin-left: 0.8rem;
        margin-right: 0;
    }
    .message.api { background: var(--bubble-api); }
    .message.system { background: var(--bubble-system); color: #777; font-style: italic; font-size: 0.9em; max-width: 100%; text-align: center; }
    .dark-theme .message.system { color: #bbb; }

    .message-buttons {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      margin-top: 0.5rem;
      padding-left: calc(44px + 0.8rem);
      width: fit-content;
    }
    .message-container.user-container .message-buttons {
      padding-left: 0;
      padding-right: calc(44px + 0.8rem);
      margin-left: auto;
    }

    .message-buttons button {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      background: var(--accent-gradient);
      color: #fff;
      font-size: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast), filter var(--transition-fast);
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .message-buttons button:hover {
      filter: brightness(var(--button-hover-brightness));
      box-shadow: 0 2px 6px rgba(var(--accent-color-rgb),0.2);
      transform: scale(1.1);
    }
    .message-buttons button:active {
      transform: scale(var(--button-active-scale)) translateY(0);
    }
    .message-buttons button:disabled {
        background: #ccc;
        cursor: not-allowed;
        filter: grayscale(50%);
    }
    .message-buttons .delete-btn::before { content: "🗑️"; }
    .message-buttons .regen-btn::before { content: "🔄"; }
    .message-buttons .edit-btn::before { content: "✏️"; }
    .message-buttons .copy-btn::before { content: "📋"; }

    /* --- СТИЛИ ДЛЯ РЕДАКТИРОВАНИЯ СООБЩЕНИЙ (ИСПРАВЛЕНО) --- */
    .message-edit-area {
      width: 100%; /* Заполняет родительский элемент, но ограничивается max-width */
      max-width: 75%; /* Ограничение ширины, как у обычного сообщения */
      box-sizing: border-box; /* Чтобы padding не влиял на общую ширину */
      min-height: 80px;
      max-height: 200px;
      resize: vertical;
      font-size: inherit;
      padding: 0.7rem 1rem;
      border-radius: var(--border-radius);
      border: 1px solid var(--accent-color);
      background: var(--input-bg);
      color: var(--text-color);
      font-family: inherit;
      box-shadow: 0 2px 8px rgba(var(--accent-color-rgb),0.2);
      margin-bottom: 0.5rem;
      outline: none;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .message-container:not(.user-container) .message-edit-area {
        margin-left: calc(44px + 0.8rem); /* Отступ слева для сообщений бота */
    }
    .message-container.user-container .message-edit-area {
        margin-left: auto; /* Авто-отступ слева для выравнивания по правому краю */
        margin-right: calc(44px + 0.8rem); /* Отступ справа для сообщений пользователя */
    }
    .dark-theme .message-edit-area {
      box-shadow: 0 2px 8px rgba(var(--accent-color-rgb),0.5);
    }
    .edit-button-container {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem;
        padding-left: calc(44px + 0.8rem);
    }
    .message-container.user-container .edit-button-container {
        padding-left: 0;
        padding-right: calc(44px + 0.8rem);
        justify-content: flex-end;
    }


    .input-area-container {
        padding: 0.3rem 0;
        border-top: 1px solid rgba(var(--accent-color-rgb),0.2);
        background: var(--card-bg);
        flex-shrink: 0;
        transition: border-color 0.4s var(--transition-normal), background-color 0.4s var(--transition-normal);
    }
    .dark-theme .input-area-container {
        border-top: 1px solid rgba(var(--accent-color-rgb),0.3);
    }
    /* --- СТИЛИ ДЛЯ ПРОЗРАЧНОГО ВВОДА (ИСПРАВЛЕНО) --- */
    .input-area-container.has-custom-background-too {
        background-color: rgba(var(--card-bg-rgb), 0.65) !important;
        border-top-color: rgba(var(--accent-color-rgb), 0.2) !important;
        -webkit-backdrop-filter: blur(4px);
        backdrop-filter: blur(4px);
    }
    .input-area-container.has-custom-background-too #userInput {
        background-color: rgba(var(--input-bg-rgb), 0.7) !important;
        color: var(--text-color);
    }
    .dark-theme .input-area-container.has-custom-background-too #userInput {
        background-color: rgba(var(--input-bg-rgb), 0.7) !important;
    }


    #filePreviewsContainer {
        display: none;
        flex-wrap: wrap;
        gap: 0.5rem;
        padding: 0.5rem 0.5rem 0.3rem 0.5rem;
        max-height: 120px;
        overflow-y: auto;
        border-bottom: 1px solid rgba(var(--accent-color-rgb),0.1);
    }
    .file-preview-item {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: var(--input-bg);
        border-radius: calc(var(--border-radius) - 8px);
        padding: 0.3rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        width: 80px;
        height: 80px;
    }
    .file-preview-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: calc(var(--border-radius) - 10px);
    }
    .file-preview-item .file-info {
        font-size: 0.7rem;
        color: var(--text-color);
        text-align: center;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        width: 100%;
        margin-top: 0.2rem;
    }
    .file-preview-item .file-icon-placeholder {
        font-size: 2rem;
        color: var(--accent-color);
        flex-grow: 1;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .remove-file-btn {
        position: absolute;
        top: -5px;
        right: -5px;
        background: rgba(0,0,0,0.6);
        color: white;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        font-size: 12px;
        line-height: 20px;
        text-align: center;
        cursor: pointer;
        z-index: 1;
    }


    .input-row {
      display: flex;
      align-items: flex-end; /* ИСПРАВЛЕНО: выравнивание по нижнему краю */
      gap: 0.5rem;
      position: relative;
      padding: 0 0.5rem;
    }

    .mobile-input-prefix {
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 0.4rem;
        flex-shrink: 0;
    }

    #userInput {
      flex-grow: 1;
      padding: 0.8rem 1rem;
      font-size: 1rem;
      border-radius: var(--border-radius);
      border: 1px solid transparent;
      background-color: var(--input-bg);
      color: var(--text-color);
      resize: none;
      transition: box-shadow var(--transition-fast), background var(--transition-fast), border-color var(--transition-fast);
      font-family: inherit;
      min-height: 44px;
      max-height: 150px;
      outline: none;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
      overflow-y: auto;
      line-height: 1.4;
      box-sizing: border-box; /* Добавлено для предсказуемости размеров */
    }
    #userInput:focus {
      box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb), 0.3);
      border-color: var(--accent-color);
      background: #fff;
    }
    .dark-theme #userInput:focus {
      background: var(--sidebar-hover-bg);
    }
    button.send-button, .file-attach-button {
      background: var(--accent-gradient);
      color: #fff;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-weight: 600;
      transition: filter var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
      outline: none;
      white-space: nowrap;
      user-select: none;
      box-shadow: 0 2px 8px rgba(var(--accent-color-rgb),0.15);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      box-sizing: border-box; /* Добавлено для предсказуемости размеров */
    }
    button.send-button:hover, .file-attach-button:hover {
      filter: brightness(var(--button-hover-brightness));
      box-shadow: 0 4px 15px rgba(var(--accent-color-rgb),0.25);
      transform: translateY(-1px);
    }
    button.send-button:active, .file-attach-button:active {
      transform: scale(var(--button-active-scale)) translateY(0);
      filter: brightness(0.95);
    }
    button.send-button#sendButton {
      padding: 0.8rem 1.5rem; /* Скорректировано для соответствия высоте textarea */
      height: 44px; /* Явная высота */
      font-size: 1rem;
      letter-spacing: 0.02em;
    }
    .file-attach-button {
      width: 44px;
      height: 44px;
      font-size: 18px;
    }
    input#fileInput { display: none; }

    .status-container {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.3rem;
      padding: 0 0.5rem;
      flex-wrap: wrap;
    }
    #messages-status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ccc;
      box-shadow: 0 0 8px #ccc;
      transition: background 0.3s var(--transition-normal), box-shadow 0.3s var(--transition-normal);
      flex-shrink: 0;
      margin-bottom: 16px; /* Выравнивание с кнопками */
    }
    #messages-status-indicator.active {
      background: #4CAF50;
      box-shadow: 0 0 12px #4CAF50;
      animation: pulseIndicator 1.8s infinite ease-in-out;
    }
    @keyframes pulseIndicator {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
    }
    .status-container button {
        padding: 0.5rem 1rem;
        font-size: 0.85rem;
        background: var(--participant-bg);
        color: var(--text-color);
        border: 1px solid var(--accent-color);
    }
    .status-container button:hover {
        background: var(--sidebar-hover-bg);
    }
    .status-container button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    #variantCounter {
        font-weight: 600;
        font-size: 0.9rem;
        user-select: none;
        color: var(--accent-color);
    }

    .memory-box {
      background: var(--input-bg);
      border-radius: calc(var(--border-radius) - 6px);
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
      padding: 0.8rem 1rem;
      font-size: 0.95rem;
      color: var(--text-color);
      resize: vertical;
      min-height: 80px;
      max-height: 150px;
      width: 100%;
      font-family: inherit;
      border: 1px solid transparent;
      outline: none;
      transition: box-shadow var(--transition-fast), background var(--transition-fast), border-color var(--transition-fast);
      font-weight: 500;
      box-sizing: border-box;
    }
    .memory-box:focus {
      box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb), 0.3);
      border-color: var(--accent-color);
      background: #fff;
    }
    .dark-theme .memory-box {
      background: var(--input-bg);
    }
    .dark-theme .memory-box:focus {
      background: var(--sidebar-hover-bg);
    }

    #themeToggle, #toggleSettingsBtn {
      position: fixed;
      background: var(--accent-gradient);
      border: none;
      border-radius: 50%;
      width: 52px;
      height: 52px;
      cursor: pointer;
      box-shadow: 0 4px 18px rgba(var(--accent-color-rgb),0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s var(--transition-normal), transform 0.2s var(--transition-fast), box-shadow 0.3s var(--transition-normal), filter 0.2s var(--transition-fast);
      z-index: 100;
      outline: none;
    }
    #themeToggle:hover, #toggleSettingsBtn:hover {
      filter: brightness(var(--button-hover-brightness));
      transform: scale(1.1) rotate(5deg);
      box-shadow: 0 6px 22px rgba(var(--accent-color-rgb),0.4);
    }
    #themeToggle:active, #toggleSettingsBtn:active {
      transform: scale(var(--button-active-scale));
    }
    #themeToggle { top: 20px; right: 20px; }
    #toggleSettingsBtn { top: 85px; right: 20px; }
    #themeToggle svg { fill: white; width: 24px; height: 24px; transition: transform 0.4s ease-in-out; }
    .dark-theme #themeToggle svg { transform: rotate(180deg); }
    #toggleSettingsBtn span { font-size: 22px; color: white; }

    #lorebookModal .settings-content { max-width: 600px; }
    .lorebook-entry {
      margin-bottom: 1rem;
      padding: 1rem;
      background: rgba(0,0,0,0.03);
      border-radius: calc(var(--border-radius) - 4px);
      border: 1px solid rgba(var(--accent-color-rgb),0.2);
    }
    .dark-theme .lorebook-entry {
        background: rgba(255,255,255,0.04);
        border-color: rgba(var(--accent-color-rgb),0.3);
    }
    .lorebook-entry label { display: block; font-weight: 500; margin-bottom: 0.3rem; font-size: 0.9rem; color: var(--accent-color); }
    .lorebook-entry input, .lorebook-entry textarea {
      width: 100%;
      margin-bottom: 0.5rem;
      box-sizing: border-box;
    }
    .lorebook-entry textarea { min-height: 80px; }

    #backgroundModal .settings-content { max-width: 450px; text-align: center; }
    #backgroundModal input[type="file"] { display: block; margin: 1rem auto; }

    @keyframes slideDownFadeIn {
      from { opacity: 0; transform: translateY(-15px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes slideUpFadeIn {
      from { opacity: 0; transform: translateY(15px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    @media (max-width: 900px) {
      body {
        flex-direction: column;
        overflow-y: hidden;
        height: var(--app-height);
      }

      .hamburger-btn { display: flex; }
      .mobile-menu-container { display: flex; }

      #sidebarToggleButton { display: none !important; }
      .sidebar { display: none !important; }

      body > #themeToggle, body > #toggleSettingsBtn { display: none !important; }


      .main-content {
          width: 100% !important;
          min-height: 0;
          flex-grow: 1;
          overflow: hidden;
          height: 100%;
      }
      .chat-container {
          padding: 0.8rem 0 0.3rem 0.8rem;
      }
      .chat-container.chat-container-custom-bg {
          padding-left: 0px;
          padding-bottom: 0px;
      }

      .messages {
          padding-left: 0.1rem;
          padding-right: 0.8rem;
      }

      .message-content-wrapper {
          flex-direction: column;
      }
      .message-container .message-content-wrapper {
          align-items: flex-start;
      }
      .message-container.user-container .message-content-wrapper {
          align-items: flex-end;
      }

      .avatar {
          width: 30px;
          height: 30px;
          margin-right: 0;
          margin-left: 0;
          margin-bottom: 0.3rem;
      }
      .message-container.user-container .message-content-wrapper .avatar {
          order: 0;
      }

      .message {
          max-width: 100%;
          padding: 0.5rem 0.8rem;
      }

      .message-buttons {
          padding: 0 0.8rem;
          box-sizing: border-box;
          width: 100%;
          margin-left: 0;
          margin-right: 0;
      }
      .message-container .message-buttons {
          justify-content: flex-start;
      }
      .message-container.user-container .message-buttons {
          justify-content: flex-end;
          padding-right: 0 !important;
      }

      .edit-button-container {
          padding: 0 0.8rem;
          box-sizing: border-box;
          width: 100%;
          margin-left: 0;
          margin-right: 0;
      }
      .message-container .edit-button-container {
          justify-content: flex-start;
      }
      .message-container.user-container .edit-button-container {
          justify-content: flex-end;
          padding-right: 0 !important;
      }

      #groupParticipants { margin-bottom: 1rem; }


      .input-area-container {
        padding: 0.5rem;
      }
      .input-row {
        flex-wrap: nowrap;
        align-items: center; /* На мобильных вернем центрирование */
        gap: 0.4rem;
        padding: 0;
      }
      .mobile-input-prefix {
        display: flex;
      }

      .input-row > .file-attach-button:not(.mobile-input-prefix .file-attach-button),
      .input-row > #messages-status-indicator:not(.mobile-input-prefix #messages-status-indicator) {
        display: none !important;
      }


      #userInput {
        font-size: 0.95rem;
        padding: 0.7rem 0.9rem;
        min-height: 80px;
      }
      button.send-button#sendButton {
        width: 40px;
        height: 40px;
        padding: 0;
        font-size: 1.2rem;
        line-height: 1;
        border-radius: 50%;
        flex-shrink: 0;
        margin-left: 0.4rem;
      }

      .mobile-input-prefix .file-attach-button {
        width: 40px;
        height: 40px;
        font-size: 1.1rem;
        flex-shrink: 0;
      }
      .mobile-input-prefix #messages-status-indicator {
          margin: 0;
          flex-shrink: 0;
          width: 12px;
          height: 12px;
      }
      #messages-status-indicator {
        margin-bottom: 0;
      }

      .settings-content .settings {
        grid-template-columns: 1fr;
      }
      .settings-content .settings > .fieldset-span-1 {
        grid-column: span 1;
      }
      .settings-content .settings .avatar-selection {
        flex-direction: column;
        align-items: stretch;
        grid-column: span 1;
      }
      .settings-content .settings .avatar-selection button {
        width: 100%;
        margin-bottom: 0.5rem;
      }
      .settings-content { padding: 1rem 1.2rem; max-height: 80vh; }


      .message-buttons button { width: 28px; height: 28px; font-size: 14px; }
    }
    @media (min-width: 901px) {
        .hamburger-btn {
            display: none !important;
        }
        #sidebarToggleButton {
            display: flex !important;
        }
        .sidebar {
            display: flex !important;
        }
    }


    @media (max-width: 480px) {
      .avatar {
          width: 28px;
          height: 28px;
          margin-bottom: 0.2rem;
      }
      .message {
          padding: 0.4rem 0.7rem;
      }

      .input-row { gap: 0.2rem; }
      #userInput { min-height: 70px; padding: 0.6rem 0.8rem; font-size: 0.9rem; }
      button.send-button#sendButton,
      .mobile-input-prefix .file-attach-button {
        width: 38px;
        height: 38px;
      }
      .mobile-input-prefix { margin-right: 0.3rem; }


      .memory-box { font-size: 0.9rem; padding: 0.7rem; }
      .settings-content { padding: 1rem; }
      .settings-content legend {font-size: 1rem;}
      .settings-content input, .settings-content textarea, .settings-content select {font-size: 0.9rem; padding: 0.7rem 0.9rem;}
      .settings-content button {font-size: 0.9rem; padding: 0.7rem 1.2rem;}


      .hamburger-btn { top: 10px; left: 10px; width: 40px; height: 40px; }
      .hamburger-btn span { width: 20px; height: 2.5px;}
      .hamburger-btn span::before { transform: translateY(-6px); }
      .hamburger-btn span::after { transform: translateY(6px); }
    }

  </style>

<style>
/* Mobile tab styles - hidden by default (so PC is unaffected) */
.settings-content .tab-buttons { display: none; }
.settings-content .tab-page { display: block; }

@media (max-width: 900px) {
  .settings-content .tab-buttons {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    overflow-x: auto;
  }
  .settings-content .tab-buttons button {
    flex: 1;
    padding: 0.6rem;
    font-size: 0.9rem;
    border: 1px solid var(--accent-color);
    border-radius: var(--border-radius);
    background: var(--card-bg);
    color: var(--text-color);
    white-space: nowrap;
  }
  .settings-content .tab-buttons button.active {
    background: var(--accent-gradient);
    color: #fff;
    border-color: transparent;
  }
  .settings-content .tab-page {
    display: none;
    flex-direction: column;
    gap: 1rem;
  }
  .settings-content .tab-page.active {
    display: flex;
  }
  /* Ensure settings grid becomes single column on mobile (for compatibility) */
  .settings-content .settings { display: block; }
}
</style>

<style>
/* Mobile actions panel - hidden on desktop */
.settings-content .mobile-actions { display: none; }

/* buttons look compact on mobile */
.settings-content .mobile-actions .mobile-action-btn {
  padding: 0.6rem 0.8rem;
  border-radius: 10px;
  border: 1px solid rgba(var(--accent-color-rgb),0.12);
  background: var(--input-bg);
  color: var(--text-color);
  font-weight: 600;
  width: 100%;
  box-sizing: border-box;
}

/* two-column small screens */
@media (max-width: 480px) {
  .settings-content .mobile-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 0.4rem; }
}
@media (min-width: 481px) and (max-width:900px) {
  .settings-content .mobile-actions { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; }
  .settings-content .mobile-actions .mobile-action-btn { padding: 0.6rem; }
}
/* Keep hidden on desktop explicitly */
@media (min-width: 901px) {
  .settings-content .mobile-actions { display: none !important; }
}
</style>

<style>
@media (min-width: 901px) {
  .settings-content .tab-buttons { display: none !important; }
}
</style>

<style>
@media (max-width: 900px) {
  .settings-content .mobile-actions { 
    display: flex !important; 
  }
  .settings-content .mobile-actions button {
    flex: 1 1 calc(50% - 0.5rem);
    min-width: 120px;
  }
}
@media (max-width: 480px) {
  .settings-content .mobile-actions button {
    flex: 1 1 100%;
  }
}
@media (min-width: 901px) {
  .settings-content .mobile-actions {
    display: none !important;
  }
}
</style>

<style>
/* show mobile color picker only on mobile */
.settings-content .mobile-color-picker { display: none; }
@media (max-width: 900px) {
  .settings-content .mobile-color-picker { display: block !important; }
  .settings-content .mobile-actions { display: grid !important; grid-template-columns: repeat(2, 1fr); gap:0.5rem; }
  .settings-content .mobile-actions .mobile-action-btn { width:100%; }
}
</style>

<style>
/* Animation guard for modal overlays */
#settingsModal, #lorebookModal, #backgroundModal, #greetingSelectModal, #clearChatConfirmModal {
  display: flex !important;
  align-items: center;
  justify-content: center;
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  transition: opacity 0.28s ease, visibility 0.28s ease;
  background: rgba(0,0,0,0); /* keep transparent unless shown */
  padding: 1rem;
  box-sizing: border-box;
}
#settingsModal.modal-show, #lorebookModal.modal-show, #backgroundModal.modal-show, #greetingSelectModal.modal-show, #clearChatConfirmModal.modal-show {
  opacity: 1;
  visibility: visible;
  pointer-events: auto;
  background: rgba(0,0,0,0.65);
}
/* Ensure inner content still uses existing class .settings-content etc */
</style>
<!-- END IMPORTED MODAL STYLES -->

</head>
<body>
<!-- Hamburger Menu Button (Mobile) -->
<button aria-controls="mobileMenuContainer" aria-expanded="false" aria-label="Меню" class="hamburger-btn" id="hamburgerBtn">
<span></span>
</button>
<!-- Sidebar Toggle Button (PC) -->
<button aria-label="Свернуть/развернуть боковую панель" id="sidebarToggleButton" title="Свернуть/развернуть панель">&lt;&lt;</button>
<!-- Mobile Menu Flyout -->
<div aria-hidden="true" class="mobile-menu-container" id="mobileMenuContainer">
<div class="mobile-menu-header">
<span class="mobile-menu-title">Меню</span>
</div>
<div id="mobileMenuItemsPlaceholder">
<!-- Content will be injected by JS -->
</div>
</div>
<!-- Floating Action Buttons (Theme, Settings) -->
<button aria-label="Переключить тему" id="themeToggle" tabindex="0" title="Переключить тему">
<svg aria-hidden="true" focusable="false" id="themeIcon" viewbox="0 0 24 24">
<path d="M21 12.79A9 9 0 0112.21 3 7 7 0 1021 12.79z"></path> </svg>
</button>
<button aria-label="Настройки" id="toggleSettingsBtn" tabindex="0" title="Настройки">
<span>⚙️</span>
</button>
<!-- Main Sidebar (PC) -->
<aside aria-label="Список чатов" class="sidebar" id="sidebar" role="navigation">
<div class="sidebar-header">💬 Чаты с ботами</div>
<div class="chat-list" id="chatList" role="list">
<!-- Character list items will be injected by JS -->
</div>
</aside>
<!-- Main Content Area -->
<main class="main-content" id="mainContent">
<div aria-label="Участники группового чата" id="groupParticipants" role="list">
<!-- Group participants will be injected by JS -->
</div>
<div class="chat-container" id="chatContainer">
<div aria-live="polite" aria-relevant="additions" class="messages" id="messages">
<!-- Messages will be injected by JS -->
</div>
<div class="input-area-container">
<div id="filePreviewsContainer">
<!-- File previews will be injected by JS -->
</div>
<div class="input-row" id="mainInputRow">
<div class="mobile-input-prefix">
<!-- Mobile-specific buttons injected by JS -->
</div>
<div aria-label="Статус нейросети" id="messages-status-indicator" title="Статус нейросети"></div>
<textarea aria-label="Поле для ввода сообщения" id="userInput" placeholder="Введите сообщение..." rows="1" spellcheck="true"></textarea>
<button aria-label="Отправить сообщение" class="send-button" id="sendButton">Отправить</button>
</div>
<div class="status-container" style="justify-content: flex-end; padding-right: 5px;">
<div style="display:flex; align-items:center; gap:10px;">
<button aria-label="Предыдущий вариант" class="send-button" id="prevVariantBtn" onclick="prevVariant()" style="display:none;">← Пред.</button>
<span id="variantCounter" style="font-weight:700; user-select:none; display:none;"></span>
<button aria-label="Следующий вариант" class="send-button" id="nextVariantBtn" onclick="nextVariant()" style="display:none;">След. →</button>
<button aria-label="Применить вариант" class="send-button" id="applyVariantBtn" onclick="applyVariant()" style="display:none;">Применить</button>
</div>
</div>
</div>
</div>
</main>
<!-- Settings Modal -->
<div id="settingsModal">
<div class="settings-content">
<button aria-label="Закрыть настройки" class="close-btn" onclick="closeSettingsModal()" title="Закрыть">×</button>
<h2>⚙️ Настройки чата и персонажа</h2>
<fieldset style="margin-top:1rem; margin-bottom:1.5rem;"> <legend>Режим чата</legend>
<div aria-label="Режимы чата" class="toggle-mode" role="tablist">
<button aria-controls="settingsSection" aria-selected="true" class="selected" id="personalModeBtn" role="tab" tabindex="0">👤 Личный чат</button>
<button aria-controls="groupParticipants" aria-selected="false" id="groupModeBtn" role="tab" tabindex="0">👥 Групповой чат</button>
</div>
</fieldset>
<section aria-label="Настройки персонажа" class="settings" id="settingsSection"><div class="tab-buttons"><button class="active" onclick="openSettingsTab(1)" type="button">🔌 Настройки API LLM (По умолчанию)</button><button onclick="openSettingsTab(2)" type="button">🇬 Настройки Google Gemini API</button><button onclick="openSettingsTab(3)" type="button">🔗 Настройки REST API</button><button onclick="openSettingsTab(4)" type="button">👤 Основные настройки Персонажа</button><button onclick="openSettingsTab(5)" type="button">📝 Описание и личность</button><button onclick="openSettingsTab(6)" type="button">📖 Сценарий и примеры диалога</button><button onclick="openSettingsTab(7)" type="button">👋 Приветствия</button><button onclick="openSettingsTab(8)" type="button">⚙️ Дополнительные инструкции для ИИ</button><button onclick="openSettingsTab(9)" type="button">🎨 Настройки оформления</button><button onclick="openSettingsTab(10)" type="button">🖼️ Аватары</button><button onclick="openSettingsTab(11)" type="button">🧠 Память ИИ (Общая)</button></div><div class="tab-page active" id="settingsTab1"><fieldset class="fieldset-span-1"> <legend>🔌 Настройки API LLM (По умолчанию)</legend>
<label for="apiKey">Ключ API (LLM):</label>
<input aria-label="Ключ API LLM" autocomplete="off" id="apiKey" placeholder="Введите ваш API ключ" type="password"/>
<label for="apiUrl">URL API LLM:</label>
<input aria-label="URL LLM API" id="apiUrl" type="text" value="https://openrouter.ai/api/v1/chat/completions"/>
<label for="model">Модель LLM (по умолчанию):</label>
<input aria-label="Модель LLM" id="model" readonly="" type="text" value="deepseek/deepseek-r1-0528:free"/>
<label for="temperature">Температура (0-1):</label>
<input aria-label="Температура LLM" id="temperature" placeholder="Например, 0.7" step="0.1" type="number" value="0.7"/>
<label for="maxTokens">Максимум токенов:</label>
<input aria-label="Максимум токенов LLM" id="maxTokens" placeholder="Например, 1024" type="number" value="1024"/>
</fieldset></div><div class="tab-page" id="settingsTab2"><fieldset class="fieldset-span-1">
<legend>🇬 Настройки Google Gemini API</legend>
<label for="googleApiKey">Ключ Google API:</label>
<input aria-label="Ключ Google API" autocomplete="off" id="googleApiKey" placeholder="Введите ваш Google API ключ" type="password"/>
<label for="googleApiModel">Модель Google Gemini:</label>
<select aria-label="Модель Google Gemini" id="googleApiModel"></select>
<div style="display: flex; align-items: center; margin-top: 0.5rem; gap: 10px;">
<label for="enableGoogleApi" style="font-weight: 500; margin-bottom: 0;">Использовать Google Gemini API:</label>
<label class="switch">
<input aria-label="Включить Google Gemini API" id="enableGoogleApi" type="checkbox"/>
<span class="slider round"></span>
</label>
</div>
</fieldset></div><div class="tab-page" id="settingsTab3"><fieldset>
<legend>🔗 Настройки REST API</legend>
<label for="restApiUrl">URL REST API:</label>
<input aria-label="URL REST API" id="restApiUrl" placeholder="URL конечной точки REST API" type="text"/>
<label for="restApiHeaders">Заголовки REST API (JSON):</label>
<textarea aria-label="Заголовки REST API (JSON)" id="restApiHeaders" placeholder='Пример: {"Authorization": "Bearer ВАШ_ТОКЕН"}'></textarea>
<div style="display: flex; align-items: center; margin-top: 0.5rem; gap: 10px;">
<label for="enableRestApi" style="font-weight: 500; margin-bottom: 0;">Использовать REST API:</label>
<label class="switch">
<input aria-label="Включить REST API" id="enableRestApi" type="checkbox"/>
<span class="slider round"></span>
</label>
</div>
</fieldset></div><div class="tab-page" id="settingsTab4"><fieldset>
<legend>👤 Основные настройки Персонажа</legend>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
<div>
<label for="characterSelect">Выбрать персонажа:</label>
<select aria-label="Выбор персонажа" disabled="" id="characterSelect"></select>
</div>
<div>
<label for="characterName">Имя персонажа:</label>
<input aria-label="Имя персонажа" id="characterName" placeholder="Введите имя персонажа" type="text"/>
</div>
</div>
<label for="characterModel">Модель для персонажа (если отличается):</label>
<input aria-label="Модель персонажа" id="characterModel" placeholder="Например, gpt-4-turbo или модель Gemini" type="text"/>
</fieldset></div><div class="tab-page" id="settingsTab5"><fieldset>
<legend>📝 Описание и личность</legend>
<label for="description">Описание (внешность, роль, цели):</label>
<textarea aria-label="Описание персонажа" id="description" placeholder="Описание роли, характера, предыстории..." style="min-height: 140px;"></textarea>
<label for="personality">Личность (черты характера):</label>
<textarea aria-label="Личность персонажа" id="personality" placeholder="Личность, манера речи, поведение..."></textarea>
</fieldset></div><div class="tab-page" id="settingsTab6"><fieldset>
<legend>📖 Сценарий и примеры диалога</legend>
<label for="scenario">Сценарий (мир, окружение):</label>
<textarea aria-label="Сценарий" id="scenario" placeholder="Описание мира, ситуации, сеттинга..."></textarea>
<label for="mes_example">Пример диалога:</label>
<textarea aria-label="Пример диалога" id="mes_example" placeholder="&lt;START&gt;\nПример диалога для демонстрации стиля..." style="min-height: 140px;"></textarea>
</fieldset></div><div class="tab-page" id="settingsTab7"><fieldset>
<legend>👋 Приветствия</legend>
<label for="welcomeMessage">Основное приветствие:</label>
<textarea aria-label="Основное приветственное сообщение" id="welcomeMessage" placeholder="Сообщение от бота при начале чата"></textarea>
<!-- REMOVED: Alternative Greetings Input Field -->
</fieldset></div><div class="tab-page" id="settingsTab8"><fieldset>
<legend>⚙️ Дополнительные инструкции для ИИ</legend>
<label for="system_prompt">Системный промпт:</label>
<textarea aria-label="Системный промпт" id="system_prompt" placeholder="Глобальные инструкции для ИИ (system prompt)"></textarea>
<label for="post_history_instructions">Инструкции после истории:</label>
<textarea aria-label="Инструкции после истории" id="post_history_instructions" placeholder="Инструкции, которые вставляются после истории чата"></textarea>
<label for="creator_notes">Заметки создателя:</label>
<textarea aria-label="Заметки создателя" id="creator_notes" placeholder="Заметки от создателя персонажа"></textarea>
</fieldset></div><div class="tab-page" id="settingsTab9"><fieldset class="fieldset-span-1">
<legend>🎨 Настройки оформления</legend>
<div>
<label for="mainTextColor">Основной цвет текста:</label>
<input aria-label="Основной цвет текста" id="mainTextColor" onchange="applyTextColor(this.value); localStorage.setItem(TEXT_COLOR_STORAGE, this.value);" type="color"/>
</div>
<div style="margin-top: 1rem;">
<label for="chatFontSize">Размер текста в чате: <span id="chatFontSizeIndicator">100%</span></label>
<input aria-label="Размер текста в чате" id="chatFontSize" max="1.5" min="0.8" step="0.05" type="range" value="1"/>
</div>
</fieldset></div><div class="tab-page" id="settingsTab10"><fieldset class="fieldset-span-1">
<legend>🖼️ Аватары</legend>
<div class="avatar-selection">
<button onclick="showAvatarOptions('link', 'character')" type="button">Аватар Персонажа: Ссылка</button>
<button onclick="showAvatarOptions('file', 'character')" type="button">Аватар Персонажа: Файл</button>
</div>
<div id="avatarLinkInput_character" style="display:none; margin-top: 0.5rem;">
<input aria-label="Ссылка на аватар персонажа" id="avatarUrl_character" placeholder="URL аватара персонажа" type="text"/>
</div>
<div id="avatarFileInputWrapper_character" style="display:none; margin-top: 0.5rem;">
<input accept="image/*" aria-label="Выбор файла аватара персонажа" id="avatarFileInput_character" type="file"/>
</div>
<div class="avatar-selection" style="margin-top: 1rem;">
<button onclick="showAvatarOptions('link', 'user')" type="button">Ваш Аватар: Ссылка</button>
<button onclick="showAvatarOptions('file', 'user')" type="button">Ваш Аватар: Файл</button>
</div>
<div id="avatarLinkInput_user" style="display:none; margin-top: 0.5rem;">
<input aria-label="Ссылка на ваш аватар" id="avatarUrl_user" placeholder="URL вашего аватара" type="text"/>
</div>
<div id="avatarFileInputWrapper_user" style="display:none; margin-top: 0.5rem;">
<input accept="image/*" aria-label="Выбор файла вашего аватара" id="avatarFileInput_user" type="file"/>
</div>
</fieldset></div><div class="tab-page" id="settingsTab11"><fieldset>
<legend>🧠 Память ИИ (Общая)</legend>
<textarea aria-label="Память нейросети" class="memory-box" id="neuralMemory" placeholder="Заметки и контекст, которые бот будет помнить глобально..." spellcheck="true"></textarea>
</fieldset></div><div class="settings-bottom-actions" style="margin-top:1rem; display:flex; gap:0.5rem; flex-wrap:wrap;"><button onclick="importCharacterData()" type="button">📥 Импорт JSON</button><button onclick="exportCharacterData()" type="button">📤 Экспорт JSON</button><button onclick="openBackgroundModal()" type="button">🖼️ Фон чата</button><button onclick="openLorebookModal()" type="button">📚 Lorebook</button><button onclick="saveSettings()" type="button">Сохранить</button><button onclick="clearChat()" type="button">Очистить чат</button></div></section>
<div class="settings-bottom-actions mobile-actions" style="display:none; margin-top: 1rem; flex-wrap: wrap; gap: 0.5rem; justify-content:center;"><button class="mobile-action-btn" onclick="saveSettings()" type="button">💾 Сохранить/Обновить</button><button class="mobile-action-btn" onclick="exportCharacterData()" type="button">📤 Сохранить JSON</button><button class="mobile-action-btn" onclick="document.getElementById('jsonFileInput') &amp;&amp; document.getElementById('jsonFileInput').click()" type="button">📥 Загрузить JSON</button><button class="mobile-action-btn" onclick="openClearChatConfirm()" type="button">🗑️ Очистить чат</button><button class="mobile-action-btn" onclick="openBackgroundModal()" type="button">🖼️ Фон</button><button class="mobile-action-btn" onclick="openLorebookModal()" type="button">📚 Lorebook</button></div></div>
</div>
<!-- Lorebook Modal -->
<div id="lorebookModal">
<div class="settings-content"> <button aria-label="Закрыть Lorebook" class="close-btn" onclick="closeLorebookModal()" title="Закрыть">×</button>
<h2>📚 Lorebook для "<span id="lorebookCharacterName"></span>"</h2>
<p style="font-size: 0.9rem; color: var(--text-color); opacity: 0.8; margin-bottom: 1rem;">Добавляйте записи с названием, ключевыми словами (триггерами) и информацией, которую бот будет использовать, если триггер встретится в сообщении пользователя.</p>
<div id="lorebookEntries" style="margin-bottom: 1rem;">
<!-- Lorebook entries injected by JS -->
</div>
<button onclick="addLorebookEntry()" type="button">➕ Добавить запись</button>
</div>
</div>
<!-- Background Modal -->
<div id="backgroundModal">
<div class="settings-content"> <button aria-label="Закрыть настройки фона" class="close-btn" onclick="closeBackgroundModal()" title="Закрыть">×</button>
<h2>🖼️ Фон для "<span id="backgroundCharacterName"></span>"</h2>
<p style="font-size: 0.9rem; color: var(--text-color); opacity: 0.8; margin-bottom: 1rem;">Выберите изображение для фона области сообщений этого персонажа.</p>
<input accept="image/*" aria-label="Выбрать файл фона" id="backgroundFileInput" type="file"/>
<div style="margin-top: 1rem;">
<button onclick="uploadBackground()" type="button">📥 Загрузить</button>
<button onclick="deleteBackground()" style="background: #ffcdd2; color:#5f2120;" type="button">🗑️ Удалить фон</button>
</div>
</div>
</div>
<!-- Greeting Selection Modal -->
<div id="greetingSelectModal">
<div class="greeting-select-content"> <button aria-label="Закрыть выбор приветствия" class="close-btn" onclick="closeGreetingModal()" title="Закрыть">×</button>
<h2>👋 Выберите приветствие для <span id="greetingCharacterName"></span></h2>
<div class="greeting-options" id="greetingOptions">
<!-- Greeting options injected by JS -->
</div>
<button onclick="confirmGreetingSelection()" type="button">Выбрать это приветствие</button>
</div>
</div>
<input accept="image/*,application/*,text/*,*/*" id="fileInput" multiple="" style="display:none;" type="file"/>
<script>
    // --- Global Variables and Constants ---
    if (typeof window.currentMode === 'undefined') window.currentMode = "personal";
    let characters = {};
    let activeCharacter = null;
    let attachedFiles = [];
    let regenerateVariants = [];
    let currentVariantIndex = -1;
    let isBotGenerating = false;
    let shouldScrollToBottom = true;
    let tempImportedCharacterData = null;

    const ROOM_HISTORY_KEY = "roomHistory_v3";
    const MEMORY_KEY = "neuralMemory_v3";
    const API_KEY_STORAGE = "userApiKey_v3";
    const API_URL_STORAGE = "apiUrl_v3";
    const THEME_STORAGE = "themePreference_v3";
    const TEXT_COLOR_STORAGE = "mainTextColor_v3";
    const CHAT_FONT_SIZE_STORAGE = "chatFontSize_v1";
    const SIDEBAR_STATE_STORAGE = "sidebarState_v1";
    const REST_API_URL_STORAGE = "restApiUrl_v2";
    const REST_API_HEADERS_STORAGE = "restApiHeaders_v2";
    const ENABLE_REST_API_STORAGE = "enableRestApi_v2";
    const GOOGLE_API_KEY_STORAGE = "googleApiKey_v1";
    const GOOGLE_API_MODEL_STORAGE = "googleApiModel_v1";
    const ENABLE_GOOGLE_API_STORAGE = "enableGoogleApi_v1";
    const AVAILABLE_GOOGLE_MODELS = [ { id: "gemini-2.0-flash", name: "Gemini 2.0 Flash" }, { id: "gemini-2.5-pro", name: "Gemini 2.5 Pro" }, { id: "gemini-2.5-flash", name: "Gemini 2.5 Flash" }, { id: "gemini-2.5-flash-lite", name: "Gemini 2.5 Flash-Lite" } ];

    let useRestApi = false;
    let restApiUrlValue = "";
    let restApiHeadersValue = {};
    let useGoogleApi = false;
    let googleApiKey = "";
    let googleApiModel = "";

    // --- DOM Elements Cache ---
    const prevVariantBtn = document.getElementById("prevVariantBtn");
    const nextVariantBtn = document.getElementById("nextVariantBtn");
    const applyVariantBtn = document.getElementById("applyVariantBtn");
    const variantCounter = document.getElementById("variantCounter");
    let globalToggleSettingsBtn;
    let globalThemeToggleBtn;
    const sendButton = document.getElementById("sendButton");
    const personalModeBtn = document.getElementById("personalModeBtn");
    const groupModeBtn = document.getElementById("groupModeBtn");
    const messagesBox = document.getElementById("messages");
    const userInput = document.getElementById("userInput");
    const chatFontSizeSlider = document.getElementById("chatFontSize");
    const chatFontSizeIndicator = document.getElementById("chatFontSizeIndicator");
    const hamburgerBtn = document.getElementById('hamburgerBtn');
    const mobileMenuContainer = document.getElementById('mobileMenuContainer');
    const mobileMenuItemsPlaceholder = document.getElementById('mobileMenuItemsPlaceholder');
    const mainInputRow = document.getElementById('mainInputRow');
    const sidebar = document.getElementById('sidebar');
    const sidebarToggleButton = document.getElementById('sidebarToggleButton');
    const filePreviewsContainer = document.getElementById('filePreviewsContainer');

    // --- Utility Functions ---

    /**
     * [FIXED] Adds the copy to clipboard functionality.
     * @param {string} text - The text to copy.
     */
    function copyMessageToClipboard(text) {
      if (!text) return;
      const textArea = document.createElement("textarea");
      textArea.value = text;
      
      // Prevent screen from scrolling to the element
      textArea.style.top = "0";
      textArea.style.left = "0";
      textArea.style.position = "fixed";

      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
            showCustomAlert('Текст скопирован в буфер обмена!');
        } else {
            showCustomAlert('Не удалось скопировать текст.');
        }
      } catch (err) {
        console.error('Ошибка копирования:', err);
        showCustomAlert('Ошибка при копировании текста.');
      }

      document.body.removeChild(textArea);
    }

    function setAppHeight() {
      const doc = document.documentElement;
      doc.style.setProperty('--app-height', `${window.innerHeight}px`);
    }

    function setAccentRgb() {
        const rootStyle = getComputedStyle(document.documentElement);
        const accentColor = rootStyle.getPropertyValue('--accent-color').trim();
        if (accentColor.startsWith('#')) {
            const hex = accentColor.substring(1);
            const r = parseInt(hex.substring(0,2), 16);
            const g = parseInt(hex.substring(2,4), 16);
            const b = parseInt(hex.substring(4,6), 16);
            document.documentElement.style.setProperty('--accent-color-rgb', `${r},${g},${b}`);
        } else if (accentColor.startsWith('rgb')) {
             const match = accentColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
            if (match) {
                document.documentElement.style.setProperty('--accent-color-rgb', `${match[1]},${match[2]},${match[3]}`);
            }
        }
    }

    function isMobileView() {
        return window.innerWidth <= 900;
    }

    // --- Mobile Menu & View Handling ---

    
function setupMobileHamburgerMenu() {{
        const placeholder = mobileMenuItemsPlaceholder;
        if (!placeholder) return;

        // Preserve existing buttons (if present) BEFORE we clear the placeholder.
        let themeBtn = document.getElementById('themeToggle');
        let settingsBtn = document.getElementById('toggleSettingsBtn');

        // Templates to recreate buttons if they get removed elsewhere.
        const themeTemplate = `<button aria-label="Переключить тему" id="themeToggle" tabindex="0" title="Переключить тему">
<svg aria-hidden="true" focusable="false" id="themeIcon" viewbox="0 0 24 24">
<path d="M21 12.79A9 9 0 0112.21 3 7 7 0 1021 12.79z"></path> </svg>
</button>`;
        const settingsTemplate = `<button aria-label="Настройки" id="toggleSettingsBtn" tabindex="0" title="Настройки">
<span>⚙️</span>
</button>`;

        // Clear placeholder (we have references or templates if needed).
        placeholder.innerHTML = '';

        const originalSidebarHeader = document.querySelector('.sidebar .sidebar-header');
        if (originalSidebarHeader) placeholder.appendChild(originalSidebarHeader.cloneNode(true));

        const mobileChatListDiv = document.createElement('div');
        mobileChatListDiv.id = 'mobileMenuChatListInternal';
        mobileChatListDiv.className = 'chat-list';
        placeholder.appendChild(mobileChatListDiv);
        renderChatList(mobileChatListDiv);

        // If original elements existed, move them into the placeholder.
        if (themeBtn && themeBtn.parentElement !== placeholder) {{
            placeholder.appendChild(themeBtn);
        }} else if (!themeBtn) {{
            // Recreate from template (no event listeners are preserved — we rebind globals below).
            const tmp = document.createElement('div');
            tmp.innerHTML = themeTemplate;
            const newBtn = tmp.firstElementChild;
            if (newBtn) placeholder.appendChild(newBtn);
        }}

        if (settingsBtn && settingsBtn.parentElement !== placeholder) {{
            placeholder.appendChild(settingsBtn);
        }} else if (!settingsBtn) {{
            const tmp2 = document.createElement('div');
            tmp2.innerHTML = settingsTemplate;
            const newBtn2 = tmp2.firstElementChild;
            if (newBtn2) placeholder.appendChild(newBtn2);
        }}

        // Re-resolve globals so other code that attaches handlers can find these elements.
        globalThemeToggleBtn = document.getElementById('themeToggle');
        globalToggleSettingsBtn = document.getElementById('toggleSettingsBtn');

        // If there are initialization functions that attach listeners, call them here.
        if (typeof attachThemeToggleHandlers === 'function') {{
            attachThemeToggleHandlers(globalThemeToggleBtn);
        }}
        if (typeof attachSettingsHandlers === 'function') {{
            attachSettingsHandlers(globalToggleSettingsBtn);
        }}
    }}


    function restoreDesktopElements() {
        const themeToggleInHamburger = mobileMenuItemsPlaceholder.querySelector('#themeToggle');
        if (themeToggleInHamburger) {
            document.body.appendChild(themeToggleInHamburger);
        }
        const settingsToggleInHamburger = mobileMenuItemsPlaceholder.querySelector('#toggleSettingsBtn');
        if (settingsToggleInHamburger) {
            document.body.appendChild(settingsToggleInHamburger);
        }
    }


    function handleViewChange() {
        setAppHeight();
        const mainContentEl = document.getElementById('mainContent');
        const visibleFileAttachBtn = mainInputRow.querySelector('.file-attach-button');
        const originalStatusIndicator = document.getElementById('messages-status-indicator');
        const pcSidebarToggle = document.getElementById('sidebarToggleButton');

        if (isMobileView()) {
            setupMobileHamburgerMenu();
            sendButton.innerHTML = '→';
            sendButton.setAttribute('aria-label', 'Отправить');

            let mobilePrefixDiv = mainInputRow.querySelector('.mobile-input-prefix');
            if (!mobilePrefixDiv) {
                mobilePrefixDiv = document.createElement('div');
                mobilePrefixDiv.className = 'mobile-input-prefix';
                mainInputRow.insertBefore(mobilePrefixDiv, userInput);
            }
            mobilePrefixDiv.style.display = 'flex';


            let mobileFileAttachBtn = mobilePrefixDiv.querySelector('.file-attach-button');
            if (!mobileFileAttachBtn && visibleFileAttachBtn) {
                mobileFileAttachBtn = visibleFileAttachBtn.cloneNode(true);
                mobileFileAttachBtn.onclick = () => document.getElementById('fileInput').click();
                mobilePrefixDiv.appendChild(mobileFileAttachBtn);
            } else if (mobileFileAttachBtn) {
                 mobileFileAttachBtn.style.display = 'flex';
            }
             if (visibleFileAttachBtn && visibleFileAttachBtn.parentElement === mainInputRow) {
                visibleFileAttachBtn.style.display = 'none';
            }


            let mobileStatusIndicator = mobilePrefixDiv.querySelector('#messages-status-indicator');
            if (!mobileStatusIndicator && originalStatusIndicator) {
                mobileStatusIndicator = originalStatusIndicator.cloneNode(true);
                mobilePrefixDiv.appendChild(mobileStatusIndicator);
            } else if (mobileStatusIndicator) {
                 mobileStatusIndicator.style.display = 'block';
            }
            if (originalStatusIndicator && originalStatusIndicator.parentElement === mainInputRow) {
                 originalStatusIndicator.style.display = 'none';
            }

            if(sidebar) sidebar.style.display = 'none';
            if(pcSidebarToggle) pcSidebarToggle.style.display = 'none';

        } else {
            restoreDesktopElements();
            sendButton.innerHTML = 'Отправить';

            const mobilePrefixDiv = mainInputRow.querySelector('.mobile-input-prefix');
            if (mobilePrefixDiv) mobilePrefixDiv.style.display = 'none';


            if (visibleFileAttachBtn && visibleFileAttachBtn.parentElement === mainInputRow) {
                 visibleFileAttachBtn.style.display = 'flex';
            }
            if (originalStatusIndicator && originalStatusIndicator.parentElement === mainInputRow) {
                originalStatusIndicator.style.display = 'block';
            }

            if (sidebar) sidebar.style.display = 'flex';
            if(pcSidebarToggle) pcSidebarToggle.style.display = 'flex';
            loadSidebarState();
        }
    }


    // --- Initialization ---
    window.onload = () => {
      setAccentRgb();
      loadSettings();
      loadNeuralMemory();
      loadTheme();
      loadTextColor();
      loadChatTextSize();
      populateGoogleApiModelSelect();

      const statusIndicator = document.getElementById('messages-status-indicator');
      const userInputEl = document.getElementById('userInput');

      let desktopFileAttachButton = mainInputRow.querySelector('.file-attach-button:not(.mobile-input-prefix .file-attach-button)');
      if (!desktopFileAttachButton) {
          desktopFileAttachButton = document.createElement('button');
          desktopFileAttachButton.className = 'file-attach-button';
          desktopFileAttachButton.setAttribute('aria-label', 'Прикрепить файл или изображение');
          desktopFileAttachButton.title = 'Прикрепить файл или изображение';
          desktopFileAttachButton.innerHTML = '📎'; // Changed from '?' to '📎'
          desktopFileAttachButton.type = 'button';
          desktopFileAttachButton.onclick = () => document.getElementById('fileInput').click();

          if (statusIndicator && statusIndicator.parentElement === mainInputRow) {
            mainInputRow.insertBefore(desktopFileAttachButton, statusIndicator);
          } else if (userInputEl) {
            mainInputRow.insertBefore(desktopFileAttachButton, userInputEl);
          } else {
            mainInputRow.insertBefore(desktopFileAttachButton, mainInputRow.firstChild);
          }
      } else {
         desktopFileAttachButton.innerHTML = '📎'; // Changed from '?' to '📎'
      }


      renderMode();
      renderChatList();
      renderGroupParticipants();
      setupEventListeners();
      updateVariantControls();
      handleViewChange();
      renderFilePreviews();

      if (activeCharacter) {
        setActiveCharacter(activeCharacter);
      } else {
        displayInitialHelperMessage();
      }
      userInput.style.height = 'auto';
      userInput.style.height = (userInput.scrollHeight) + 'px';
      setAppHeight();
    };


    function displayInitialHelperMessage() {
        if (Object.keys(characters).length === 0 && messagesBox.children.length === 0) {
             const helperP = document.createElement('p');
             helperP.style.textAlign = 'center';
             helperP.style.color = 'var(--text-color)';
             helperP.style.padding = '20px';
             helperP.style.fontStyle = 'italic';
             helperP.style.opacity = '0.7';
             helperP.innerHTML = 'Добро пожаловать! 👋<br>Создайте своего первого персонажа в настройках (⚙️), чтобы начать чат.';
             messagesBox.appendChild(helperP);
        }
    }

    // --- Event Listeners Setup ---
    function setupEventListeners() {
      if (hamburgerBtn) {
        hamburgerBtn.addEventListener('click', () => {
            mobileMenuContainer.classList.toggle('open');
            hamburgerBtn.classList.toggle('open');
            hamburgerBtn.setAttribute('aria-expanded', mobileMenuContainer.classList.contains('open'));
            mobileMenuContainer.setAttribute('aria-hidden', !mobileMenuContainer.classList.contains('open'));
        });
      }
      document.addEventListener('click', (event) => {
        if (mobileMenuContainer && mobileMenuContainer.classList.contains('open') &&
            !mobileMenuContainer.contains(event.target) &&
            hamburgerBtn && !hamburgerBtn.contains(event.target)) {
            mobileMenuContainer.classList.remove('open');
            if (hamburgerBtn) {
                hamburgerBtn.classList.remove('open');
                hamburgerBtn.setAttribute('aria-expanded', 'false');
            }
            mobileMenuContainer.setAttribute('aria-hidden', 'true');
        }
      });

      document.body.addEventListener('click', function(event) {
        const target = event.target.closest('#themeToggle');
        if (target) {
            document.body.classList.toggle("dark-theme");
            const isDark = document.body.classList.contains("dark-theme");
            setTheme(isDark);
            setAccentRgb();
            const savedUserColor = localStorage.getItem(TEXT_COLOR_STORAGE);
            if (savedUserColor) {
                applyTextColor(savedUserColor);
            } else {
                const themeTextColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
                applyTextColor(themeTextColor);
            }
        }
      });
      document.body.addEventListener('click', function(event) {
        if (event.target.closest('#toggleSettingsBtn')) {
            openSettingsModal();
        }
      });


      document.getElementById("settingsModal").addEventListener("click", (e) => {
        if (e.target === document.getElementById("settingsModal")) closeSettingsModal();
      });
       document.getElementById("lorebookModal").addEventListener("click", (e) => {
        if (e.target === document.getElementById("lorebookModal")) closeLorebookModal();
      });
       document.getElementById("backgroundModal").addEventListener("click", (e) => {
        if (e.target === document.getElementById("backgroundModal")) closeBackgroundModal();
      });
      document.getElementById("greetingSelectModal").addEventListener("click", (e) => {
        if (e.target === document.getElementById("greetingSelectModal")) closeGreetingModal();
      });

      // ИСПРАВЛЕНО: Закрытие модальных окон по Escape
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          closeSettingsModal();
          closeLorebookModal();
          closeBackgroundModal();
          closeGreetingModal();
          const avatarModal = document.querySelector('.avatar-preview-modal');
          if (avatarModal) document.body.removeChild(avatarModal);
          if (mobileMenuContainer && mobileMenuContainer.classList.contains('open')) {
            mobileMenuContainer.classList.remove('open');
            if (hamburgerBtn) {
                 hamburgerBtn.classList.remove('open');
                 hamburgerBtn.setAttribute('aria-expanded', 'false');
            }
            mobileMenuContainer.setAttribute('aria-hidden', 'true');
          }
        }
      });
      
      // ИСПРАВЛЕНО: Убираем фокус с поля ввода по клику вне его
      document.getElementById('chatContainer').addEventListener('click', (e) => {
        const inputContainer = document.querySelector('.input-area-container');
        // Check if the clicked element or any of its parents is the userInput or a child of inputContainer
        if (inputContainer && !inputContainer.contains(e.target)) {
            userInput.blur(); // Blur the input if click is outside
        }
      });

      sendButton.addEventListener("click", sendMessage);
      userInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          sendMessage();
        }
      });
      userInput.addEventListener('input', () => {
          userInput.style.height = 'auto';
          userInput.style.height = (userInput.scrollHeight) + 'px';
      });

      personalModeBtn.addEventListener('click', () => switchMode("personal"));
      groupModeBtn.addEventListener('click', () => switchMode("group"));


      document.getElementById("apiKey").addEventListener("input", () => saveToStorage(API_KEY_STORAGE, document.getElementById("apiKey").value.trim()));
      document.getElementById("apiUrl").addEventListener("input", () => saveToStorage(API_URL_STORAGE, document.getElementById("apiUrl").value.trim()));

      document.getElementById("googleApiKey").addEventListener("input", () => {
          googleApiKey = document.getElementById("googleApiKey").value.trim();
          saveToStorage(GOOGLE_API_KEY_STORAGE, googleApiKey);
      });
      document.getElementById("googleApiModel").addEventListener("change", () => {
          googleApiModel = document.getElementById("googleApiModel").value;
          saveToStorage(GOOGLE_API_MODEL_STORAGE, googleApiModel);
      });
      document.getElementById("enableGoogleApi").addEventListener("change", (event) => {
          useGoogleApi = event.target.checked;
          saveToStorage(ENABLE_GOOGLE_API_STORAGE, useGoogleApi.toString());
      });


      document.getElementById("neuralMemory").addEventListener("input", () => saveToStorage(MEMORY_KEY, document.getElementById("neuralMemory").value));
      document.getElementById("mainTextColor").addEventListener("input", (e) => {
          applyTextColor(e.target.value);
          saveToStorage(TEXT_COLOR_STORAGE, e.target.value);
      });
      chatFontSizeSlider.addEventListener("input", (e) => {
          applyChatTextSize(e.target.value);
          saveToStorage(CHAT_FONT_SIZE_STORAGE, e.target.value);
          chatFontSizeIndicator.textContent = `${Math.round(e.target.value * 100)}%`;
      });

      if (sidebarToggleButton) {
        sidebarToggleButton.addEventListener('click', toggleSidebar);
      }

      setupRestApiSwitch();
      setupFileAttach();
      setupScrollHandler();
      setupAvatarClickHandler();
      window.addEventListener('resize', handleViewChange);
    }

    // --- Sidebar Toggle (PC) ---
    function toggleSidebar() {
        if (!sidebar) return;
        sidebar.classList.toggle('collapsed');
        const isCollapsed = sidebar.classList.contains('collapsed');
        if (sidebarToggleButton) {
            sidebarToggleButton.innerHTML = isCollapsed ? '&gt;&gt;' : '&lt;&lt;';
            sidebarToggleButton.setAttribute('aria-label', isCollapsed ? 'Развернуть боковую панель' : 'Свернуть боковую панель');
        }
        localStorage.setItem(SIDEBAR_STATE_STORAGE, isCollapsed ? 'collapsed' : 'expanded');
        applyBackground(getCurrentCharacterName());
    }

    function loadSidebarState() {
        if (isMobileView() || !sidebar) {
             if(sidebar) sidebar.classList.add('collapsed');
             return;
        }
        const state = localStorage.getItem(SIDEBAR_STATE_STORAGE);
        const isCollapsed = state === 'collapsed';
        sidebar.classList.toggle('collapsed', isCollapsed);
        if (sidebarToggleButton) {
            sidebarToggleButton.innerHTML = isCollapsed ? '&gt;&gt;' : '&lt;&lt;';
            sidebarToggleButton.setAttribute('aria-label', isCollapsed ? 'Развернуть боковую панель' : 'Свернуть боковую панель');
        }
    }


    // --- Theme and Color Management ---
    function setTheme(isDark) {
      localStorage.setItem(THEME_STORAGE, isDark ? "dark" : "light");
      const themeIconPath = isDark ?
        '<path d="M12 3.6A8.4 8.4 0 003.6 12 8.4 8.4 0 0012 20.4a8.4 8.4 0 008.4-8.4A8.4 8.4 0 0012 3.6zm0 14.4a6 6 0 110-12 6 6 0 010 12zM12 7a1 1 0 00-1 1v3H8a1 1 0 000 2h3v3a1 1 0 002 0v-3h3a1 1 0 000-2h-3V8a1 1 0 00-1-1z"/>'
        : '<path d="M21 12.79A9 9 0 0112.21 3 7 7 0 1021 12.79z"/>';
      const themeIconEl = document.getElementById("themeIcon");
      if (themeIconEl) themeIconEl.innerHTML = themeIconPath;
    }
    function loadTheme() {
      const savedTheme = localStorage.getItem(THEME_STORAGE);
      const isDark = savedTheme === "dark";
      document.body.classList.toggle("dark-theme", isDark);
      setTheme(isDark);
      setAccentRgb();
    }
    function applyTextColor(color) {
        document.documentElement.style.setProperty('--text-color', color);
        document.documentElement.style.setProperty('--bold-text-color', color);
    }
    function loadTextColor() {
        const savedColor = localStorage.getItem(TEXT_COLOR_STORAGE);
        const colorPicker = document.getElementById("mainTextColor");
        if (savedColor) {
            applyTextColor(savedColor);
            if(colorPicker) colorPicker.value = savedColor;
        } else {
            const defaultThemeColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            applyTextColor(defaultThemeColor);
            if(colorPicker) colorPicker.value = defaultThemeColor;
        }
    }

    // --- Chat Font Size ---
    function applyChatTextSize(sizeMultiplier) {
        document.documentElement.style.setProperty('--chat-font-size-multiplier', sizeMultiplier);
        if (chatFontSizeIndicator) chatFontSizeIndicator.textContent = `${Math.round(sizeMultiplier * 100)}%`;
    }

    function loadChatTextSize() {
        const savedSize = localStorage.getItem(CHAT_FONT_SIZE_STORAGE);
        const defaultSize = 1;
        const sizeToApply = savedSize ? parseFloat(savedSize) : defaultSize;
        applyChatTextSize(sizeToApply);
        if (chatFontSizeSlider) chatFontSizeSlider.value = sizeToApply;
    }


    // --- Modal Handling ---
    function openSettingsModal() {
        const modal = document.getElementById("settingsModal");
        modal.style.display = "flex";
        if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
            modal.classList.add('above-hamburger');
        }
        document.getElementById("personalModeBtn").classList.toggle("selected", currentMode === "personal");
        document.getElementById("personalModeBtn").setAttribute("aria-selected", currentMode === "personal");
        document.getElementById("groupModeBtn").classList.toggle("selected", currentMode === "group");
        document.getElementById("groupModeBtn").setAttribute("aria-selected", currentMode === "group");
    }
    function closeSettingsModal() {
        const modal = document.getElementById("settingsModal");
        modal.style.display = "none";
        modal.classList.remove('above-hamburger');
    }
    function openLorebookModal() {
      const name = getCurrentCharacterName();
      if (!name || !characters[name]) return showCustomAlert("Сначала выберите или создайте персонажа.");
      document.getElementById("lorebookCharacterName").textContent = name;
      renderLorebookEntries(name);
      const modal = document.getElementById("lorebookModal");
      modal.style.display = "flex";
      const settingsModal = document.getElementById("settingsModal");
      if (settingsModal.style.display === "flex") {
          const settingsZIndex = parseInt(window.getComputedStyle(settingsModal).zIndex, 10) || 1000;
          modal.style.zIndex = settingsZIndex + 10;
      } else if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
            modal.classList.add('above-hamburger');
      } else {
          modal.style.zIndex = '';
      }
    }
    function closeLorebookModal() {
        const modal = document.getElementById("lorebookModal");
        modal.style.display = "none";
        modal.classList.remove('above-hamburger');
        modal.style.zIndex = '';
    }
    function openBackgroundModal() {
      const name = getCurrentCharacterName();
      if (!name) return showCustomAlert("Сначала выберите или создайте персонажа.");
      document.getElementById("backgroundCharacterName").textContent = name;
      const modal = document.getElementById("backgroundModal");
      modal.style.display = "flex";
      const settingsModal = document.getElementById("settingsModal");
      if (settingsModal.style.display === "flex") {
          const settingsZIndex = parseInt(window.getComputedStyle(settingsModal).zIndex, 10) || 1000;
          modal.style.zIndex = settingsZIndex + 10;
      } else if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
            modal.classList.add('above-hamburger');
      } else {
          modal.style.zIndex = '';
      }
    }
    function closeBackgroundModal() {
        const modal = document.getElementById("backgroundModal");
        modal.style.display = "none";
        modal.classList.remove('above-hamburger');
        modal.style.zIndex = '';
    }

    function openGreetingModal(characterName, greetings) {
        document.getElementById("greetingCharacterName").textContent = characterName;
        const optionsContainer = document.getElementById("greetingOptions");
        optionsContainer.innerHTML = "";
        let selectedGreeting = null;

        greetings.forEach((greeting, index) => {
            const optionDiv = document.createElement("div");
            optionDiv.className = "greeting-option";
            optionDiv.textContent = greeting.length > 150 ? greeting.substring(0, 150) + "..." : greeting;
            optionDiv.dataset.fullGreeting = greeting;
            if (index === 0) {
                optionDiv.classList.add("selected");
                selectedGreeting = greeting;
            }
            optionDiv.addEventListener("click", () => {
                optionsContainer.querySelectorAll(".greeting-option").forEach(opt => opt.classList.remove("selected"));
                optionDiv.classList.add("selected");
                selectedGreeting = greeting;
            });
            optionsContainer.appendChild(optionDiv);
        });

        const greetingModal = document.getElementById("greetingSelectModal");
        greetingModal.style.display = "flex";
        greetingModal.style.zIndex = '';
        greetingModal.classList.remove('above-hamburger');

        const settingsModal = document.getElementById("settingsModal");
        if (settingsModal.style.display === "flex") {
            const settingsZIndex = parseInt(window.getComputedStyle(settingsModal).zIndex, 10) || 1000;
            greetingModal.style.zIndex = settingsZIndex + 10;
        } else if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
            greetingModal.classList.add('above-hamburger');
        }
    }

    function closeGreetingModal() {
        const modal = document.getElementById("greetingSelectModal");
        modal.style.display = "none";
        modal.classList.remove('above-hamburger');
        modal.style.zIndex = '';
        tempImportedCharacterData = null;
    }
    function confirmGreetingSelection() {
        const selectedOption = document.querySelector("#greetingOptions .greeting-option.selected");
        if (selectedOption && tempImportedCharacterData) {
            tempImportedCharacterData.character.welcomeMessage = selectedOption.dataset.fullGreeting;
            finalizeImport(tempImportedCharacterData);
        }
        closeGreetingModal();
    }


    // --- Mode Switching (Personal/Group) ---
    function switchMode(mode) {
      if (currentMode === mode) return;
      currentMode = mode;

      const settingsPersonalBtn = document.querySelector('#settingsModal #personalModeBtn');
      const settingsGroupBtn = document.querySelector('#settingsModal #groupModeBtn');
      if (settingsPersonalBtn) {
        settingsPersonalBtn.classList.toggle("selected", mode === "personal");
        settingsPersonalBtn.setAttribute("aria-selected", mode === "personal");
      }
      if (settingsGroupBtn) {
        settingsGroupBtn.classList.toggle("selected", mode === "group");
        settingsGroupBtn.setAttribute("aria-selected", mode === "group");
      }

      renderMode();
      clearVariants();
    }

    function renderMode() {
      document.getElementById("groupParticipants").style.display = currentMode === "group" ? "flex" : "none";
      document.getElementById("characterSelect").disabled = currentMode === "group";
      shouldScrollToBottom = true;
      loadAndRenderMessages();
      renderGroupParticipants();
      updateVariantControls();
    }

    // --- Data Storage Utilities ---
    function saveToStorage(key, value) {
      if (value !== undefined && value !== null) localStorage.setItem(key, value);
      else localStorage.removeItem(key);
    }

    // --- Settings Load/Save ---
    function loadSettings() {
      characters = JSON.parse(localStorage.getItem("characters_v3")) || {};
      document.getElementById("apiKey").value = localStorage.getItem(API_KEY_STORAGE) || "";
      document.getElementById("apiUrl").value = localStorage.getItem(API_URL_STORAGE) || "https://openrouter.ai/api/v1/chat/completions";

      restApiUrlValue = localStorage.getItem(REST_API_URL_STORAGE) || "";
      document.getElementById("restApiUrl").value = restApiUrlValue;
      const headersString = localStorage.getItem(REST_API_HEADERS_STORAGE) || "";
      document.getElementById("restApiHeaders").value = headersString;
      try { restApiHeadersValue = headersString ? JSON.parse(headersString) : {}; }
      catch (e) { console.error("Ошибка парсинга сохраненных заголовков REST API:", e); restApiHeadersValue = {}; }
      useRestApi = localStorage.getItem(ENABLE_REST_API_STORAGE) === "true";
      document.getElementById("enableRestApi").checked = useRestApi;

      googleApiKey = localStorage.getItem(GOOGLE_API_KEY_STORAGE) || "";
      document.getElementById("googleApiKey").value = googleApiKey;
      googleApiModel = localStorage.getItem(GOOGLE_API_MODEL_STORAGE) || (AVAILABLE_GOOGLE_MODELS.length > 0 ? AVAILABLE_GOOGLE_MODELS[0].id : "");
      document.getElementById("googleApiModel").value = googleApiModel;
      useGoogleApi = localStorage.getItem(ENABLE_GOOGLE_API_STORAGE) === "true";
      document.getElementById("enableGoogleApi").checked = useGoogleApi;



      if (!activeCharacter && Object.keys(characters).length > 0) {
        activeCharacter = Object.keys(characters)[0];
      }

      // --- Restore temperature and maxTokens from localStorage (ensure persistence even after dynamic settings re-render) ---
      try {
        const storedTemp = localStorage.getItem('temperature');
        const storedMax = localStorage.getItem('maxTokens');
        const tempEl = document.getElementById('temperature');
        const maxEl = document.getElementById('maxTokens');
        if (tempEl && storedTemp !== null) tempEl.value = storedTemp;
        if (maxEl && storedMax !== null) maxEl.value = storedMax;

        // Attach listeners so future changes are persisted (idempotent)
        function saveTemp() { try { if (tempEl) localStorage.setItem('temperature', tempEl.value); } catch(e){console.warn(e);} }
        function saveMax() { try { if (maxEl) localStorage.setItem('maxTokens', maxEl.value); } catch(e){console.warn(e);} }
        if (tempEl && !tempEl.__charis_persist_attached) { tempEl.addEventListener('input', saveTemp); tempEl.addEventListener('change', saveTemp); tempEl.__charis_persist_attached = true; }
        if (maxEl && !maxEl.__charis_persist_attached) { maxEl.addEventListener('input', saveMax); maxEl.addEventListener('change', saveMax); maxEl.__charis_persist_attached = true; }
      } catch(e){ console.warn('settings persistence injection error', e); }

      populateCharacterSelect();
    }
    function loadNeuralMemory() {
      document.getElementById("neuralMemory").value = localStorage.getItem(MEMORY_KEY) || "";
    }

    /**
     * [FIXED] Saves settings and handles avatar file uploads by resizing and compressing them.
     */
    async function saveSettings() {
      const name = document.getElementById("characterName").value.trim();
      if (!name) return showCustomAlert("Введите имя персонажа.");

      const isNewChar = !characters[name];
      const charData = characters[name] || {};

      // --- Update character data from all form fields ---
      charData.name = name;
      charData.description = document.getElementById("description").value;
      charData.personality = document.getElementById("personality").value;
      charData.scenario = document.getElementById("scenario").value;
      charData.mes_example = document.getElementById("mes_example").value;
      charData.welcomeMessage = document.getElementById("welcomeMessage").value;
      // Removed: charData.alternate_greetings = document.getElementById("alternate_greetings").value.split('\n').map(g => g.trim()).filter(g => g);
      // When saving, we don't take alternate_greetings from UI, they are only imported.
      // If charData.alternate_greetings doesn't exist or is empty, initialize it as an empty array.
      if (!charData.alternate_greetings || !Array.isArray(charData.alternate_greetings)) {
          charData.alternate_greetings = [];
      }


      // Advanced prompts
      charData.system_prompt = document.getElementById("system_prompt").value;
      charData.post_history_instructions = document.getElementById("post_history_instructions").value;
      charData.creator_notes = document.getElementById("creator_notes").value;

      charData.model = document.getElementById("characterModel").value.trim() || document.getElementById("model").value;
      charData.lorebook = charData.lorebook || [];

      // Await avatar processing
      const charAvatarFromFile = await handleAvatarUpload('character');
      const userAvatarFromFile = await handleAvatarUpload('user');

      // Prioritize file upload, then URL input, then existing, then default placeholder
      if (charAvatarFromFile) {
          charData.avatarCharacter = charAvatarFromFile;
      } else if (document.getElementById("avatarUrl_character").value) {
          charData.avatarCharacter = document.getElementById("avatarUrl_character").value;
      } else if (!charData.avatarCharacter || charData.avatarCharacter.startsWith('data:image')) {
          charData.avatarCharacter = "https://placehold.co/100x100/FF7AAC/FFFFFF?text=Бот";
      }

      if (userAvatarFromFile) {
          charData.avatarUser = userAvatarFromFile;
      } else if (document.getElementById("avatarUrl_user").value) {
          charData.avatarUser = document.getElementById("avatarUrl_user").value;
      } else if (!charData.avatarUser || charData.avatarUser.startsWith('data:image')) {
          charData.avatarUser = "https://placehold.co/100x100/7AC5FF/FFFFFF?text=Вы";
      }


      // Save REST API settings
      restApiUrlValue = document.getElementById("restApiUrl").value.trim();
      saveToStorage(REST_API_URL_STORAGE, restApiUrlValue);
      const headersString = document.getElementById("restApiHeaders").value.trim();
      saveToStorage(REST_API_HEADERS_STORAGE, headersString);
      try { restApiHeadersValue = headersString ? JSON.parse(headersString) : {}; }
      catch (e) { showCustomAlert("Ошибка в JSON формате заголовков REST API. Заголовки не сохранены."); console.error("Неверный JSON в заголовках REST API:", e); restApiHeadersValue = {};}
      useRestApi = document.getElementById("enableRestApi").checked;
      saveToStorage(ENABLE_REST_API_STORAGE, useRestApi.toString());

      // Save Google API settings
      googleApiKey = document.getElementById("googleApiKey").value.trim();
      saveToStorage(GOOGLE_API_KEY_STORAGE, googleApiKey);
      googleApiModel = document.getElementById("googleApiModel").value;
      saveToStorage(GOOGLE_API_MODEL_STORAGE, googleApiModel);
      useGoogleApi = document.getElementById("enableGoogleApi").checked;
      saveToStorage(ENABLE_GOOGLE_API_STORAGE, useGoogleApi.toString());

      characters[name] = charData;
      localStorage.setItem("characters_v3", JSON.stringify(characters));

      populateCharacterSelect();
      renderChatList(document.getElementById('chatList'));
      const hamburgerChatListContainer = document.getElementById('mobileMenuChatListInternal');
      if (hamburgerChatListContainer) renderChatList(hamburgerChatListContainer);

      renderGroupParticipants();

      if (isNewChar || activeCharacter !== name) {
          setActiveCharacter(name);
      } else {
          loadAndRenderMessages();
          applyBackground(name);
      }
      document.getElementById("characterSelect").value = name;
      animateSaveButton();
      showCustomAlert(`Персонаж "${name}" сохранён.`);
      closeSettingsModal();
    }

    function populateGoogleApiModelSelect() {
        const selectEl = document.getElementById("googleApiModel");
        if (!selectEl) return;
        selectEl.innerHTML = "";
        AVAILABLE_GOOGLE_MODELS.forEach(model => {
            const option = document.createElement("option");
            option.value = model.id;
            option.textContent = model.name;
            selectEl.appendChild(option);
        });
        selectEl.value = localStorage.getItem(GOOGLE_API_MODEL_STORAGE) || (AVAILABLE_GOOGLE_MODELS.length > 0 ? AVAILABLE_GOOGLE_MODELS[0].id : "");
    }


    function animateSaveButton() {
      const btn = document.querySelector('.settings-content button[onclick="saveSettings()"]');
      if (!btn) return;
      const originalText = btn.textContent;
      btn.textContent = "✅ Сохранено!";
      btn.style.background = "linear-gradient(135deg, #a8e063 0%, #56ab2f 100%)";
      setTimeout(() => {
        btn.textContent = originalText;
        btn.style.background = "";
      }, 1500);
    }

    function showAvatarOptions(option, target) {
      document.getElementById(`avatarLinkInput_${target}`).style.display = option === 'link' ? 'block' : 'none';
      document.getElementById(`avatarFileInputWrapper_${target}`).style.display = option === 'file' ? 'block' : 'none';
    }

    /**
     * [FIXED] Handles avatar file upload. Resizes and compresses the image to prevent
     * localStorage size limit issues before converting to a Data URL.
     * @param {string} target - 'character' or 'user'.
     * @returns {Promise<string|null>} A promise that resolves with the compressed Data URL or null.
     */
    async function handleAvatarUpload(target) {
        const fileInput = document.getElementById(`avatarFileInput_${target}`);
        if (!fileInput || fileInput.files.length === 0) {
            return null;
        }
        const file = fileInput.files[0];
        const MAX_WIDTH = 256;
        const MAX_HEIGHT = 256;

        return new Promise((resolve) => {
            const img = document.createElement("img");
            const reader = new FileReader();

            reader.onload = (e) => {
                img.src = e.target.result; // Load file into an image element
            };

            img.onerror = () => {
                console.error("Не удалось загрузить файл изображения для обработки.");
                resolve(null); // Resolve with null if the image fails to load
            };

            img.onload = () => {
                // Resize the image on a canvas
                const canvas = document.createElement("canvas");
                let width = img.width;
                let height = img.height;

                if (width > height) {
                    if (width > MAX_WIDTH) {
                        height *= MAX_WIDTH / width;
                        width = MAX_WIDTH;
                    }
                } else {
                    if (height > MAX_HEIGHT) {
                        width *= MAX_HEIGHT / height;
                        height = MAX_HEIGHT;
                    }
                }
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0, width, height);

                // Get a compressed data URL (jpeg is usually smaller for photos)
                const dataUrl = canvas.toDataURL("image/jpeg", 0.85); 
                resolve(dataUrl);
            };
            
            reader.readAsDataURL(file);
        });
    }


    // --- Character List and Selection ---
    function populateCharacterSelect() {
      const select = document.getElementById("characterSelect");
      if (!select) return;
      const currentVal = select.value;
      select.innerHTML = "<option value=\"\" disabled>-- Выберите персонажа --</option>";
      const sortedNames = Object.keys(characters).sort((a, b) => a.localeCompare(b, 'ru'));

      for (const name of sortedNames) {
        const option = document.createElement("option");
        option.value = name;
        option.textContent = name;
        select.appendChild(option);
      }
      if (characters[currentVal]) select.value = currentVal;
      else if (activeCharacter && characters[activeCharacter]) select.value = activeCharacter;
      else if (sortedNames.length > 0) select.value = "";

      select.onchange = () => {
          if (select.value) setActiveCharacter(select.value);
          clearVariants();
      };
    }

    function renderChatList(targetContainerEl = null) {
      const container = targetContainerEl || document.getElementById("chatList");
      if (!container) {
        return;
      }

      container.innerHTML = "";
      const fragment = document.createDocumentFragment();
      const sortedNames = Object.keys(characters).sort((a, b) => a.localeCompare(b, 'ru'));

      if (sortedNames.length === 0 && container.id === "chatList") {
          container.innerHTML = `<p style="text-align:center; font-style:italic; opacity:0.7; padding:1rem;">Нет созданных персонажей.</p>`;
          return;
      }

      for (const name of sortedNames) {
        const char = characters[name];
        const chatItem = document.createElement("div");
        chatItem.className = "chat-item";
        if (activeCharacter === name && currentMode === "personal") chatItem.classList.add("active");
        chatItem.setAttribute("role", "listitem");
        chatItem.setAttribute("tabindex", "0");

        const avatarSrc = char.avatarCharacter || "https://placehold.co/80x80/FF7AAC/FFFFFF?text=" + name.charAt(0);
        chatItem.innerHTML = `
          <img src="${avatarSrc}" alt="Аватар ${name}" onerror="this.onerror=null;this.src='https://placehold.co/80x80/FF7AAC/FFFFFF?text=?';"/>
          <div class="chat-name" title="${name}">${name}</div>
          <button class="delete-char-btn" aria-label="Удалить персонажа ${name}" title="Удалить ${name}">×</button>
        `;
        chatItem.addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-char-btn')) return;
            setActiveCharacter(name);
            switchMode("personal");
            clearVariants();
            if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
                mobileMenuContainer.classList.remove('open');
                if(hamburgerBtn) hamburgerBtn.classList.remove('open');
            }
        });
        chatItem.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                if (e.target.classList.contains('delete-char-btn')) {
                    e.target.click();
                } else {
                    setActiveCharacter(name);
                    switchMode("personal");
                    clearVariants();
                     if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
                        mobileMenuContainer.classList.remove('open');
                        if(hamburgerBtn) hamburgerBtn.classList.remove('open');
                    }
                }
            }
        });

        chatItem.querySelector('.delete-char-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            showCustomConfirm(`Вы уверены, что хотите удалить персонажа "${name}" и всю историю чата с ним? Это действие нельзя отменить.`, () => {
              delete characters[name];
              localStorage.setItem("characters_v3", JSON.stringify(characters));
              localStorage.removeItem(getChatKey(name));

              if (activeCharacter === name) {
                activeCharacter = Object.keys(characters)[0] || null;
                if (activeCharacter) {
                  setActiveCharacter(activeCharacter);
                } else {
                  // Clear all fields if no characters left
                  ['characterName', 'description', 'personality', 'scenario', 'mes_example', 'welcomeMessage', 'characterModel', 'system_prompt', 'post_history_instructions', 'creator_notes', 'avatarUrl_character', 'avatarUrl_user'].forEach(id => document.getElementById(id).value = '');
                  // For alternate_greetings, we no longer have an input field, so just ensure it's handled as an empty array or null if needed.
                  loadAndRenderMessages();
                  applyBackground(null);
                  displayInitialHelperMessage();
                }
              }
              renderChatList(document.getElementById('chatList'));
              const hamburgerChatList = document.getElementById('mobileMenuChatListInternal');
              if (hamburgerChatList) renderChatList(hamburgerChatList);

              renderGroupParticipants();
              populateCharacterSelect();
              clearVariants();
            });
        });
        fragment.appendChild(chatItem);
      }
      container.appendChild(fragment);
    }


    function renderGroupParticipants() {
      const container = document.getElementById("groupParticipants");
      container.innerHTML = "";
      if (currentMode !== "group" || Object.keys(characters).length === 0) {
        container.style.display = "none";
        return;
      }
      container.style.display = "flex";
      const fragment = document.createDocumentFragment();
      const sortedNames = Object.keys(characters).sort((a, b) => a.localeCompare(b, 'ru'));

      for (const name of sortedNames) {
        const char = characters[name];
        const participant = document.createElement("div");
        participant.className = "participant";
        participant.title = `Ответить от имени ${name}`;
        participant.setAttribute("role", "button");
        participant.setAttribute("tabindex", "0");
        const avatarSrc = char.avatarCharacter || 'https://placehold.co/80x80/FF7AAC/FFFFFF?text=' + name.charAt(0);
        participant.innerHTML = `
          <img src="${avatarSrc}" alt="Аватар ${name}" onerror="this.onerror=null;this.src='https://placehold.co/80x80/FF7AAC/FFFFFF?text=?';"/>
          <div>${name}</div>
        `;
        participant.addEventListener('click', () => {
            showCustomConfirm(`Сгенерировать ответ от имени ${name}?`, () => {
                 respondToLastMessage(name);
            });
        });
        participant.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                showCustomConfirm(`Сгенерировать ответ от имени ${name}?`, () => {
                     respondToLastMessage(name);
                });
            }
        });
        fragment.appendChild(participant);
      }
      if (sortedNames.length === 0) {
          container.innerHTML = `<p style="text-align:center; font-style:italic; opacity:0.7; padding:0.5rem;">Сначала создайте персонажей в настройках.</p>`;
      } else {
          container.appendChild(fragment);
      }
    }


    function setActiveCharacter(name) {
      if (!characters[name]) {
        console.warn(`Персонаж "${name}" не найден.`);
        activeCharacter = null;
        return;
      }
      activeCharacter = name;
      const ch = characters[name];

      // --- Populate all settings fields for the active character ---
      document.getElementById("characterName").value = name;
      document.getElementById("description").value = ch.description || "";
      document.getElementById("personality").value = ch.personality || "";
      document.getElementById("scenario").value = ch.scenario || "";
      document.getElementById("mes_example").value = ch.mes_example || "";
      document.getElementById("welcomeMessage").value = ch.welcomeMessage || "";
      // Removed: document.getElementById("alternate_greetings").value = (ch.alternate_greetings || []).join('\n');
      document.getElementById("system_prompt").value = ch.system_prompt || "";
      document.getElementById("post_history_instructions").value = ch.post_history_instructions || "";
      document.getElementById("creator_notes").value = ch.creator_notes || "";
      document.getElementById("characterModel").value = ch.model || "";
      
      // Update avatar URL input fields based on character data
      const avatarUrlInputChar = document.getElementById("avatarUrl_character");
      if (ch.avatarCharacter && !ch.avatarCharacter.startsWith('data:image')) {
          avatarUrlInputChar.value = ch.avatarCharacter;
          showAvatarOptions('link', 'character');
      } else {
          avatarUrlInputChar.value = "";
          showAvatarOptions('file', 'character'); // Default to file input if it's a data URL or missing
      }
      
      const avatarUrlInputUser = document.getElementById("avatarUrl_user");
      if (ch.avatarUser && !ch.avatarUser.startsWith('data:image')) {
          avatarUrlInputUser.value = ch.avatarUser;
          showAvatarOptions('link', 'user');
      } else {
          avatarUrlInputUser.value = "";
          showAvatarOptions('file', 'user'); // Default to file input if it's a data URL or missing
      }


      if (document.getElementById("characterSelect").value !== name) {
          document.getElementById("characterSelect").value = name;
      }

      shouldScrollToBottom = true;
      loadAndRenderMessages();
      renderChatList(document.getElementById('chatList'));
      const hamburgerChatList = document.getElementById('mobileMenuChatListInternal');
      if (hamburgerChatList) renderChatList(hamburgerChatList);

      applyBackground(name);
      clearVariants();
    }

    function getCurrentCharacterName() {
      if (currentMode === "personal") {
        return activeCharacter || (Object.keys(characters).length > 0 ? Object.keys(characters)[0] : null);
      }
      return null;
    }

    // --- Chat History Management ---
    function getChatKey(name) { return `chatHistory_v3_${name}`; }
    function saveChat(name, messages) {
      if (!name) return;
      try {
        localStorage.setItem(getChatKey(name), JSON.stringify(messages));
      } catch (e) {
        console.error("Ошибка сохранения чата в localStorage:", e);
        showCustomAlert("Ошибка: не удалось сохранить историю чата. Возможно, она слишком большая.");
      }
      allMessages = messages;
    }
    function loadChat(name) {
      if (!name) return [];
      let msgs = JSON.parse(localStorage.getItem(getChatKey(name)) || "[]");
      return msgs.map(msg => ({ ...msg, attachments: msg.attachments || null }));
    }
    function saveRoomChat(messages) {
        try {
            localStorage.setItem(ROOM_HISTORY_KEY, JSON.stringify(messages));
        } catch(e) {
            console.error("Ошибка сохранения чата комнаты в localStorage:", e);
            showCustomAlert("Ошибка: не удалось сохранить историю чата. Возможно, она слишком большая.");
        }
        allMessages = messages;
    }
    function loadRoomChat() {
      let msgs = JSON.parse(localStorage.getItem(ROOM_HISTORY_KEY) || "[]");
      return msgs.map(msg => ({ ...msg, attachments: msg.attachments || null }));
    }

    let allMessages = [];

    function loadAndRenderMessages(scrollToIndex = -1) {
        messagesBox.innerHTML = "";
        let characterForBackground = null;

        if (currentMode === "personal") {
            const name = getCurrentCharacterName();
            if (!name) {
                displayInitialHelperMessage();
                applyBackground(null);
                allMessages = [];
                return;
            }
            allMessages = loadChat(name);
            characterForBackground = name;
            if (allMessages.length === 0 && characters[name]?.welcomeMessage) {
                const welcome = characters[name].welcomeMessage;
                const welcomeMsgObject = { role: "assistant", content: welcome, avatar: characters[name].avatarCharacter, attachments: null };
                allMessages.push(welcomeMsgObject);
                saveChat(name, allMessages);
            } else if (allMessages.length === 0) {
                 const helperP = document.createElement('p');
                 helperP.style.textAlign = 'center'; helperP.style.color = 'var(--text-color)'; helperP.style.padding = '20px'; helperP.style.fontStyle = 'italic'; helperP.style.opacity = '0.7';
                 helperP.textContent = 'Нет сообщений. Начните диалог!';
                 messagesBox.appendChild(helperP);
            }
        } else {
            allMessages = loadRoomChat();
            characterForBackground = null;
            if (allMessages.length === 0) {
                const helperP = document.createElement('p');
                helperP.style.textAlign = 'center'; helperP.style.color = 'var(--text-color)'; helperP.style.padding = '20px'; helperP.style.fontStyle = 'italic'; helperP.style.opacity = '0.7';
                helperP.textContent = 'Нет сообщений в групповом чате. Начните диалог!';
                messagesBox.appendChild(helperP);
            }
        }
        applyBackground(characterForBackground);

        const fragment = document.createDocumentFragment();
        allMessages.forEach((msg, i) => {
            const container = createMessageContainerDOM(msg, i);
            fragment.appendChild(container);
        });
        messagesBox.appendChild(fragment);

        if (scrollToIndex !== -1 && scrollToIndex < allMessages.length) {
            const targetMsgEl = messagesBox.children[scrollToIndex];
            if (targetMsgEl) targetMsgEl.scrollIntoView({ behavior: "smooth", block: "nearest" });
        } else if (shouldScrollToBottom) {
            scrollToBottom(true);
            shouldScrollToBottom = false;
        }
    }


    // --- Message DOM Manipulation ---
    function createMessageContainerDOM(msgData, index) {
      const container = document.createElement("div");
      container.className = "message-container";
      container.dataset.index = index;

      let senderName, msgClass, roleForButtons, avatarUrl;
      const charNameForMsg = getCurrentCharacterName();

      if (currentMode === "personal") {
        senderName = msgData.role === "user" ? "Вы" : charNameForMsg;
        msgClass = msgData.role === "user" ? "user" : (msgData.role === "system" ? "system" : (msgData.role === "api" ? "api" : ""));
        roleForButtons = msgData.role;
        if (msgData.role === "user") {
          avatarUrl = characters[charNameForMsg]?.avatarUser || "https://placehold.co/80x80/7AC5FF/FFFFFF?text=Вы";
        } else if (msgData.role === "assistant") {
          avatarUrl = characters[charNameForMsg]?.avatarCharacter || "https://placehold.co/80x80/FF7AAC/FFFFFF?text=" + (charNameForMsg ? charNameForMsg.charAt(0) : "Б");
        } else {
          avatarUrl = msgData.role === "system" ? "https://placehold.co/80x80/CCCCCC/FFFFFF?text=S" : "https://placehold.co/80x80/80D0C0/FFFFFF?text=A";
        }
      } else {
        senderName = msgData.sender || (msgData.role === "user" ? "Вы" : "Система");
        msgClass = (msgData.sender === "Вы" || msgData.role === "user") ? "user" : (msgData.role === "system" ? "system" : (msgData.role === "api" ? "api" : ""));
        roleForButtons = msgData.role;
        if (msgData.sender === "Вы") {
          const anyUserAvatar = Object.values(characters).find(c => c.avatarUser)?.avatarUser;
          avatarUrl = anyUserAvatar || "https://placehold.co/80x80/7AC5FF/FFFFFF?text=Вы";
        } else if (characters[msgData.sender]) {
          avatarUrl = characters[msgData.sender].avatarCharacter || "https://placehold.co/80x80/FF7AAC/FFFFFF?text=" + msgData.sender.charAt(0);
        } else {
          avatarUrl = msgData.role === "system" ? "https://placehold.co/80x80/CCCCCC/FFFFFF?text=S" : "https://placehold.co/80x80/80D0C0/FFFFFF?text=A";
        }
      }
      avatarUrl = msgData.avatar || avatarUrl;
      if (msgClass === "user") container.classList.add("user-container");

      const contentWrapper = document.createElement('div');
      contentWrapper.className = 'message-content-wrapper';

      const avatarImg = document.createElement("img");
      avatarImg.src = avatarUrl || "https://placehold.co/80x80/CCCCCC/FFFFFF?text=?";
      avatarImg.alt = `Аватар ${senderName}`;
      avatarImg.className = "avatar";
      avatarImg.onerror = function() { this.onerror=null; this.src='https://placehold.co/80x80/CCCCCC/FFFFFF?text=?'; };


      const messageDiv = document.createElement("div");
      messageDiv.className = `message ${msgClass}`;

      let htmlContent = "";
      let textPart = msgData.content ? marked.parse(msgData.content) : '';
      htmlContent = `<strong>${senderName}:</strong>${textPart}`;
      messageDiv.innerHTML = htmlContent;

      if (msgData.attachments && msgData.attachments.length > 0) {
        const attachmentsGrid = document.createElement('div');
        attachmentsGrid.className = 'attachments-grid';
        msgData.attachments.forEach(att => {
            if (att.type && att.type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = att.src;
                img.alt = att.name || 'Прикрепленное изображение';
                img.className = 'attached-image';
                attachmentsGrid.appendChild(img);
            } else {
                const fileLink = document.createElement('a');
                fileLink.href = att.src;
                fileLink.target = '_blank';
                fileLink.className = 'attached-file-link';
                fileLink.download = att.name || 'file';
                fileLink.innerHTML = `<span class="file-icon">📄</span> ${att.name || 'Прикрепленный файл'}`;
                attachmentsGrid.appendChild(fileLink);
            }
        });
        messageDiv.appendChild(attachmentsGrid);
      }


      contentWrapper.appendChild(avatarImg);
      contentWrapper.appendChild(messageDiv);
      container.appendChild(contentWrapper);

      if (index !== null && roleForButtons !== "system" && senderName !== "API" && senderName !== "Система") {
        const buttonsDiv = document.createElement("div");
        buttonsDiv.className = "message-buttons";

        const copyBtn = document.createElement("button");
        copyBtn.className = "copy-btn"; copyBtn.title = "Копировать";
        copyBtn.setAttribute("aria-label", "Копировать сообщение");
        copyBtn.addEventListener("click", () => copyMessageToClipboard(msgData.content || ""));
        buttonsDiv.appendChild(copyBtn);

        const editBtn = document.createElement("button");
        editBtn.className = "edit-btn"; editBtn.title = "Редактировать";
        editBtn.setAttribute("aria-label", "Редактировать сообщение");
        editBtn.addEventListener("click", () => startEditingMessage(container, index));
        buttonsDiv.appendChild(editBtn);

        if (roleForButtons === "assistant") {
          const regenBtn = document.createElement("button");
          regenBtn.className = "regen-btn"; regenBtn.title = "Регенерировать";
          regenBtn.setAttribute("aria-label", "Регенерировать ответ");
          regenBtn.addEventListener("click", () => regenerateMessage(index));
          if (isBotGenerating) regenBtn.disabled = true;
          buttonsDiv.appendChild(regenBtn);
        }

        const delBtn = document.createElement("button");
        delBtn.className = "delete-btn"; delBtn.title = "Удалить";
        delBtn.setAttribute("aria-label", "Удалить сообщение");
        delBtn.addEventListener("click", () => deleteMessage(index));
        buttonsDiv.appendChild(delBtn);

        container.appendChild(buttonsDiv);
      }
      return container;
    }

    function appendNewMessageToDOM(msgData, index) {
        const container = createMessageContainerDOM(msgData, index);
        messagesBox.appendChild(container);
        requestAnimationFrame(() => {
            container.style.opacity = 1;
            container.style.transform = 'translateY(0)';
        });
        if (shouldScrollToBottom) {
            scrollToBottom(true);
        }
    }

    function updateMessageInDOM(index, newMsgData) {
        const oldContainer = messagesBox.querySelector(`.message-container[data-index="${index}"]`);
        if (oldContainer) {
            const newContainer = createMessageContainerDOM(newMsgData, index);
            messagesBox.replaceChild(newContainer, oldContainer);
             requestAnimationFrame(() => {
                newContainer.style.opacity = 1;
                newContainer.style.transform = 'translateY(0)';
            });
        }
    }
    function removeMessageFromDOM(index) {
        const containerToRemove = messagesBox.querySelector(`.message-container[data-index="${index}"]`);
        if (containerToRemove) {
            messagesBox.removeChild(containerToRemove);
            const messageContainers = messagesBox.querySelectorAll('.message-container');
            messageContainers.forEach((container, newIdx) => {
                container.dataset.index = newIdx;
            });
        }
    }


    function scrollToBottom(force = false) {
      if (force || messagesBox.scrollTop + messagesBox.clientHeight >= messagesBox.scrollHeight - 100) {
        messagesBox.scrollTop = messagesBox.scrollHeight;
      }
    }

    // --- Message Editing ---
    function startEditingMessage(container, index) {
      const messageContentWrapper = container.querySelector(".message-content-wrapper");
      const messageButtons = container.querySelector(".message-buttons");
      if (!messageContentWrapper || container.querySelector(".message-edit-area")) return;

      let originalText = allMessages[index].content;

      messageContentWrapper.style.display = "none";
      if (messageButtons) messageButtons.style.display = "none";

      const editArea = document.createElement("textarea");
      editArea.className = "message-edit-area";
      editArea.value = originalText;
      editArea.style.height = 'auto';
      editArea.style.height = (Math.max(80, editArea.scrollHeight)) + 'px';
      editArea.addEventListener('input', () => {
          editArea.style.height = 'auto';
          editArea.style.height = (Math.max(80, editArea.scrollHeight)) + 'px';
      });

      const saveBtn = document.createElement("button");
      saveBtn.textContent = "Сохранить"; saveBtn.className = "send-button";
      saveBtn.style.marginRight = "0.5rem";

      const cancelBtn = document.createElement("button");
      cancelBtn.textContent = "Отмена"; cancelBtn.className = "send-button";
      cancelBtn.style.background = "var(--participant-bg)"; cancelBtn.style.color = "var(--text-color)";

      const btnContainer = document.createElement("div");
      btnContainer.className = "edit-button-container";
      btnContainer.appendChild(saveBtn); btnContainer.appendChild(cancelBtn);

      container.insertBefore(editArea, messageContentWrapper);
      container.insertBefore(btnContainer, editArea.nextSibling);
      editArea.focus();

      saveBtn.onclick = () => {
        const newText = editArea.value.trim();
        const currentMessageAttachments = allMessages[index]?.attachments;
        if (!newText && (!currentMessageAttachments || currentMessageAttachments.length === 0)) {
            return showCustomAlert("Сообщение не может быть пустым, если нет вложений.");
        }
        updateMessageContent(index, newText);

        if (allMessages[index].role === 'user' || allMessages[index].sender === 'Вы') {
            const charToRespondName = currentMode === 'personal' ? getCurrentCharacterName() : getLastBotSender(index);
            if (charToRespondName && characters[charToRespondName]) {
                triggerBotResponseAfterEdit(index, charToRespondName);
            }
        }
      };
      cancelBtn.onclick = () => {
        messageContentWrapper.style.display = "flex";
        if (messageButtons) messageButtons.style.display = "flex";
        container.removeChild(editArea);
        container.removeChild(btnContainer);
      };
    }

    function getLastBotSender(currentUserMsgIndex) {
        if (currentMode !== 'group') return null;
        for (let i = currentUserMsgIndex - 1; i >= 0; i--) {
            if (allMessages[i].role === 'assistant' && allMessages[i].sender && characters[allMessages[i].sender]) {
                return allMessages[i].sender;
            }
        }
        return Object.keys(characters).length > 0 ? Object.keys(characters)[0] : null;
    }

    async function triggerBotResponseAfterEdit(editedUserMessageIndex, characterNameToRespond) {
        const charDataForApi = characters[characterNameToRespond];
        if (!charDataForApi) return;

        const historyUpToEdited = allMessages.slice(0, editedUserMessageIndex + 1);
        const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
        const max_tokens = parseInt(document.getElementById("maxTokens").value) || 1024;

        if (allMessages.length > editedUserMessageIndex + 1) {
            allMessages.splice(editedUserMessageIndex + 1);
             if (currentMode === "personal") saveChat(getCurrentCharacterName(), allMessages);
             else saveRoomChat(allMessages);
            loadAndRenderMessages(editedUserMessageIndex);
        }

        const systemPromptText = getSystemContent(charDataForApi, allMessages[editedUserMessageIndex].content);

        if (useGoogleApi && googleApiKey && googleApiModel) {
            let geminiContents = [];
            historyUpToEdited.forEach(m => {
                let role = (m.sender === "Вы" || m.role === "user") ? "user" : "model";
                let textContent = (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${m.content}` : m.content;

                let parts = [];
                if (textContent) parts.push({ text: textContent });
                if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                    m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                        parts.push({ inlineData: { mimeType: att.type, data: att.src.split(',')[1] } });
                    });
                } else if (m.attachments) {
                     parts.push({ text: `[Прикреплено ${m.attachments.length} файлов]` });
                }

                if (parts.length > 0) {
                     if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                        console.warn("Consecutive roles for Gemini (after edit), appending parts:", role);
                        geminiContents[geminiContents.length - 1].parts.push(...parts);
                    } else {
                        geminiContents.push({ role: role, parts: parts });
                    }
                }
            });
            let lastValidRoleAfterEdit = null;
            geminiContents = geminiContents.filter(item => {
                if (item.role === lastValidRoleAfterEdit) return false;
                lastValidRoleAfterEdit = item.role;
                return true;
            });

            
            // Добавляем пост-инструкции в systemPromptText (если заданы) чтобы Gemini учитывал их с повышенным приоритетом
            try {
                const postEl = document.getElementById('post_history_instructions');
                const postInstr = postEl ? postEl.value.trim() : '';
                if (postInstr) {
                    // добавляем в конец systemPromptText, отделяя переносами для ясности
                    systemPromptText = (systemPromptText ? systemPromptText + "\n\n" : "") + postInstr;
                }
            } catch(e){ console.error('post history instructions append error', e); }
        await fetchGeminiChatCompletion(
                googleApiKey, googleApiModel, systemPromptText, geminiContents,
                temperature, max_tokens, characterNameToRespond,
                allMessages, charDataForApi.avatarCharacter, true
            );

        } else {
            let messagesForAPI = [{ role: "system", content: systemPromptText }];
            messagesForAPI.push(...historyUpToEdited.map(m => {
                let apiMsgContentArray = [];
                if (m.content) apiMsgContentArray.push({ type: "text", text: m.content });
                // Append post-history instructions as system (if present)
                try {
                    const postEl = document.getElementById('post_history_instructions');
                    const postInstr = postEl ? postEl.value.trim() : '';
                    if (postInstr) {
                        messagesForAPI.push({ role: "system", content: postInstr });
                    }
                } catch(e){ console.error('post history instructions append error', e); }
                
                if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                    m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                         apiMsgContentArray.push({ type: "image_url", image_url: { url: att.src } });
                    });
                } else if (m.attachments) {
                     apiMsgContentArray.push({ type: "text", text: `[Прикреплено ${m.attachments.length} файлов]` });
                }
                const finalContent = apiMsgContentArray.length === 1 && apiMsgContentArray[0].type === "text" ? apiMsgContentArray[0].text : apiMsgContentArray;

                return {
                    role: (m.sender === "Вы" || m.role === "user") ? "user" : "assistant",
                    content: (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${finalContent}` : finalContent
                };
            }));

            const apiKey = document.getElementById("apiKey").value;
            const apiUrl = document.getElementById("apiUrl").value;
            const modelForApi = charDataForApi.model || document.getElementById("model").value;

            await fetchChatCompletion(
                apiUrl, apiKey, modelForApi, messagesForAPI,
                temperature, max_tokens, characterNameToRespond,
                allMessages, charDataForApi.avatarCharacter, true
            );
        }
    }


    function updateMessageContent(index, newContent) {
      if (index < 0 || index >= allMessages.length) return;
      const msgToUpdate = allMessages[index];
      msgToUpdate.content = newContent;

      if (currentMode === "personal") {
        const name = getCurrentCharacterName();
        if (!name) return;
        saveChat(name, allMessages);
      } else {
        saveRoomChat(allMessages);
      }
      updateMessageInDOM(index, msgToUpdate);
    }

    function deleteMessage(index) {
      if (index < 0 || index >= allMessages.length) return;
      showCustomConfirm("Вы уверены, что хотите удалить это сообщение?", () => {
        allMessages.splice(index, 1);

        if (currentMode === "personal") {
          const name = getCurrentCharacterName();
          if (!name) return;
          saveChat(name, allMessages);
        } else {
          saveRoomChat(allMessages);
        }
        removeMessageFromDOM(index);
        clearVariants();
        if (allMessages.length === 0) {
            loadAndRenderMessages();
        }
      });
    }

    // --- Message Regeneration ---
    async function regenerateMessage(index) {
        if (isBotGenerating) return;
        if (index < 0 || index >= allMessages.length || allMessages[index].role !== 'assistant') {
            showCustomAlert("Можно регенерировать только ответ ассистента.");
            return;
        }

        isBotGenerating = true;
        updateRegenerateButtonsState(true);
        setStatusActive(true);

        const characterForResponse = currentMode === "personal" ? getCurrentCharacterName() : allMessages[index].sender;
        if (!characterForResponse || !characters[characterForResponse]) {
            showCustomAlert("Не удалось определить персонажа для регенерации.");
            isBotGenerating = false; updateRegenerateButtonsState(false); setStatusActive(false);
            return;
        }
        const charData = characters[characterForResponse];

        let userMsgIndex = -1;
        for (let i = index - 1; i >= 0; i--) {
            const msg = allMessages[i];
            const isUserMsg = (currentMode === "personal" && msg.role === "user") ||
                              (currentMode === "group" && (msg.sender === "Вы" || msg.role === "user"));
            if (isUserMsg) {
                userMsgIndex = i;
                break;
            }
        }
        if (userMsgIndex === -1) {
            showCustomAlert("Не найдено предыдущее сообщение пользователя для контекста регенерации.");
            isBotGenerating = false; updateRegenerateButtonsState(false); setStatusActive(false);
            return;
        }

        if (regenerateVariants.length === 0 || currentVariantIndex === -1) {
            regenerateVariants = [JSON.parse(JSON.stringify(allMessages))];
            currentVariantIndex = 0;
        }

        const historyForAPI = allMessages.slice(0, index);
        const userMessageContentForSystem = allMessages[userMsgIndex].content;

        const targetMessageContainer = messagesBox.querySelector(`.message-container[data-index="${index}"]`);
        const messageDivToUpdate = targetMessageContainer ? targetMessageContainer.querySelector('.message') : null;

        if (messageDivToUpdate) {
            messageDivToUpdate.innerHTML = `<strong>${characterForResponse}:</strong> ...регенерируется...`;
            scrollToBottom(true);
        }

        let newVariantChatState;

        try {
            let reply;
            const systemPromptText = getSystemContent(charData, userMessageContentForSystem);

            if (useGoogleApi && googleApiKey && googleApiModel) {
                let geminiContents = [];
                 historyForAPI.forEach(m => {
                    let role = (m.sender === "Вы" || m.role === "user") ? "user" : "model";
                    let textContent = (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${m.content}` : m.content;
                    let parts = [];
                    if (textContent) parts.push({ text: textContent });
                    if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                        m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                            parts.push({ inlineData: { mimeType: att.type, data: att.src.split(',')[1] } });
                        });
                    } else if (m.attachments) {
                        parts.push({ text: `[Прикреплено ${m.attachments.length} файлов]` });
                    }
                    if (parts.length > 0) {
                         if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                             console.warn("Consecutive roles for Gemini (regen), appending parts:", role);
                             geminiContents[geminiContents.length - 1].parts.push(...parts);
                         } else {
                            geminiContents.push({ role: role, parts: parts });
                         }
                    }
                });
                let lastValidRoleRegen = null;
                geminiContents = geminiContents.filter(item => {
                    if (item.role === lastValidRoleRegen) return false;
                    lastValidRoleRegen = item.role;
                    return true;
                });

                const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${googleApiModel}:generateContent?key=${googleApiKey}`;
                const geminiRequestBody = {
                    systemInstruction: { parts: [{ text: systemPromptText }] },
                    contents: geminiContents,
                    generationConfig: {
                        temperature: parseFloat(document.getElementById("temperature").value) || 0.7,
                        maxOutputTokens: parseInt(document.getElementById("maxTokens").value) || 1024
                    }
                };
                const response = await fetch(geminiUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(geminiRequestBody)
                });
                if (!response.ok) throw new Error(`Google API Ошибка: ${response.status} ${await response.text()}`);
                const result = await response.json();
                reply = result.candidates?.[0]?.content?.parts?.[0]?.text || "";
                if (!reply && !(result.candidates && result.candidates[0].finishReason === "MAX_TOKENS")) throw new Error("Пустой ответ от Google API.");

                newVariantChatState = JSON.parse(JSON.stringify(allMessages.slice(0, index)));
                const newBotMsgData = {
                    ...allMessages[index],
                    content: reply,
                    attachments: null,
                };
                newVariantChatState.push(newBotMsgData);
                if (allMessages.length > index + 1) {
                    newVariantChatState.push(...JSON.parse(JSON.stringify(allMessages.slice(index + 1))));
                }
                regenerateVariants.push(newVariantChatState);
                currentVariantIndex = regenerateVariants.length - 1;
                allMessages = [...newVariantChatState];
                if (currentMode === "personal") saveChat(getCurrentCharacterName(), allMessages);
                else saveRoomChat(allMessages);
                updateMessageInDOM(index, allMessages[index]);
                scrollToBottom(true);
                shouldScrollToBottom = false;

            } else {
                shouldScrollToBottom = true;
                let messagesForStdAPI = [{ role: "system", content: systemPromptText }];
                messagesForStdAPI.push(...historyForAPI.map(m => {
                     let apiContentArray = [];
                     if (m.content) apiContentArray.push({ type: "text", text: m.content });
                // Append 'Инструкции после истории' как system-сообщение (если задано)
                try {
                    const postEl = document.getElementById('post_history_instructions');
                    const postInstr = postEl ? postEl.value.trim() : '';
                    if (postInstr) {
                        messagesForStdAPI.push({ role: "system", content: postInstr });
                    }
                } catch(e){ console.error('post history instructions append error', e); }
                
                     if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                         m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                              apiContentArray.push({ type: "image_url", image_url: { url: att.src } });
                         });
                     } else if (m.attachments) {
                         apiContentArray.push({ type: "text", text: ` [Прикреплено ${m.attachments.length} файлов]` });
                     }
                     const finalContent = apiContentArray.length === 1 && apiContentArray[0].type === "text" ? apiContentArray[0].text : apiContentArray;
                    return {
                        role: (m.sender === "Вы" || m.role === "user") ? "user" : "assistant",
                        content: (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${finalContent}` : finalContent
                    };
                }));

                const apiKey = document.getElementById("apiKey").value;
                const apiUrl = document.getElementById("apiUrl").value;
                const model = charData.model || document.getElementById("model").value;
                const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
                const max_tokens = parseInt(document.getElementById("maxTokens").value) || 1024;

                const response = await fetch(apiUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "Authorization": `Bearer ${apiKey}` },
                    body: JSON.stringify({ model, messages: messagesForStdAPI, stream: true, max_tokens, temperature })
                });
                if (!response.ok) throw new Error(`HTTP ошибка! Статус: ${response.status} ${await response.text()}`);

                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let streamedContent = "";
                reply = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value);
                    const lines = chunk.split("\n").filter(line => line.trim().startsWith("data: "));
                    for (const line of lines) {
                        if (line.includes("[DONE]")) break;
                        const jsonString = line.replace(/^data: /, "");
                        try {
                            const parsed = JSON.parse(jsonString);
                            const content = parsed.choices?.[0]?.delta?.content;
                            if (content) {
                                streamedContent += content;
                                reply = removeThoughts(streamedContent);
                                if (messageDivToUpdate) {
                                    messageDivToUpdate.innerHTML = `<strong>${characterForResponse}:</strong>${marked.parse(reply)}`;
                                    scrollToBottom(true);
                                }
                            }
                        } catch (e) { /* console.warn("Stream parsing error:", e, jsonString); */ }
                    }
                }
                if (!reply && streamedContent) reply = removeThoughts(streamedContent);

                newVariantChatState = JSON.parse(JSON.stringify(allMessages.slice(0, index)));
                const newBotMsgDataStreaming = {
                    ...allMessages[index],
                    content: reply,
                    attachments: null,
                };
                newVariantChatState.push(newBotMsgDataStreaming);
                if (allMessages.length > index + 1) {
                    newVariantChatState.push(...JSON.parse(JSON.stringify(allMessages.slice(index + 1))));
                }
                regenerateVariants.push(newVariantChatState);
                currentVariantIndex = regenerateVariants.length - 1;
                allMessages = [...newVariantChatState];
                if (currentMode === "personal") saveChat(getCurrentCharacterName(), allMessages);
                else saveRoomChat(allMessages);
                if (!messageDivToUpdate) {
                    updateMessageInDOM(index, allMessages[index]);
                }
            }
        } catch (err) {
            console.error("Ошибка регенерации:", err);
            if (messageDivToUpdate) {
                 const originalMessageOfCurrentVariant = regenerateVariants[currentVariantIndex] ? regenerateVariants[currentVariantIndex][index] : null;
                 const veryFirstOriginalMessage = regenerateVariants[0] ? regenerateVariants[0][index] : null;
                 const messageToRevertTo = originalMessageOfCurrentVariant || veryFirstOriginalMessage;

                 if (messageToRevertTo) {
                    updateMessageInDOM(index, messageToRevertTo);
                    allMessages[index] = JSON.parse(JSON.stringify(messageToRevertTo));
                 } else {
                    messageDivToUpdate.innerHTML = `<strong>${characterForResponse}:</strong> Ошибка регенерации: ${err.message}`;
                 }
            } else {
                appendNewMessageToDOM({ sender: "Система", content: `Ошибка регенерации: ${err.message}`, role: "system" }, allMessages.length);
            }
        } finally {
            setStatusActive(false);
            isBotGenerating = false;
            updateRegenerateButtonsState(false);
            updateVariantControls();
            if (shouldScrollToBottom) { scrollToBottom(true); shouldScrollToBottom = false; }
            userInput.focus();
        }
    }


    function updateRegenerateButtonsState(disable) {
        const regenBtns = document.querySelectorAll('.message-buttons .regen-btn');
        regenBtns.forEach(btn => btn.disabled = disable);
    }


    function renderSpecificChatState(chatState) {
        messagesBox.innerHTML = "";
        const fragment = document.createDocumentFragment();
        chatState.forEach((msg, i) => {
            const container = createMessageContainerDOM(msg, i);
            fragment.appendChild(container);
        });
        messagesBox.appendChild(fragment);
        scrollToBottom(true);
    }


    function updateVariantControls() {
      const hasVariants = regenerateVariants.length > 1;
      [prevVariantBtn, nextVariantBtn, applyVariantBtn, variantCounter].forEach(el => {
          if (el) el.style.display = hasVariants ? "inline-block" : "none";
      });
      if (!hasVariants) {
        if (variantCounter) variantCounter.textContent = "";
        if(prevVariantBtn) prevVariantBtn.disabled = true;
        if(nextVariantBtn) nextVariantBtn.disabled = true;
        return;
      }
      if (currentVariantIndex < 0 && regenerateVariants.length > 0) currentVariantIndex = 0;
      if (currentVariantIndex >= regenerateVariants.length) currentVariantIndex = regenerateVariants.length - 1;

      if (variantCounter) variantCounter.textContent = `Вариант ${currentVariantIndex + 1} / ${regenerateVariants.length}`;
      if (prevVariantBtn) prevVariantBtn.disabled = currentVariantIndex === 0;
      if (nextVariantBtn) nextVariantBtn.disabled = currentVariantIndex === regenerateVariants.length - 1;
    }
    function prevVariant() { if (currentVariantIndex > 0) { currentVariantIndex--; renderVariant(); updateVariantControls(); } }
    function nextVariant() { if (currentVariantIndex < regenerateVariants.length - 1) { currentVariantIndex++; renderVariant(); updateVariantControls(); } }
    function applyVariant() {
      if (currentVariantIndex < 0 || currentVariantIndex >= regenerateVariants.length) return;
      const variantToApply = regenerateVariants[currentVariantIndex];
      allMessages = [...variantToApply];

      if (currentMode === "personal") {
        const name = getCurrentCharacterName();
        if (!name) return;
        saveChat(name, allMessages);
      } else {
        saveRoomChat(allMessages);
      }
      clearVariantsAndRender();
    }
    function renderVariant() {
      if (currentVariantIndex < 0 || currentVariantIndex >= regenerateVariants.length) return;
      renderSpecificChatState(regenerateVariants[currentVariantIndex]);
    }
    function clearVariants() { regenerateVariants = []; currentVariantIndex = -1; updateVariantControls(); }
    function clearVariantsAndRender() {
        clearVariants();
        shouldScrollToBottom = true;
        loadAndRenderMessages();
    }


    function getNeuralMemory() { return document.getElementById("neuralMemory").value.trim(); }

    function getSystemContent(charData, userMessage) {
        const memory = getNeuralMemory();
        const dateTime = new Date().toLocaleString('ru-RU', { dateStyle: 'full', timeStyle: 'short' });
        const dateTimeInfo = `[Текущие дата и время]: ${dateTime}`;

        // Build a comprehensive character definition string
        let characterDefinition = "";
        if (charData.description) characterDefinition += `[Описание персонажа]\n${charData.description}\n\n`;
        if (charData.personality) characterDefinition += `[Личность]\n${charData.personality}\n\n`;
        if (charData.scenario) characterDefinition += `[Сценарий]\n${charData.scenario}\n\n`;
        if (charData.mes_example) characterDefinition += `[Пример диалога]\n${charData.mes_example}\n\n`;

        // Start building the final system prompt
        let systemContent = `${characterDefinition.trim()}\n\n${dateTimeInfo}`;

        if (memory) {
            systemContent += `\n\n[Память нейросети (глобальные заметки)]:\n${memory}`;
        }

        // Add character's specific system_prompt if it exists
        if (charData.system_prompt) {
            systemContent += `\n\n[Дополнительные системные инструкции]\n${charData.system_prompt}`;
        }

        // Check lorebook entries against the user's message
        if (charData.lorebook && charData.lorebook.length > 0 && userMessage) {
            const triggeredEntries = charData.lorebook.filter(entry =>
                entry.triggers && entry.triggers.some(trigger => userMessage.toLowerCase().includes(trigger.toLowerCase().trim()))
            );
            if (triggeredEntries.length > 0) {
                const loreInfo = triggeredEntries.map(entry => {
                    let entryPrefix = "- ";
                    if (entry.entryName) {
                        entryPrefix = `- [${entry.entryName}]: `;
                    }
                    return `${entryPrefix}${entry.info}`;
                }).join("\n");
                systemContent += `\n\n[Информация из Lorebook (активировано триггерами в последнем сообщении пользователя)]:\n${loreInfo}`;
            }
        }
        return systemContent.trim();
    }


    async function sendToRestApi(userMessageContent, attachmentsArray = null) {
        if (!restApiUrlValue) {
            appendNewMessageToDOM({sender:"Система", content:"URL REST API не настроен.", role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"}, allMessages.length);
            return;
        }
        setStatusActive(true);
        const apiPlaceholderAvatar = "https://placehold.co/80x80/80D0C0/FFFFFF?text=A";
        const placeholderMsgData = {sender:"API", content:"Отправка запроса на REST API...", role:"api", avatar: apiPlaceholderAvatar, attachments: attachmentsArray};
        allMessages.push(placeholderMsgData);
        appendNewMessageToDOM(placeholderMsgData, allMessages.length -1);


        try {
            const requestBody = { message: userMessageContent, attachments: attachmentsArray };
            const response = await fetch(restApiUrlValue, {
                method: "POST",
                headers: { "Content-Type": "application/json", ...restApiHeadersValue },
                body: JSON.stringify(requestBody)
            });

            const placeholderIndex = allMessages.findIndex(m => m.content === "Отправка запроса на REST API..." && m.sender === "API");
            if (placeholderIndex > -1) {
                allMessages.splice(placeholderIndex, 1);
                removeMessageFromDOM(placeholderIndex);
            }


            const responseData = await response.json();
            if (!response.ok) throw new Error(`API Ошибка: ${response.status} - ${responseData.error || JSON.stringify(responseData)}`);

            let apiReplyText = responseData.reply || responseData.message || JSON.stringify(responseData.data) || JSON.stringify(responseData);
            const apiReplyMsgData = {sender:"API", content:apiReplyText, role:"api", avatar: apiPlaceholderAvatar, attachments: responseData.attachments};
            allMessages.push(apiReplyMsgData);
            appendNewMessageToDOM(apiReplyMsgData, allMessages.length - 1);


        } catch (error) {
            console.error("REST API Ошибка:", error);
            const placeholderIndexOnError = allMessages.findIndex(m => m.content === "Отправка запроса на REST API..." && m.sender === "API");
            if (placeholderIndexOnError > -1) {
                 allMessages.splice(placeholderIndexOnError, 1);
                removeMessageFromDOM(placeholderIndexOnError);
            }
            const errorMsgData = {sender:"Система", content:`Ошибка REST API: ${error.message}`, role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"};
            allMessages.push(errorMsgData);
            appendNewMessageToDOM(errorMsgData, allMessages.length - 1);

        } finally {
            setStatusActive(false);
            scrollToBottom(true);
            userInput.focus();
        }
    }
    function setupRestApiSwitch() {
        const enableRestApiCheckbox = document.getElementById("enableRestApi");
        enableRestApiCheckbox.addEventListener("change", () => {
            useRestApi = enableRestApiCheckbox.checked;
            saveToStorage(ENABLE_REST_API_STORAGE, useRestApi.toString());
        });
    }

    async function respondToLastMessage(characterName) {
      if (isBotGenerating) return;
      isBotGenerating = true;
      updateRegenerateButtonsState(true);

      const currentGroupMessages = [...allMessages];
      if (currentGroupMessages.length === 0) {
          showCustomAlert("Нет сообщений для ответа.");
          isBotGenerating = false; updateRegenerateButtonsState(false); return;
      }
      if (!characters[characterName]) {
          showCustomAlert(`Персонаж "${characterName}" не найден.`);
          isBotGenerating = false; updateRegenerateButtonsState(false); return;
      }

      const charData = characters[characterName];
      let lastUserMessageForContext = "";
      let lastUserMessageAttachments = null;
      for (let i = currentGroupMessages.length -1; i >= 0; i--) {
          if ((currentGroupMessages[i].sender === "Вы" || currentGroupMessages[i].role === "user")) {
              lastUserMessageForContext = currentGroupMessages[i].content;
              lastUserMessageAttachments = currentGroupMessages[i].attachments;
              break;
          }
      }

      const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
      const max_tokens = parseInt(document.getElementById("maxTokens").value) || 1024;
      const systemPromptText = getSystemContent(charData, lastUserMessageForContext);


      if (useGoogleApi && googleApiKey && googleApiModel) {
        let geminiContents = [];
        currentGroupMessages.forEach(m => {
            let role = (m.sender === "Вы" || m.role === "user") ? "user" : "model";
            let textContent = (m.sender !== "Вы" && m.role !== "user" && m.sender) ? `${m.sender}: ${m.content}` : m.content;

            let parts = [];
            if (textContent) parts.push({ text: textContent });
            if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                 m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                    parts.push({ inlineData: { mimeType: att.type, data: att.src.split(',')[1] } });
                 });
            } else if (m.attachments) {
                parts.push({ text: `[Прикреплено ${m.attachments.length} файлов]` });
            }

            if (parts.length > 0) {
                 if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                     console.warn("Consecutive roles for Gemini (respondToLast), appending parts:", role);
                     geminiContents[geminiContents.length - 1].parts.push(...parts);
                 } else {
                    geminiContents.push({ role: role, parts: parts });
                 }
            }
        });
        let lastValidRoleGroup = null;
        geminiContents = geminiContents.filter(item => {
            if (item.role === lastValidRoleGroup) return false;
            lastValidRoleGroup = item.role;
            return true;
        });

        await fetchGeminiChatCompletion(
            googleApiKey, googleApiModel, systemPromptText, geminiContents,
            temperature, max_tokens, characterName, allMessages, charData.avatarCharacter
        );

      } else {
        const model = charData.model || document.getElementById("model").value;
        const apiKey = document.getElementById("apiKey").value;
        const apiUrl = document.getElementById("apiUrl").value;
        const messagesForAPI = [
          { role: "system", content: systemPromptText },
          ...currentGroupMessages.map(m => {
              let apiContentArray = [];
              if (m.content) apiContentArray.push({ type: "text", text: m.content });
              if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                   m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                        apiContentArray.push({ type: "image_url", image_url: { url: att.src } });
                   });
              } else if (m.attachments) {
                  apiContentArray.push({ type: "text", text: ` [Прикреплено ${m.attachments.length} файлов]` });
              }

              const finalContent = apiContentArray.length === 1 && apiContentArray[0].type === "text" ? apiContentArray[0].text : apiContentArray;
              return {
                  role: (m.sender === "Вы" || m.role === "user") ? "user" : "assistant",
                  content: (m.sender !== "Вы" && m.role !== "user" && m.sender) ? `${m.sender}: ${finalContent}` : finalContent
              }
          })
        ];
        await fetchChatCompletion(apiUrl, apiKey, model, messagesForAPI, temperature, max_tokens, characterName, allMessages, charData.avatarCharacter);
      }
    }


    async function sendMessage() {
        if (isBotGenerating && !useRestApi && !(useGoogleApi && googleApiKey && googleApiModel) ) {
            return;
        }

        const messageContent = userInput.value.trim();
        if (!messageContent && attachedFiles.length === 0) return;

        clearVariants();
        const originalPlaceholder = userInput.placeholder;
        userInput.value = "";
        userInput.placeholder = "Отправка...";
        userInput.disabled = true;
        userInput.style.height = 'auto';
        userInput.style.height = (userInput.scrollHeight) + 'px';


        let userAvatarUrl;
        let activeCharNameForUserMsg = getCurrentCharacterName();
        let attachmentsDataArray = [];

        if (attachedFiles.length > 0) {
            for (const file of attachedFiles) {
                 attachmentsDataArray.push({
                    name: file.name,
                    type: file.type,
                    src: await readFileAsDataURL(file)
                });
            }
        }

        const userMsgObject = {
            role: "user",
            content: messageContent,
            attachments: attachmentsDataArray.length > 0 ? attachmentsDataArray : null
        };

        if (currentMode === "personal") {
            if (!activeCharNameForUserMsg) {
                showCustomAlert("Выберите персонажа для отправки сообщения.");
                userInput.placeholder = originalPlaceholder; userInput.disabled = false; userInput.focus(); return;
            }
            userAvatarUrl = characters[activeCharNameForUserMsg]?.avatarUser || "https://placehold.co/80x80/7AC5FF/FFFFFF?text=Вы";
            userMsgObject.avatar = userAvatarUrl;
            allMessages.push(userMsgObject);
            saveChat(activeCharNameForUserMsg, allMessages);
        } else {
            const anyUserAvatar = Object.values(characters).find(c => c.avatarUser)?.avatarUser;
            userAvatarUrl = anyUserAvatar || "https://placehold.co/80x80/7AC5FF/FFFFFF?text=Вы";
            userMsgObject.sender = "Вы";
            userMsgObject.avatar = userAvatarUrl;
            allMessages.push(userMsgObject);
            saveRoomChat(allMessages);
        }

        appendNewMessageToDOM(userMsgObject, allMessages.length - 1);
        shouldScrollToBottom = true;

        attachedFiles = [];
        renderFilePreviews();
        document.getElementById("fileInput").value = "";

        const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
        const max_tokens = parseInt(document.getElementById("maxTokens").value) || 1024;

        let charToRespondName, charDataForApi, systemContextMsgForLLM;
        if (currentMode === "personal") {
            charToRespondName = activeCharNameForUserMsg;
            charDataForApi = characters[charToRespondName];
            systemContextMsgForLLM = messageContent;
        } else {
            let lastBotSender = null;
            for (let i = allMessages.length - 2; i >= 0; i--) {
                if (allMessages[i].role === 'assistant' && allMessages[i].sender && characters[allMessages[i].sender]) {
                    lastBotSender = allMessages[i].sender; break;
                }
            }
            charToRespondName = lastBotSender || (Object.keys(characters).length > 0 ? Object.keys(characters)[0] : null);
            if (!charToRespondName || !characters[charToRespondName]) {
                const sysMsg = {sender:"Система", content:"Не удалось определить персонажа для ответа в группе.", role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"};
                allMessages.push(sysMsg); appendNewMessageToDOM(sysMsg, allMessages.length - 1);
                userInput.placeholder = originalPlaceholder; userInput.disabled = false; userInput.focus(); return;
            }
            charDataForApi = characters[charToRespondName];
            systemContextMsgForLLM = messageContent;
        }

        const systemPromptText = getSystemContent(charDataForApi, systemContextMsgForLLM);

        if (useGoogleApi && googleApiKey && googleApiModel) {
            isBotGenerating = true;
            updateRegenerateButtonsState(true);
            setStatusActive(true);
            shouldScrollToBottom = true;

            let geminiContents = [];
            allMessages.forEach(m => {
                let role = (m.sender === "Вы" || m.role === "user") ? "user" : "model";
                let textContent = (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${m.content}` : m.content;

                let parts = [];
                if (textContent) parts.push({ text: textContent });
                if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                     m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                        parts.push({ inlineData: { mimeType: att.type, data: att.src.split(',')[1] } });
                     });
                } else if (m.attachments) {
                    parts.push({ text: `[Прикреплено ${m.attachments.length} файлов]` });
                }


                if (parts.length > 0) {
                    if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                        console.warn("Consecutive roles for Gemini (send), appending parts:", role);
                         geminiContents[geminiContents.length - 1].parts.push(...parts);
                    } else {
                        geminiContents.push({ role: role, parts: parts });
                    }
                }
            });
            let lastValidRoleSend = null;
            geminiContents = geminiContents.filter(item => {
                if (item.role === lastValidRoleSend) return false;
                lastValidRoleSend = item.role;
                return true;
            });


            await fetchGeminiChatCompletion(
                googleApiKey, googleApiModel, systemPromptText, geminiContents,
                temperature, max_tokens, charToRespondName, allMessages, charDataForApi.avatarCharacter
            );


        } else if (useRestApi && restApiUrlValue) {
            shouldScrollToBottom = true;
            await sendToRestApi(messageContent, attachmentsDataArray);
        } else {
            isBotGenerating = true;
            updateRegenerateButtonsState(true);
            setStatusActive(true);
            shouldScrollToBottom = true;

            let messagesForAPI = [{ role: "system", content: systemPromptText }];
            messagesForAPI.push(...allMessages.map(m => {
                let apiMsgContentArray = [];
                if (m.content) apiMsgContentArray.push({ type: "text", text: m.content });
                if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                     m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                        apiMsgContentArray.push({ type: "image_url", image_url: { url: att.src } });
                     });
                } else if (m.attachments) {
                    apiMsgContentArray.push({ type: "text", text: `[Прикреплено ${m.attachments.length} файлов]` });
                }

                const finalContent = apiMsgContentArray.length === 1 && apiMsgContentArray[0].type === "text" ? apiMsgContentArray[0].text : apiMsgContentArray;
                return {
                    role: (m.sender === "Вы" || m.role === "user") ? "user" : "assistant",
                    content: (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${finalContent}` : finalContent
                };
            }));

            const apiKey = document.getElementById("apiKey").value;
            const apiUrl = document.getElementById("apiUrl").value;
            const modelForApi = charDataForApi.model || document.getElementById("model").value;

            await fetchChatCompletion(apiUrl, apiKey, modelForApi, messagesForAPI, temperature, max_tokens, charToRespondName, allMessages, charDataForApi.avatarCharacter);
        }
        userInput.placeholder = originalPlaceholder; userInput.disabled = false;
        userInput.focus(); // Keep focus on the input field
    }

    async function fetchGeminiChatCompletion(gApiKey, gModel, systemInstructionText, geminiContents, temperature, maxOutputTokens, apiCharacterName, chatArrayToUpdateRef, botAvatarUrl, isAfterEdit = false) {
        const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${gModel}:generateContent?key=${gApiKey}`;

        const requestBody = {
            systemInstruction: { parts: [{ text: systemInstructionText }] },
            contents: geminiContents,
            generationConfig: {
                temperature: temperature,
                maxOutputTokens: maxOutputTokens
            }
        };

        setStatusActive(true);

        const placeholderMsgData = { content: "...", role: "assistant", avatar: botAvatarUrl, attachments: null };
        if (currentMode === "group") {
            placeholderMsgData.sender = apiCharacterName;
        }

        let placeholderIndex = -1;
        if (!isAfterEdit) {
            chatArrayToUpdateRef.push(placeholderMsgData);
            placeholderIndex = chatArrayToUpdateRef.length - 1;
            appendNewMessageToDOM(placeholderMsgData, placeholderIndex);
        } else {
             chatArrayToUpdateRef.push(placeholderMsgData);
             placeholderIndex = chatArrayToUpdateRef.length - 1;
             appendNewMessageToDOM(placeholderMsgData, placeholderIndex);
        }


        try {
            const response = await fetch(geminiApiUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`Google API Ошибка: ${response.status} - ${errorBody}`);
            }
            const result = await response.json();
            const reply = result.candidates?.[0]?.content?.parts?.[0]?.text || "";

            if (!reply && !(result.candidates && result.candidates[0].finishReason === "MAX_TOKENS")) {
                 throw new Error("Пустой ответ от Google API или неожиданный формат.");
            }

            chatArrayToUpdateRef[placeholderIndex].content = reply;
            chatArrayToUpdateRef[placeholderIndex].attachments = null;
            if (currentMode === "group") {
                 chatArrayToUpdateRef[placeholderIndex].sender = apiCharacterName;
            }

            updateMessageInDOM(placeholderIndex, chatArrayToUpdateRef[placeholderIndex]);
            scrollToBottom(true);
            shouldScrollToBottom = false;

            if (currentMode === "personal") saveChat(getCurrentCharacterName(), chatArrayToUpdateRef);
            else saveRoomChat(chatArrayToUpdateRef);

        } catch (err) {
            console.error("fetchGeminiChatCompletion Ошибка:", err);
            if (chatArrayToUpdateRef[placeholderIndex] && chatArrayToUpdateRef[placeholderIndex].content === "...") {
                chatArrayToUpdateRef.splice(placeholderIndex, 1);
                removeMessageFromDOM(placeholderIndex);
            }
            const errorMsgData = {sender:"Система", content:`Ошибка Google Gemini API: ${err.message}`, role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"};
            chatArrayToUpdateRef.push(errorMsgData);
            appendNewMessageToDOM(errorMsgData, chatArrayToUpdateRef.length - 1);
        } finally {
            setStatusActive(false);
            isBotGenerating = false;
            updateRegenerateButtonsState(false);
            if (shouldScrollToBottom) { scrollToBottom(true); shouldScrollToBottom = false; }
            userInput.focus();
        }
    }


    async function fetchChatCompletion(apiUrl, apiKey, model, messagesForAPI, temperature, max_tokens, apiCharacterName, chatArrayToUpdateRef, botAvatarUrl, isAfterEdit = false) {
      const requestBody = { model, messages: messagesForAPI, stream: true, max_tokens, temperature };
      setStatusActive(true);
      shouldScrollToBottom = true;

      const placeholderMsgData = { content: "...", role: "assistant", avatar: botAvatarUrl, attachments: null };
      if (currentMode === "group") {
          placeholderMsgData.sender = apiCharacterName;
      }

      chatArrayToUpdateRef.push(placeholderMsgData);
      const placeholderIndex = chatArrayToUpdateRef.length - 1;
      appendNewMessageToDOM(placeholderMsgData, placeholderIndex);

      try {
        const response = await fetch(apiUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Authorization": `Bearer ${apiKey}` },
          body: JSON.stringify(requestBody)
        });
        if (!response.ok) throw new Error(`HTTP ошибка! Статус: ${response.status} ${await response.text()}`);

        const reader = response.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let reply = "", streamedContent = "";

        const streamingMessageContainer = messagesBox.querySelector(`.message-container[data-index="${placeholderIndex}"]`);
        const streamingMessageDiv = streamingMessageContainer?.querySelector(".message");


        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value);
          const lines = chunk.split("\n").filter(line => line.trim().startsWith("data: "));
          for (const line of lines) {
            if (line.includes("[DONE]")) break;
            const jsonString = line.replace(/^data: /, "");
            try {
              const parsed = JSON.parse(jsonString);
              const content = parsed.choices?.[0]?.delta?.content;
              if (content) {
                streamedContent += content;
                reply = removeThoughts(streamedContent);
                if (streamingMessageDiv) {
                  streamingMessageDiv.innerHTML = `<strong>${apiCharacterName}:</strong>${marked.parse(reply)}`;
                  scrollToBottom(true);
                }
              }
            } catch (e) { /* console.warn("Stream parsing error:", e, jsonString); */ }
          }
        }
        if (!reply && streamedContent) reply = removeThoughts(streamedContent);

        chatArrayToUpdateRef[placeholderIndex].content = reply;
        chatArrayToUpdateRef[placeholderIndex].attachments = null;
        if (currentMode === "group") {
            chatArrayToUpdateRef[placeholderIndex].sender = apiCharacterName;
        }

        if (!streamingMessageDiv) {
            updateMessageInDOM(placeholderIndex, chatArrayToUpdateRef[placeholderIndex]);
        }

        if (currentMode === "personal") saveChat(getCurrentCharacterName(), chatArrayToUpdateRef);
        else saveRoomChat(chatArrayToUpdateRef);


      } catch (err) {
        console.error("fetchChatCompletion Ошибка:", err);
        if (chatArrayToUpdateRef[placeholderIndex] && chatArrayToUpdateRef[placeholderIndex].content === "...") {
            chatArrayToUpdateRef.splice(placeholderIndex, 1);
            removeMessageFromDOM(placeholderIndex);
        }
        const errorMsgData = {sender:"Система", content:`Ошибка LLM: ${err.message}`, role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"};
        chatArrayToUpdateRef.push(errorMsgData);
        appendNewMessageToDOM(errorMsgData, chatArrayToUpdateRef.length - 1);

      } finally {
        setStatusActive(false);
        isBotGenerating = false;
        updateRegenerateButtonsState(false);
        if (shouldScrollToBottom) { scrollToBottom(true); shouldScrollToBottom = false; }
      }
    }


    function removeThoughts(text) { return text.replace(/<think>[\s\S]*?<\/think>/g, '').trim(); }

    function clearMessages() {
      showCustomConfirm("Вы уверены, что хотите очистить текущий чат? Это действие нельзя отменить.", () => {
        let initialMessages = [];
        if (currentMode === "personal") {
          const name = getCurrentCharacterName();
          if (!name) return;
          const charData = characters[name];
          if (charData && charData.welcomeMessage) {
              initialMessages.push({ role: "assistant", content: charData.welcomeMessage, avatar: charData.avatarCharacter, attachments: null });
          }
          saveChat(name, initialMessages);
        } else {
          saveRoomChat(initialMessages);
        }
        shouldScrollToBottom = true;
        loadAndRenderMessages();
        clearVariants();
      });
    }

    function exportCharacterData() {
      const name = getCurrentCharacterName();
      if (!name || !characters[name]) return showCustomAlert("Выберите персонажа для экспорта.");

      const charData = characters[name];
      const chatHistory = loadChat(name);

      const dataToExport = {
        spec: "chara_card_v2",
        spec_version: "2.0",
        data: {
            name: charData.name || "",
            description: charData.description || "",
            personality: charData.personality || "",
            scenario: charData.scenario || "",
            first_mes: charData.welcomeMessage || "",
            mes_example: charData.mes_example || "",
            creator_notes: charData.creator_notes || "",
            system_prompt: charData.system_prompt || "",
            post_history_instructions: charData.post_history_instructions || "",
            alternate_greetings: charData.alternate_greetings || [],
            tags: [], // Tags not implemented in UI yet
            creator: "", // Creator not implemented in UI yet
            character_version: "", // Version not implemented in UI yet
            avatar: "none", // Placeholder, actual avatar is in our app's format
            extensions: {}
        }
      };

      const fullExportData = {
          character: charData,
          messages: chatHistory,
          version: "2.0",
          format: "llm_chatbot_rp_v3_full",
          tavern_card: dataToExport
      };

      const blob = new Blob([JSON.stringify(fullExportData, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = `${name}_персонаж_и_чат.json`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showCustomAlert(`Данные персонажа "${name}" и история чата экспортированы.`);
    }

    function importCharacterData() { document.getElementById("jsonFileInput").click(); }

    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const importedJson = JSON.parse(e.target.result);
          let charDataToProcess;

          // Check for our app's full format first
          if (importedJson.format === "llm_chatbot_rp_v3_full" && importedJson.character) {
              console.log("Importing llm_chatbot_rp_v3_full format");
              charDataToProcess = {
                  character: importedJson.character,
                  messages: importedJson.messages || [],
              };
          }
          // Then check for standard TavernAI/Chub format
          else if (importedJson.spec === "chara_card_v2" && importedJson.data) {
            console.log("Importing chara_card_v2 format");
            const tavernData = importedJson.data;
            charDataToProcess = {
              character: {
                name: tavernData.name || "Безымянный",
                description: tavernData.description || "",
                personality: tavernData.personality || "",
                scenario: tavernData.scenario || "",
                mes_example: tavernData.mes_example || "",
                welcomeMessage: tavernData.first_mes || "",
                alternate_greetings: tavernData.alternate_greetings || [],
                system_prompt: tavernData.system_prompt || "",
                post_history_instructions: tavernData.post_history_instructions || "",
                creator_notes: tavernData.creator_notes || "",
                avatarCharacter: tavernData.avatar || "https://placehold.co/100x100/FF7AAC/FFFFFF?text=Бот", // Use TavernAI avatar or default
                avatarUser: document.getElementById("avatarUrl_user").value || "https://placehold.co/100x100/7AC5FF/FFFFFF?text=Вы",
                model: document.getElementById("characterModel").value || document.getElementById("model").value,
                lorebook: [],
              },
              messages: [],
              _tavernData: tavernData // Keep original data for reference
            };

            if (tavernData.character_book && tavernData.character_book.entries) {
                charDataToProcess.character.lorebook = tavernData.character_book.entries.map(entry => ({
                    entryName: entry.name || "",
                    triggers: entry.keys || [],
                    info: entry.content || ""
                })).filter(lbEntry => (lbEntry.triggers.length > 0 && lbEntry.info) || lbEntry.entryName);
            }
          } else {
            throw new Error("Неподдерживаемый или неверный формат файла JSON.");
          }

          tempImportedCharacterData = charDataToProcess;

          if (charDataToProcess._tavernData) {
            const greetings = [];
            if (charDataToProcess._tavernData.first_mes) greetings.push(charDataToProcess._tavernData.first_mes);
            if (charDataToProcess._tavernData.alternate_greetings && charDataToProcess._tavernData.alternate_greetings.length > 0) {
                greetings.push(...charDataToProcess._tavernData.alternate_greetings);
            }

            if (greetings.length > 1) {
                openGreetingModal(charDataToProcess.character.name, greetings); return;
            } else if (greetings.length === 1) {
                charDataToProcess.character.welcomeMessage = greetings[0];
            }
          }
          finalizeImport(charDataToProcess);

        } catch (err) {
          showCustomAlert(`Ошибка импорта файла: ${err.message}`); console.error("Ошибка импорта:", err);
          tempImportedCharacterData = null;
        } finally {
            event.target.value = null;
        }
      };
      reader.readAsText(file);
    }

    function finalizeImport(dataToImport) {
        if (!dataToImport || !dataToImport.character) {
            console.error("Данные для импорта неполные.");
            showCustomAlert("Ошибка: не удалось завершить импорт, данные неполные.");
            return;
        }
        const charData = dataToImport.character;
        const charName = charData.name;

        // Ensure all fields exist on the object to prevent errors
        const fullCharData = {
          name: charName,
          description: charData.description || "",
          personality: charData.personality || "",
          scenario: charData.scenario || "",
          mes_example: charData.mes_example || "",
          welcomeMessage: charData.welcomeMessage || "",
          alternate_greetings: charData.alternate_greetings || [],
          system_prompt: charData.system_prompt || "",
          post_history_instructions: charData.post_history_instructions || "",
          creator_notes: charData.creator_notes || "",
          model: charData.model || document.getElementById("model").value,
          avatarCharacter: charData.avatarCharacter || "https://placehold.co/100x100/FF7AAC/FFFFFF?text=Бот",
          avatarUser: charData.avatarUser || document.getElementById("avatarUrl_user").value || "https://placehold.co/100x100/7AC5FF/FFFFFF?text=Вы",
          lorebook: charData.lorebook || [],
          backgroundImage: charData.backgroundImage || null
        };

        characters[charName] = fullCharData;
        saveChat(charName, dataToImport.messages || []);
        localStorage.setItem("characters_v3", JSON.stringify(characters));

        populateCharacterSelect();
        setActiveCharacter(charName);
        document.getElementById("characterSelect").value = charName;

        showCustomAlert(`Персонаж "${charName}" успешно импортирован!`);
        closeSettingsModal();
        tempImportedCharacterData = null;
    }


    function setupFileAttach() {
        const hiddenFileInput = document.getElementById("fileInput");
        if(hiddenFileInput) {
            hiddenFileInput.addEventListener("change", (event) => {
                if (event.target.files.length > 0) {
                    Array.from(event.target.files).forEach(file => attachedFiles.push(file));
                    renderFilePreviews();
                    userInput.placeholder = `${attachedFiles.length} файл(ов) прикреплено. Введите текст или отправьте.`;
                }
                event.target.value = null;
            });
        }
    }

    function renderFilePreviews() {
        filePreviewsContainer.innerHTML = "";
        if (attachedFiles.length === 0) {
            filePreviewsContainer.style.display = "none";
            if (!userInput.value.trim()) {
                 userInput.placeholder = "Введите сообщение...";
            }
            return;
        }
        filePreviewsContainer.style.display = "flex";

        attachedFiles.forEach((file, index) => {
            const previewItem = document.createElement('div');
            previewItem.className = 'file-preview-item';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-file-btn';
            removeBtn.innerHTML = '&times;';
            removeBtn.title = 'Удалить файл';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                attachedFiles.splice(index, 1);
                renderFilePreviews();
                 if (attachedFiles.length > 0) {
                    userInput.placeholder = `${attachedFiles.length} файл(ов) прикреплено. Введите текст или отправьте.`;
                } else if (!userInput.value.trim()) {
                     userInput.placeholder = "Введите сообщение...";
                }
            };
            previewItem.appendChild(removeBtn);

            if (file.type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = URL.createObjectURL(file);
                img.onload = () => URL.revokeObjectURL(img.src);
                previewItem.appendChild(img);
            } else {
                const icon = document.createElement('div');
                icon.className = 'file-icon-placeholder';
                icon.textContent = '📄';
                previewItem.appendChild(icon);
            }
            const fileName = document.createElement('div');
            fileName.className = 'file-info';
            fileName.textContent = file.name;
            fileName.title = file.name;
            previewItem.appendChild(fileName);

            filePreviewsContainer.appendChild(previewItem);
        });
    }


    function readFileAsDataURL(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }


    function renderLorebookEntries(characterName) {
      const container = document.getElementById("lorebookEntries");
      container.innerHTML = "";
      const character = characters[characterName];
      if (!character || !character.lorebook || character.lorebook.length === 0) {
        container.innerHTML = "<p style='font-style:italic; opacity:0.7;'>Записей нет.</p>"; return;
      }
      character.lorebook.forEach((entry, index) => {
        const entryDiv = document.createElement("div");
        entryDiv.className = "lorebook-entry";
        entryDiv.innerHTML = `
          <div>
            <label for="lore-entryName-${index}">Название записи (Имя):</label>
            <input type="text" id="lore-entryName-${index}" value="${entry.entryName || ""}" data-index="${index}" oninput="updateLorebookField(${index}, 'entryName', this.value)" />
          </div>
          <div>
            <label for="lore-triggers-${index}">Ключевые слова (через запятую):</label>
            <input type="text" id="lore-triggers-${index}" value="${(entry.triggers || []).join(', ')}" data-index="${index}" oninput="updateLorebookField(${index}, 'triggers', this.value)" />
          </div>
          <div>
            <label for="lore-info-${index}">Информация:</label>
            <textarea id="lore-info-${index}" data-index="${index}" oninput="updateLorebookField(${index}, 'info', this.value)">${entry.info || ""}</textarea>
          </div>
          <button type="button" onclick="deleteLorebookEntry(${index})" style="background: #ffcdd2; color:#5f2120; font-size:0.9rem; padding: 0.5rem 0.8rem;">Удалить запись</button>
        `;
        container.appendChild(entryDiv);
      });
    }

    function updateLorebookField(index, field, value) {
        const charName = getCurrentCharacterName();
        if (!charName || !characters[charName] || !characters[charName].lorebook[index]) return;

        if (field === 'entryName') {
            characters[charName].lorebook[index].entryName = value.trim();
        } else if (field === 'triggers') {
            characters[charName].lorebook[index].triggers = value.split(',').map(t => t.trim()).filter(t => t);
        } else if (field === 'info') {
            characters[charName].lorebook[index].info = value.trim();
        }
        localStorage.setItem("characters_v2", JSON.stringify(characters));
    }

    function addLorebookEntry() {
      const charName = getCurrentCharacterName();
      if (!charName || !characters[charName]) return showCustomAlert("Сначала выберите персонажа.");
      characters[charName].lorebook = characters[charName].lorebook || [];
      characters[charName].lorebook.push({ entryName: "", triggers: [], info: "" }); // Add new empty entry with entryName
      localStorage.setItem("characters_v2", JSON.stringify(characters));
      renderLorebookEntries(charName);
    }

    function deleteLorebookEntry(index) {
      const charName = getCurrentCharacterName();
      if (!charName || !characters[charName] || !characters[charName].lorebook) return;
      showCustomConfirm("Удалить эту запись из Lorebook?", () => {
        characters[charName].lorebook.splice(index, 1);
        localStorage.setItem("characters_v2", JSON.stringify(characters));
        renderLorebookEntries(charName);
      });
    }

    function uploadBackground() {
      const name = getCurrentCharacterName(); // Get current character
      if (!name || !characters[name]) return showCustomAlert("Персонаж не найден.");
      const fileInput = document.getElementById("backgroundFileInput");
      const file = fileInput.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          characters[name].backgroundImage = e.target.result; // Store as dataURL
          localStorage.setItem("characters_v2", JSON.stringify(characters)); // Save
          applyBackground(name); // Apply immediately
          closeBackgroundModal(); // Close modal
        };
        reader.readAsDataURL(file);
      } else {
        showCustomAlert("Пожалуйста, выберите файл изображения.");
      }
      fileInput.value = ""; // Reset file input
    }
    function deleteBackground() {
      const name = getCurrentCharacterName();
      if (!name || !characters[name]) return showCustomAlert("Персонаж не найден.");
      delete characters[name].backgroundImage; // Remove property
      localStorage.setItem("characters_v2", JSON.stringify(characters)); // Save
      applyBackground(name); // Re-apply (will remove background)
      closeBackgroundModal();
    }

    function applyBackground(characterName) {
      const messagesDiv = document.querySelector('.messages');
      const chatContainerDiv = document.getElementById('chatContainer');
      const inputAreaContainer = document.querySelector('.input-area-container');

      if (!messagesDiv || !chatContainerDiv || !inputAreaContainer) return;

      const character = characterName ? characters[characterName] : null;
      const backgroundImage = character?.backgroundImage;

      if (backgroundImage && currentMode === "personal") {
        chatContainerDiv.style.backgroundImage = `url(${backgroundImage})`;
        chatContainerDiv.style.backgroundSize = 'cover';
        chatContainerDiv.style.backgroundPosition = 'center';
        chatContainerDiv.style.backgroundRepeat = 'no-repeat';
        chatContainerDiv.classList.add('chat-container-custom-bg'); // Add class to adjust padding

        messagesDiv.classList.add('has-custom-background');
        inputAreaContainer.classList.add('has-custom-background-too');
      } else {
        chatContainerDiv.style.backgroundImage = 'none';
        chatContainerDiv.classList.remove('chat-container-custom-bg'); // Remove class to revert padding

        messagesDiv.classList.remove('has-custom-background');
        inputAreaContainer.classList.remove('has-custom-background-too');
      }
    }


    function setupAvatarClickHandler() {
      document.addEventListener('click', function(e) {
        const targetElement = e.target;
        // Check if clicked on an avatar in a message, or an attached image in a message, or an image in file preview
        if (targetElement.classList.contains('avatar')) {
          const avatarSrc = targetElement.src;
          previewImage(avatarSrc);
        }
        else if (targetElement.classList.contains('attached-image')) { // Image inside a message bubble
          const imageSrc = targetElement.src;
          previewImage(imageSrc);
        }
        else if (targetElement.tagName === 'IMG' && targetElement.closest('.file-preview-item')) { // Image in the file preview area before sending
             const imageSrc = targetElement.src;
             previewImage(imageSrc);
        }
      });
    }

    function previewImage(src) {
        // Remove existing modal if any
        const existingModal = document.querySelector('.avatar-preview-modal');
        if (existingModal) document.body.removeChild(existingModal);

        const modal = document.createElement('div');
        modal.className = 'avatar-preview-modal';
        // Basic styling for the modal (overlay)
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.background = 'rgba(0,0,0,0.8)'; // Dark overlay
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.style.zIndex = '2000'; // High z-index to be on top
        modal.style.cursor = 'zoom-out'; // Indicate it can be closed by clicking
        // Image styling within the modal
        modal.innerHTML = `
            <img src="${src}" style="max-width:90vw; max-height:90vh; object-fit:contain; border-radius: 8px; box-shadow: 0 5px 25px rgba(0,0,0,0.5);" />
        `;
        // Close modal on click
        modal.addEventListener('click', () => document.body.removeChild(modal));
        document.body.appendChild(modal);
    }


    function setupScrollHandler() {
      messagesBox.addEventListener("scroll", () => {
        // If user scrolls up, disable auto-scroll to bottom
        const nearBottom = messagesBox.scrollTop + messagesBox.clientHeight >= messagesBox.scrollHeight - 100;
        if (!nearBottom) {
            shouldScrollToBottom = false; // User has scrolled away from the bottom
        }
        // Auto-scroll is re-enabled when a new message is sent or bot responds (by setting shouldScrollToBottom = true)
      });
    }

    function showCustomAlert(message) {
        const messageBox = document.createElement('div');
        messageBox.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--accent-color);
            color: white;
            padding: 15px 25px;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 15px rgba(var(--accent-color-rgb), 0.3);
            z-index: 3000;
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            text-align: center;
        `;
        messageBox.textContent = message;
        document.body.appendChild(messageBox);
        setTimeout(() => {
            messageBox.style.opacity = 1;
        }, 10); // Small delay to trigger transition
        setTimeout(() => {
            messageBox.style.opacity = 0;
            messageBox.addEventListener('transitionend', () => messageBox.remove());
        }, 2000); // Disappear after 2 seconds
    }

    
function showCustomConfirm(message, onConfirm) {
        // Prevent multiple confirm boxes stacking
        if (document.querySelector('.custom-confirm-overlay')) {
            // If one exists, optionally bring it to front (do nothing)
            return;
        }
        // Create an overlay to host the confirm box (so IDs inside won't clash)
        const overlay = document.createElement('div');
        overlay.className = 'custom-confirm-overlay';
        overlay.style.cssText = `
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2999;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        // Create confirm box inside overlay
        const confirmBox = document.createElement('div');
        confirmBox.className = 'custom-confirm-box';
        confirmBox.style.cssText = `
            background-color: var(--card-bg);
            color: var(--text-color);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            z-index: 3000;
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            max-width: 95%;
            box-sizing: border-box;
        `;
        confirmBox.innerHTML = `
            <div style="margin-bottom:12px; white-space:pre-wrap;">${message}</div>
            <div style="display:flex; gap:0.6rem; justify-content:flex-end;">
                <button type="button" data-confirm="no" style="padding:0.6rem 0.9rem; border-radius:8px; background:transparent; border:1px solid rgba(var(--accent-color-rgb),0.12); color:var(--text-color);">Отмена</button>
                <button type="button" data-confirm="yes" style="padding:0.6rem 0.9rem; border-radius:8px; background:var(--accent-gradient); color:#fff; border: none;">Да</button>
            </div>
        `;
        overlay.appendChild(confirmBox);
        document.body.appendChild(overlay);

        // Prevent clicks from propagating to underlying UI
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                // clicking outside will close the dialog
                overlay.remove();
            }
        });

        // Buttons
        const btnYes = confirmBox.querySelector('[data-confirm="yes"]');
        const btnNo = confirmBox.querySelector('[data-confirm="no"]');

        // Helper to cleanup
        const cleanup = () => {
            try { overlay.remove(); } catch (e) {}
        };

        btnYes.addEventListener('click', (e) => {
            e.stopPropagation();
            // Disable to prevent double clicks
            btnYes.disabled = true;
            if (typeof onConfirm === 'function') {
                try { onConfirm(); } catch (err) { console.error(err); }
            }
            cleanup();
        });

        btnNo.addEventListener('click', (e) => {
            e.stopPropagation();
            cleanup();
        });

        // Accessibility: focus yes button
        btnYes.focus();
    }



    function setStatusActive(active) {
      const currentStatusIndicator = document.getElementById("messages-status-indicator");
      // The mobile prefix container and its cloned indicator might not always exist if the DOM structure changes.
      // It's safer to query for it within the mobile prefix div if it's consistently there.
      const mobilePrefixDiv = mainInputRow.querySelector('.mobile-input-prefix');
      const clonedStatusIndicator = mobilePrefixDiv ? mobilePrefixDiv.querySelector('#messages-status-indicator') : null;


      if (currentStatusIndicator) {
        currentStatusIndicator.classList.toggle("active", active);
        currentStatusIndicator.title = active ? "Нейросеть активна..." : "Нейросеть неактивна";
      }
      if (clonedStatusIndicator) { // Also update the cloned indicator if it exists (for mobile view)
        clonedStatusIndicator.classList.toggle("active", active);
        clonedStatusIndicator.title = active ? "Нейросеть активна..." : "Нейросеть неактивна";
      }
    }

  </script>
<script>
// Original (PC) settings content (from original file)
if (typeof window.originalSettingsHTML === 'undefined') {
  window.originalSettingsHTML = `
<fieldset class="fieldset-span-1"> <legend>🔌 Настройки API LLM (По умолчанию)</legend>
<label for="apiKey">Ключ API (LLM):</label>
<input aria-label="Ключ API LLM" autocomplete="off" id="apiKey" placeholder="Введите ваш API ключ" type="password"/>
<label for="apiUrl">URL API LLM:</label>
<input aria-label="URL LLM API" id="apiUrl" type="text" value="https://openrouter.ai/api/v1/chat/completions"/>
<label for="model">Модель LLM (по умолчанию):</label>
<input aria-label="Модель LLM" id="model" readonly="" type="text" value="deepseek/deepseek-r1-0528:free"/>
<label for="temperature">Температура (0-1):</label>
<input aria-label="Температура LLM" id="temperature" placeholder="Например, 0.7" step="0.1" type="number" value="0.7"/>
<label for="maxTokens">Максимум токенов:</label>
<input aria-label="Максимум токенов LLM" id="maxTokens" placeholder="Например, 1024" type="number" value="1024"/>
</fieldset>
<fieldset class="fieldset-span-1">
<legend>🇬 Настройки Google Gemini API</legend>
<label for="googleApiKey">Ключ Google API:</label>
<input aria-label="Ключ Google API" autocomplete="off" id="googleApiKey" placeholder="Введите ваш Google API ключ" type="password"/>
<label for="googleApiModel">Модель Google Gemini:</label>
<select aria-label="Модель Google Gemini" id="googleApiModel"></select>
<div style="display: flex; align-items: center; margin-top: 0.5rem; gap: 10px;">
<label for="enableGoogleApi" style="font-weight: 500; margin-bottom: 0;">Использовать Google Gemini API:</label>
<label class="switch">
<input aria-label="Включить Google Gemini API" id="enableGoogleApi" type="checkbox"/>
<span class="slider round"></span>
</label>
</div>
</fieldset>
<fieldset>
<legend>🔗 Настройки REST API</legend>
<label for="restApiUrl">URL REST API:</label>
<input aria-label="URL REST API" id="restApiUrl" placeholder="URL конечной точки REST API" type="text"/>
<label for="restApiHeaders">Заголовки REST API (JSON):</label>
<textarea aria-label="Заголовки REST API (JSON)" id="restApiHeaders" placeholder='Пример: {"Authorization": "Bearer ВАШ_ТОКЕН"}'></textarea>
<div style="display: flex; align-items: center; margin-top: 0.5rem; gap: 10px;">
<label for="enableRestApi" style="font-weight: 500; margin-bottom: 0;">Использовать REST API:</label>
<label class="switch">
<input aria-label="Включить REST API" id="enableRestApi" type="checkbox">
<span class="slider round"></span>
</input></label>
</div>
</fieldset>
<fieldset>
<legend>👤 Основные настройки Персонажа</legend>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
<div>
<label for="characterSelect">Выбрать персонажа:</label>
<select aria-label="Выбор персонажа" disabled="" id="characterSelect"></select>
</div>
<div>
<label for="characterName">Имя персонажа:</label>
<input aria-label="Имя персонажа" id="characterName" placeholder="Введите имя персонажа" type="text"/>
</div>
</div>
<label for="characterModel">Модель для персонажа (если отличается):</label>
<input aria-label="Модель персонажа" id="characterModel" placeholder="Например, gpt-4-turbo или модель Gemini" type="text"/>
</fieldset>
<fieldset>
<legend>📝 Описание и личность</legend>
<label for="description">Описание (внешность, роль, цели):</label>
<textarea aria-label="Описание персонажа" id="description" placeholder="Описание роли, характера, предыстории..." style="min-height: 140px;"></textarea>
<label for="personality">Личность (черты характера):</label>
<textarea aria-label="Личность персонажа" id="personality" placeholder="Личность, манера речи, поведение..."></textarea>
</fieldset>
<fieldset>
<legend>📖 Сценарий и примеры диалога</legend>
<label for="scenario">Сценарий (мир, окружение):</label>
<textarea aria-label="Сценарий" id="scenario" placeholder="Описание мира, ситуации, сеттинга..."></textarea>
<label for="mes_example">Пример диалога:</label>
<textarea aria-label="Пример диалога" id="mes_example" placeholder="&lt;START&gt;\\nПример диалога для демонстрации стиля..." style="min-height: 140px;"></textarea>
</fieldset>
<fieldset>
<legend>👋 Приветствия</legend>
<label for="welcomeMessage">Основное приветствие:</label>
<textarea aria-label="Основное приветственное сообщение" id="welcomeMessage" placeholder="Сообщение от бота при начале чата"></textarea>
<!-- REMOVED: Alternative Greetings Input Field -->
</fieldset>
<fieldset>
<legend>⚙️ Дополнительные инструкции для ИИ</legend>
<label for="system_prompt">Системный промпт:</label>
<textarea aria-label="Системный промпт" id="system_prompt" placeholder="Глобальные инструкции для ИИ (system prompt)"></textarea>
<label for="post_history_instructions">Инструкции после истории:</label>
<textarea aria-label="Инструкции после истории" id="post_history_instructions" placeholder="Инструкции, которые вставляются после истории чата"></textarea>
<label for="creator_notes">Заметки создателя:</label>
<textarea aria-label="Заметки создателя" id="creator_notes" placeholder="Заметки от создателя персонажа"></textarea>
</fieldset>
<fieldset class="fieldset-span-1">
<legend>🎨 Настройки оформления</legend>
<div>
<label for="mainTextColor">Основной цвет текста:</label>
<input aria-label="Основной цвет текста" id="mainTextColor" type="color"/>
</div>
<div style="margin-top: 1rem;">
<label for="chatFontSize">Размер текста в чате: <span id="chatFontSizeIndicator">100%</span></label>
<input aria-label="Размер текста в чате" id="chatFontSize" max="1.5" min="0.8" step="0.05" type="range" value="1"/>
</div>
</fieldset>
<fieldset class="fieldset-span-1">
<legend>🖼️ Аватары</legend>
<div class="avatar-selection">
<button onclick="showAvatarOptions('link', 'character')" type="button">Аватар Персонажа: Ссылка</button>
<button onclick="showAvatarOptions('file', 'character')" type="button">Аватар Персонажа: Файл</button>
</div>
<div id="avatarLinkInput_character" style="display:none; margin-top: 0.5rem;">
<input aria-label="Ссылка на аватар персонажа" id="avatarUrl_character" placeholder="URL аватара персонажа" type="text"/>
</div>
<div id="avatarFileInputWrapper_character" style="display:none; margin-top: 0.5rem;">
<input accept="image/*" aria-label="Выбор файла аватара персонажа" id="avatarFileInput_character" type="file"/>
</div>
<div class="avatar-selection" style="margin-top: 1rem;">
<button onclick="showAvatarOptions('link', 'user')" type="button">Ваш Аватар: Ссылка</button>
<button onclick="showAvatarOptions('file', 'user')" type="button">Ваш Аватар: Файл</button>
</div>
<div id="avatarLinkInput_user" style="display:none; margin-top: 0.5rem;">
<input aria-label="Ссылка на ваш аватар" id="avatarUrl_user" placeholder="URL вашего аватара" type="text"/>
</div>
<div id="avatarFileInputWrapper_user" style="display:none; margin-top: 0.5rem;">
<input accept="image/*" aria-label="Выбор файла вашего аватара" id="avatarFileInput_user" type="file"/>
</div>
</fieldset>
<fieldset>
<legend>🧠 Память ИИ (Общая)</legend>
<textarea aria-label="Память нейросети" class="memory-box" id="neuralMemory" placeholder="Заметки и контекст, которые бот будет помнить глобально..." spellcheck="true"></textarea>
</fieldset>
<div style="grid-column: span 2; display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; margin-top:1rem;">
<button onclick="saveSettings()" type="button">💾 Сохранить/Обновить</button>
<button onclick="clearMessages()" style="background: #ffcdd2; color:#5f2120;" type="button">🗑️ Очистить чат</button>
<button onclick="exportCharacterData()" type="button">📤 Экспорт JSON</button>
<button onclick="importCharacterData()" type="button">📥 Импорт JSON</button>
<input accept=".json, .card" id="jsonFileInput" onchange="handleFileUpload(event)" style="display:none" type="file"/>
<button onclick="openLorebookModal()" type="button">📚 Lorebook</button>
<button onclick="openBackgroundModal()" type="button">🖼️ Фон чата</button>
</div>
`;
}

// Mobile (tabbed) settings content (from modified file)
const mobileSettingsHTML = `<div class="tab-buttons"><button class="active" onclick="openSettingsTab(1)" type="button">🔌 Настройки API LLM (По умолчанию)</button><button onclick="openSettingsTab(2)" type="button">🇬 Настройки Google Gemini API</button><button onclick="openSettingsTab(3)" type="button">🔗 Настройки REST API</button><button onclick="openSettingsTab(4)" type="button">👤 Основные настройки Персонажа</button><button onclick="openSettingsTab(5)" type="button">📝 Описание и личность</button><button onclick="openSettingsTab(6)" type="button">📖 Сценарий и примеры диалога</button><button onclick="openSettingsTab(7)" type="button">👋 Приветствия</button><button onclick="openSettingsTab(8)" type="button">⚙️ Дополнительные инструкции для ИИ</button><button onclick="openSettingsTab(9)" type="button">🎨 Настройки оформления</button><button onclick="openSettingsTab(10)" type="button">🖼️ Аватары</button><button onclick="openSettingsTab(11)" type="button">🧠 Память ИИ (Общая)</button></div><div class="tab-page active" id="settingsTab1"><fieldset class="fieldset-span-1"> <legend>🔌 Настройки API LLM (По умолчанию)</legend>
<label for="apiKey">Ключ API (LLM):</label>
<input aria-label="Ключ API LLM" autocomplete="off" id="apiKey" placeholder="Введите ваш API ключ" type="password"/>
<label for="apiUrl">URL API LLM:</label>
<input aria-label="URL LLM API" id="apiUrl" type="text" value="https://openrouter.ai/api/v1/chat/completions"/>
<label for="model">Модель LLM (по умолчанию):</label>
<input aria-label="Модель LLM" id="model" readonly="" type="text" value="deepseek/deepseek-r1-0528:free"/>
<label for="temperature">Температура (0-1):</label>
<input aria-label="Температура LLM" id="temperature" placeholder="Например, 0.7" step="0.1" type="number" value="0.7"/>
<label for="maxTokens">Максимум токенов:</label>
<input aria-label="Максимум токенов LLM" id="maxTokens" placeholder="Например, 1024" type="number" value="1024"/>
</fieldset></div><div class="tab-page" id="settingsTab2"><fieldset class="fieldset-span-1">
<legend>🇬 Настройки Google Gemini API</legend>
<label for="googleApiKey">Ключ Google API:</label>
<input aria-label="Ключ Google API" autocomplete="off" id="googleApiKey" placeholder="Введите ваш Google API ключ" type="password"/>
<label for="googleApiModel">Модель Google Gemini:</label>
<select aria-label="Модель Google Gemini" id="googleApiModel"></select>
<div style="display: flex; align-items: center; margin-top: 0.5rem; gap: 10px;">
<label for="enableGoogleApi" style="font-weight: 500; margin-bottom: 0;">Использовать Google Gemini API:</label>
<label class="switch">
<input aria-label="Включить Google Gemini API" id="enableGoogleApi" type="checkbox"/>
<span class="slider round"></span>
</label>
</div>
</fieldset></div><div class="tab-page" id="settingsTab3"><fieldset>
<legend>🔗 Настройки REST API</legend>
<label for="restApiUrl">URL REST API:</label>
<input aria-label="URL REST API" id="restApiUrl" placeholder="URL конечной точки REST API" type="text"/>
<label for="restApiHeaders">Заголовки REST API (JSON):</label>
<textarea aria-label="Заголовки REST API (JSON)" id="restApiHeaders" placeholder='Пример: {"Authorization": "Bearer ВАШ_ТОКЕН"}'></textarea>
<div style="display: flex; align-items: center; margin-top: 0.5rem; gap: 10px;">
<label for="enableRestApi" style="font-weight: 500; margin-bottom: 0;">Использовать REST API:</label>
<label class="switch">
<input aria-label="Включить REST API" id="enableRestApi" type="checkbox"/>
<span class="slider round"></span>
</label>
</div>
</fieldset></div><div class="tab-page" id="settingsTab4"><fieldset>
<legend>👤 Основные настройки Персонажа</legend>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
<div>
<label for="characterSelect">Выбрать персонажа:</label>
<select aria-label="Выбор персонажа" disabled="" id="characterSelect"></select>
</div>
<div>
<label for="characterName">Имя персонажа:</label>
<input aria-label="Имя персонажа" id="characterName" placeholder="Введите имя персонажа" type="text"/>
</div>
</div>
<label for="characterModel">Модель для персонажа (если отличается):</label>
<input aria-label="Модель персонажа" id="characterModel" placeholder="Например, gpt-4-turbo или модель Gemini" type="text"/>
</fieldset></div><div class="tab-page" id="settingsTab5"><fieldset>
<legend>📝 Описание и личность</legend>
<label for="description">Описание (внешность, роль, цели):</label>
<textarea aria-label="Описание персонажа" id="description" placeholder="Описание роли, характера, предыстории..." style="min-height: 140px;"></textarea>
<label for="personality">Личность (черты характера):</label>
<textarea aria-label="Личность персонажа" id="personality" placeholder="Личность, манера речи, поведение..."></textarea>
</fieldset></div><div class="tab-page" id="settingsTab6"><fieldset>
<legend>📖 Сценарий и примеры диалога</legend>
<label for="scenario">Сценарий (мир, окружение):</label>
<textarea aria-label="Сценарий" id="scenario" placeholder="Описание мира, ситуации, сеттинга..."></textarea>
<label for="mes_example">Пример диалога:</label>
<textarea aria-label="Пример диалога" id="mes_example" placeholder="&lt;START&gt;\\nПример диалога для демонстрации стиля..." style="min-height: 140px;"></textarea>
</fieldset></div><div class="tab-page" id="settingsTab7"><fieldset>
<legend>👋 Приветствия</legend>
<label for="welcomeMessage">Основное приветствие:</label>
<textarea aria-label="Основное приветственное сообщение" id="welcomeMessage" placeholder="Сообщение от бота при начале чата"></textarea>
<!-- REMOVED: Alternative Greetings Input Field -->
</fieldset></div><div class="tab-page" id="settingsTab8"><fieldset>
<legend>⚙️ Дополнительные инструкции для ИИ</legend>
<label for="system_prompt">Системный промпт:</label>
<textarea aria-label="Системный промпт" id="system_prompt" placeholder="Глобальные инструкции для ИИ (system prompt)"></textarea>
<label for="post_history_instructions">Инструкции после истории:</label>
<textarea aria-label="Инструкции после истории" id="post_history_instructions" placeholder="Инструкции, которые вставляются после истории чата"></textarea>
<label for="creator_notes">Заметки создателя:</label>
<textarea aria-label="Заметки создателя" id="creator_notes" placeholder="Заметки от создателя персонажа"></textarea>
</fieldset></div><div class="tab-page" id="settingsTab9"><fieldset class="fieldset-span-1">
<legend>🎨 Настройки оформления</legend>
<div>
<label for="mainTextColor">Основной цвет текста:</label>
<input aria-label="Основной цвет текста" id="mainTextColor" type="color"/>
</div>
<div style="margin-top: 1rem;">
<label for="chatFontSize">Размер текста в чате: <span id="chatFontSizeIndicator">100%</span></label>
<input aria-label="Размер текста в чате" id="chatFontSize" max="1.5" min="0.8" step="0.05" type="range" value="1"/>
</div>
</fieldset></div><div class="tab-page" id="settingsTab10"><fieldset class="fieldset-span-1">
<legend>🖼️ Аватары</legend>
<div class="avatar-selection">
<button onclick="showAvatarOptions('link', 'character')" type="button">Аватар Персонажа: Ссылка</button>
<button onclick="showAvatarOptions('file', 'character')" type="button">Аватар Персонажа: Файл</button>
</div>
<div id="avatarLinkInput_character" style="display:none; margin-top: 0.5rem;">
<input aria-label="Ссылка на аватар персонажа" id="avatarUrl_character" placeholder="URL аватара персонажа" type="text"/>
</div>
<div id="avatarFileInputWrapper_character" style="display:none; margin-top: 0.5rem;">
<input accept="image/*" aria-label="Выбор файла аватара персонажа" id="avatarFileInput_character" type="file"/>
</div>
<div class="avatar-selection" style="margin-top: 1rem;">
<button onclick="showAvatarOptions('link', 'user')" type="button">Ваш Аватар: Ссылка</button>
<button onclick="showAvatarOptions('file', 'user')" type="button">Ваш Аватар: Файл</button>
</div>
<div id="avatarLinkInput_user" style="display:none; margin-top: 0.5rem;">
<input aria-label="Ссылка на ваш аватар" id="avatarUrl_user" placeholder="URL вашего аватара" type="text"/>
</div>
<div id="avatarFileInputWrapper_user" style="display:none; margin-top: 0.5rem;">
<input accept="image/*" aria-label="Выбор файла вашего аватара" id="avatarFileInput_user" type="file"/>
</div>
</fieldset></div><div class="tab-page" id="settingsTab11"><fieldset>
<legend>🧠 Память ИИ (Общая)</legend>
<textarea aria-label="Память нейросети" class="memory-box" id="neuralMemory" placeholder="Заметки и контекст, которые бот будет помнить глобально..." spellcheck="true"></textarea>
</fieldset></div>`;

let _settingsLayoutIsMobile = null;
function applySettingsLayout() {
  const container = document.getElementById('settingsSection');
  if (!container) return;
  const nowIsMobile = window.innerWidth <= 900;

  // If layout mode didn't change (only height changed - e.g. keyboard), skip.
  if (_settingsLayoutIsMobile === nowIsMobile) return;

  // If user is actively editing inside settings, avoid swapping layout mid-edit.
  try {
    const active = document.activeElement;
    if (container.contains(active) && (['INPUT','TEXTAREA','SELECT'].includes(active.tagName) || active.isContentEditable)) {
      return;
    }
  } catch (e) { /* ignore */ }

  // Preserve values of inputs by id before replacing innerHTML.
  const fields = Array.from(container.querySelectorAll('input,textarea,select'));
  const saved = {};
  fields.forEach(f => {
    if (!f.id) return;
    saved[f.id] = { value: f.value, checked: f.checked, selectedIndex: f.selectedIndex };
  });

  if (!nowIsMobile) {
    if (container.innerHTML.trim() !== originalSettingsHTML.trim()) {
      container.innerHTML = originalSettingsHTML;
    }
  } else {
    if (container.innerHTML.trim() !== mobileSettingsHTML.trim()) {
      container.innerHTML = mobileSettingsHTML;
    }
  }

  // Re-init bindings and mobile tabs if available
  if (typeof initMobileTabs === 'function') initMobileTabs();
  if (typeof initSettingsBindings === 'function') initSettingsBindings();

  // Try to restore saved values
  Object.keys(saved).forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    try {
      if (el.tagName === 'SELECT') el.selectedIndex = saved[id].selectedIndex;
      else if (el.type === 'checkbox' || el.type === 'radio') el.checked = saved[id].checked;
      else el.value = saved[id].value;
    } catch (e) {}
  });

  // Ensure model select lists and character select are repopulated
  if (typeof populateGoogleApiModelSelect === 'function') populateGoogleApiModelSelect();
  if (typeof populateCharacterSelect === 'function') populateCharacterSelect();
  // loadSettings will refresh values from localStorage if available
  if (typeof loadSettings === 'function') loadSettings();

  _settingsLayoutIsMobile = nowIsMobile;
}

// Run once on DOM ready, and on resize (debounced). Avoid swapping on small height changes.
window.addEventListener('DOMContentLoaded', function(){ applySettingsLayout(); });
window.addEventListener('resize', function(){
  clearTimeout(window._settingsResizeTimeout);
  window._settingsResizeTimeout = setTimeout(applySettingsLayout, 150);
});
</script>
<script>
function openSettingsTab(tabIndex) {
  const pages = document.querySelectorAll('.settings-content .tab-page');
  const buttons = document.querySelectorAll('.settings-content .tab-buttons button');
  pages.forEach((p, idx) => {
    p.classList.toggle('active', idx === tabIndex - 1);
  });
  buttons.forEach((b, idx) => {
    b.classList.toggle('active', idx === tabIndex - 1);
  });
  // scroll to top of modal to show content
  const modal = document.getElementById('settingsModal');
  if (modal) modal.scrollTop = 0;
}
</script>
<input accept=".json, .card" id="jsonFileInput" onchange="if(typeof handleFileUpload === 'function'){handleFileUpload(event);} else if(typeof importCharacterData === 'function'){importCharacterData(event)}" style="display:none" type="file"/>
<script>
// Ensure clearChat exists and works for both personal and group modes
function clearChat() {
  try {
    // Prefer using existing globals if present
    const mode = typeof currentMode !== 'undefined' ? currentMode : (document.getElementById('groupParticipants') ? 'group' : 'personal');
    if (mode === 'personal') {
      const name = typeof getCurrentCharacterName === 'function' ? getCurrentCharacterName() : (window.activeCharacter || null);
      if (!name) {
        if (typeof showCustomAlert === 'function') showCustomAlert('Персонаж не выбран.');
        return;
      }
      if (typeof getChatKey === 'function') {
        localStorage.setItem(getChatKey(name), JSON.stringify([]));
      } else {
        localStorage.setItem('chatHistory_v3_' + name, JSON.stringify([]));
      }
      if (typeof allMessages !== 'undefined') allMessages = [];
      if (typeof loadAndRenderMessages === 'function') {
        loadAndRenderMessages();
      } else {
        const messagesBox = document.getElementById('messages');
        if (messagesBox) messagesBox.innerHTML = '';
      }
    } else {
      // group/room mode
      const roomKey = typeof ROOM_HISTORY_KEY !== 'undefined' ? ROOM_HISTORY_KEY : 'room_history_v3';
      localStorage.setItem(roomKey, JSON.stringify([]));
      if (typeof allMessages !== 'undefined') allMessages = [];
      if (typeof loadAndRenderMessages === 'function') {
        loadAndRenderMessages();
      } else {
        const messagesBox = document.getElementById('messages');
        if (messagesBox) messagesBox.innerHTML = '';
      }
    }
    // give user feedback if function exists
    if (typeof showCustomAlert === 'function') showCustomAlert('Чат очищен.');
  } catch (e) {
    console.error('clearChat error', e);
    if (typeof showCustomAlert === 'function') showCustomAlert('Ошибка при очистке чата.');
  }
}
</script>
<div id="clearChatConfirmModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); z-index: 1100; align-items:center; justify-content:center;">
<div class="settings-content" style="max-width:420px; width:90%; padding:1rem; text-align:center;">
<h3 style="margin-top:0;">Подтвердите очистку</h3>
<p>Вы уверены, что хотите полностью очистить историю чата? Это действие необратимо.</p>
<div style="display:flex; gap:0.5rem; justify-content:center; margin-top:1rem;">
<button onclick="confirmClearChat()" style="background:var(--accent-gradient);" type="button">Да, очистить</button>
<button onclick="closeClearChatConfirm()" style="background:var(--input-bg); color:var(--text-color); border:1px solid rgba(var(--accent-color-rgb),0.12);" type="button">Отмена</button>
</div>
</div>
</div>
<script>
function openClearChatConfirm() {
  const modal = document.getElementById('clearChatConfirmModal');
  if(modal) modal.style.display = 'flex';
}
function closeClearChatConfirm() {
  const modal = document.getElementById('clearChatConfirmModal');
  if(modal) modal.style.display = 'none';
}
function confirmClearChat() {
  closeClearChatConfirm();
  if (typeof clearChat === 'function') {
    clearChat();
  } else {
    // fallback: try to clear via previous implementation
    try {
      const name = (typeof getCurrentCharacterName === 'function') ? getCurrentCharacterName() : (window.activeCharacter || null);
      if (name) {
        localStorage.setItem('chatHistory_v3_' + name, JSON.stringify([]));
      }
      if (typeof allMessages !== 'undefined') allMessages = [];
      if (typeof loadAndRenderMessages === 'function') loadAndRenderMessages();
      if (typeof showCustomAlert === 'function') showCustomAlert('Чат очищен.');
    } catch (e) { console.error(e); }
  }
}
</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  try {
    var saved = localStorage.getItem(TEXT_COLOR_STORAGE);
    if(saved) {
      var main = document.getElementById('mainTextColor');
      if(main) main.value = saved;
      var mobile = document.getElementById('mainTextColor_mobile');
      if(mobile) mobile.value = saved;
      applyTextColor(saved);
    } else {
      var main = document.getElementById('mainTextColor');
      var mobile = document.getElementById('mainTextColor_mobile');
      if(main && mobile) {
        mobile.value = main.value;
      }
    }
  } catch(e){ console.error(e); }
});
</script>
<script>
function initSettingsBindings() {
  try {
    const colorInput = document.getElementById('mainTextColor');
    if (colorInput && !colorInput._hasBinding) {
      colorInput.addEventListener('input', (e) => {
        if (typeof applyTextColor === 'function') applyTextColor(e.target.value);
        if (typeof saveToStorage === 'function') saveToStorage(TEXT_COLOR_STORAGE, e.target.value);
        else localStorage.setItem(TEXT_COLOR_STORAGE, e.target.value);
      });
      colorInput._hasBinding = true;
    }
    // ensure chat font size slider works
    const chatFontSizeSlider = document.getElementById('chatFontSize');
    const chatFontSizeIndicator = document.getElementById('chatFontSizeIndicator');
    if (chatFontSizeSlider && !chatFontSizeSlider._hasBinding) {
      chatFontSizeSlider.addEventListener('input', (e) => {
        const v = parseFloat(e.target.value);
        if (typeof applyChatTextSize === 'function') applyChatTextSize(v);
        try {
          if (typeof saveToStorage === 'function') saveToStorage(CHAT_FONT_SIZE_STORAGE, v);
          else localStorage.setItem(CHAT_FONT_SIZE_STORAGE, v);
        } catch(e){}
        if (chatFontSizeIndicator) chatFontSizeIndicator.textContent = `${Math.round(v*100)}%`;
      });
      chatFontSizeSlider._hasBinding = true;
    }
  } catch(e){ console.error('initSettingsBindings err', e); }
}

function initMobileTabs() {
  try {
    const container = document.getElementById('settingsSection');
    if (!container) return;
    const btns = container.querySelectorAll('.tab-buttons button');
    btns.forEach((b, idx) => {
      b.onclick = function(){ openSettingsTab(idx+1); };
    });
    // ensure tab pages have proper active states for first tab
    const pages = container.querySelectorAll('.tab-page');
    if (pages && pages.length) {
      pages.forEach((p,i)=> p.classList.toggle('active', i===0));
    }
  } catch(e){ console.error('initMobileTabs err', e); }
}

// run once to attach if DOM already ready
document.addEventListener('DOMContentLoaded', function(){ initSettingsBindings(); initMobileTabs(); });
</script>

<!-- MODAL SCRIPTS IMPORTED FROM index_animation_fixed.html -->
<script>
    // --- Global Variables and Constants ---
    if (typeof window.currentMode === 'undefined') window.currentMode = "personal";
    let characters = {};
    let activeCharacter = null;
    let attachedFiles = [];
    let regenerateVariants = [];
    let currentVariantIndex = -1;
    let isBotGenerating = false;
    let shouldScrollToBottom = true;
    let tempImportedCharacterData = null;

    const ROOM_HISTORY_KEY = "roomHistory_v3";
    const MEMORY_KEY = "neuralMemory_v3";
    const API_KEY_STORAGE = "userApiKey_v3";
    const API_URL_STORAGE = "apiUrl_v3";
    const THEME_STORAGE = "themePreference_v3";
    const TEXT_COLOR_STORAGE = "mainTextColor_v3";
    const CHAT_FONT_SIZE_STORAGE = "chatFontSize_v1";
    const SIDEBAR_STATE_STORAGE = "sidebarState_v1";
    const REST_API_URL_STORAGE = "restApiUrl_v2";
    const REST_API_HEADERS_STORAGE = "restApiHeaders_v2";
    const ENABLE_REST_API_STORAGE = "enableRestApi_v2";
    const GOOGLE_API_KEY_STORAGE = "googleApiKey_v1";
    const GOOGLE_API_MODEL_STORAGE = "googleApiModel_v1";
    const ENABLE_GOOGLE_API_STORAGE = "enableGoogleApi_v1";
    const AVAILABLE_GOOGLE_MODELS = [ { id: "gemini-2.0-flash", name: "Gemini 2.0 Flash" }, { id: "gemini-2.5-pro", name: "Gemini 2.5 Pro" }, { id: "gemini-2.5-flash", name: "Gemini 2.5 Flash" }, { id: "gemini-2.5-flash-lite", name: "Gemini 2.5 Flash-Lite" } ];

    let useRestApi = false;
    let restApiUrlValue = "";
    let restApiHeadersValue = {};
    let useGoogleApi = false;
    let googleApiKey = "";
    let googleApiModel = "";

    // --- DOM Elements Cache ---
    const prevVariantBtn = document.getElementById("prevVariantBtn");
    const nextVariantBtn = document.getElementById("nextVariantBtn");
    const applyVariantBtn = document.getElementById("applyVariantBtn");
    const variantCounter = document.getElementById("variantCounter");
    let globalToggleSettingsBtn;
    let globalThemeToggleBtn;
    const sendButton = document.getElementById("sendButton");
    const personalModeBtn = document.getElementById("personalModeBtn");
    const groupModeBtn = document.getElementById("groupModeBtn");
    const messagesBox = document.getElementById("messages");
    const userInput = document.getElementById("userInput");
    const chatFontSizeSlider = document.getElementById("chatFontSize");
    const chatFontSizeIndicator = document.getElementById("chatFontSizeIndicator");
    const hamburgerBtn = document.getElementById('hamburgerBtn');
    const mobileMenuContainer = document.getElementById('mobileMenuContainer');
    const mobileMenuItemsPlaceholder = document.getElementById('mobileMenuItemsPlaceholder');
    const mainInputRow = document.getElementById('mainInputRow');
    const sidebar = document.getElementById('sidebar');
    const sidebarToggleButton = document.getElementById('sidebarToggleButton');
    const filePreviewsContainer = document.getElementById('filePreviewsContainer');

    // --- Utility Functions ---

    /**
     * [FIXED] Adds the copy to clipboard functionality.
     * @param {string} text - The text to copy.
     */
    function copyMessageToClipboard(text) {
      if (!text) return;
      const textArea = document.createElement("textarea");
      textArea.value = text;
      
      // Prevent screen from scrolling to the element
      textArea.style.top = "0";
      textArea.style.left = "0";
      textArea.style.position = "fixed";

      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
            showCustomAlert('Текст скопирован в буфер обмена!');
        } else {
            showCustomAlert('Не удалось скопировать текст.');
        }
      } catch (err) {
        console.error('Ошибка копирования:', err);
        showCustomAlert('Ошибка при копировании текста.');
      }

      document.body.removeChild(textArea);
    }

    function setAppHeight() {
      const doc = document.documentElement;
      doc.style.setProperty('--app-height', `${window.innerHeight}px`);
    }

    function setAccentRgb() {
        const rootStyle = getComputedStyle(document.documentElement);
        const accentColor = rootStyle.getPropertyValue('--accent-color').trim();
        if (accentColor.startsWith('#')) {
            const hex = accentColor.substring(1);
            const r = parseInt(hex.substring(0,2), 16);
            const g = parseInt(hex.substring(2,4), 16);
            const b = parseInt(hex.substring(4,6), 16);
            document.documentElement.style.setProperty('--accent-color-rgb', `${r},${g},${b}`);
        } else if (accentColor.startsWith('rgb')) {
             const match = accentColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
            if (match) {
                document.documentElement.style.setProperty('--accent-color-rgb', `${match[1]},${match[2]},${match[3]}`);
            }
        }
    }

    function isMobileView() {
        return window.innerWidth <= 900;
    }

    // --- Mobile Menu & View Handling ---

    function setupMobileHamburgerMenu() {
        const placeholder = mobileMenuItemsPlaceholder;
        if (!placeholder) return;
        placeholder.innerHTML = '';

        const originalSidebarHeader = document.querySelector('.sidebar .sidebar-header');
        if (originalSidebarHeader) placeholder.appendChild(originalSidebarHeader.cloneNode(true));

        const mobileChatListDiv = document.createElement('div');
        mobileChatListDiv.id = 'mobileMenuChatListInternal';
        mobileChatListDiv.className = 'chat-list';
        placeholder.appendChild(mobileChatListDiv);
        renderChatList(mobileChatListDiv);

        globalThemeToggleBtn = document.getElementById('themeToggle');
        if (globalThemeToggleBtn && globalThemeToggleBtn.parentElement !== placeholder) {
             placeholder.appendChild(globalThemeToggleBtn);
        }

        globalToggleSettingsBtn = document.getElementById('toggleSettingsBtn');
        if (globalToggleSettingsBtn && globalToggleSettingsBtn.parentElement !== placeholder) {
            placeholder.appendChild(globalToggleSettingsBtn);
        }
    }

    function restoreDesktopElements() {
        const themeToggleInHamburger = mobileMenuItemsPlaceholder.querySelector('#themeToggle');
        if (themeToggleInHamburger) {
            document.body.appendChild(themeToggleInHamburger);
        }
        const settingsToggleInHamburger = mobileMenuItemsPlaceholder.querySelector('#toggleSettingsBtn');
        if (settingsToggleInHamburger) {
            document.body.appendChild(settingsToggleInHamburger);
        }
    }


    function handleViewChange() {
        setAppHeight();
        const mainContentEl = document.getElementById('mainContent');
        const visibleFileAttachBtn = mainInputRow.querySelector('.file-attach-button');
        const originalStatusIndicator = document.getElementById('messages-status-indicator');
        const pcSidebarToggle = document.getElementById('sidebarToggleButton');

        if (isMobileView()) {
            setupMobileHamburgerMenu();
            sendButton.innerHTML = '→';
            sendButton.setAttribute('aria-label', 'Отправить');

            let mobilePrefixDiv = mainInputRow.querySelector('.mobile-input-prefix');
            if (!mobilePrefixDiv) {
                mobilePrefixDiv = document.createElement('div');
                mobilePrefixDiv.className = 'mobile-input-prefix';
                mainInputRow.insertBefore(mobilePrefixDiv, userInput);
            }
            mobilePrefixDiv.style.display = 'flex';


            let mobileFileAttachBtn = mobilePrefixDiv.querySelector('.file-attach-button');
            if (!mobileFileAttachBtn && visibleFileAttachBtn) {
                mobileFileAttachBtn = visibleFileAttachBtn.cloneNode(true);
                mobileFileAttachBtn.onclick = () => document.getElementById('fileInput').click();
                mobilePrefixDiv.appendChild(mobileFileAttachBtn);
            } else if (mobileFileAttachBtn) {
                 mobileFileAttachBtn.style.display = 'flex';
            }
             if (visibleFileAttachBtn && visibleFileAttachBtn.parentElement === mainInputRow) {
                visibleFileAttachBtn.style.display = 'none';
            }


            let mobileStatusIndicator = mobilePrefixDiv.querySelector('#messages-status-indicator');
            if (!mobileStatusIndicator && originalStatusIndicator) {
                mobileStatusIndicator = originalStatusIndicator.cloneNode(true);
                mobilePrefixDiv.appendChild(mobileStatusIndicator);
            } else if (mobileStatusIndicator) {
                 mobileStatusIndicator.style.display = 'block';
            }
            if (originalStatusIndicator && originalStatusIndicator.parentElement === mainInputRow) {
                 originalStatusIndicator.style.display = 'none';
            }

            if(sidebar) sidebar.style.display = 'none';
            if(pcSidebarToggle) pcSidebarToggle.style.display = 'none';

        } else {
            restoreDesktopElements();
            sendButton.innerHTML = 'Отправить';

            const mobilePrefixDiv = mainInputRow.querySelector('.mobile-input-prefix');
            if (mobilePrefixDiv) mobilePrefixDiv.style.display = 'none';


            if (visibleFileAttachBtn && visibleFileAttachBtn.parentElement === mainInputRow) {
                 visibleFileAttachBtn.style.display = 'flex';
            }
            if (originalStatusIndicator && originalStatusIndicator.parentElement === mainInputRow) {
                originalStatusIndicator.style.display = 'block';
            }

            if (sidebar) sidebar.style.display = 'flex';
            if(pcSidebarToggle) pcSidebarToggle.style.display = 'flex';
            loadSidebarState();
        }
    }


    // --- Initialization ---
    window.onload = () => {
      setAccentRgb();
      loadSettings();
      loadNeuralMemory();
      loadTheme();
      loadTextColor();
      loadChatTextSize();
      populateGoogleApiModelSelect();

      const statusIndicator = document.getElementById('messages-status-indicator');
      const userInputEl = document.getElementById('userInput');

      let desktopFileAttachButton = mainInputRow.querySelector('.file-attach-button:not(.mobile-input-prefix .file-attach-button)');
      if (!desktopFileAttachButton) {
          desktopFileAttachButton = document.createElement('button');
          desktopFileAttachButton.className = 'file-attach-button';
          desktopFileAttachButton.setAttribute('aria-label', 'Прикрепить файл или изображение');
          desktopFileAttachButton.title = 'Прикрепить файл или изображение';
          desktopFileAttachButton.innerHTML = '📎'; // Changed from '?' to '📎'
          desktopFileAttachButton.type = 'button';
          desktopFileAttachButton.onclick = () => document.getElementById('fileInput').click();

          if (statusIndicator && statusIndicator.parentElement === mainInputRow) {
            mainInputRow.insertBefore(desktopFileAttachButton, statusIndicator);
          } else if (userInputEl) {
            mainInputRow.insertBefore(desktopFileAttachButton, userInputEl);
          } else {
            mainInputRow.insertBefore(desktopFileAttachButton, mainInputRow.firstChild);
          }
      } else {
         desktopFileAttachButton.innerHTML = '📎'; // Changed from '?' to '📎'
      }


      renderMode();
      renderChatList();
      renderGroupParticipants();
      setupEventListeners();
      updateVariantControls();
      handleViewChange();
      renderFilePreviews();

      if (activeCharacter) {
        setActiveCharacter(activeCharacter);
      } else {
        displayInitialHelperMessage();
      }
      userInput.style.height = 'auto';
      userInput.style.height = (userInput.scrollHeight) + 'px';
      setAppHeight();
    };


    function displayInitialHelperMessage() {
        if (Object.keys(characters).length === 0 && messagesBox.children.length === 0) {
             const helperP = document.createElement('p');
             helperP.style.textAlign = 'center';
             helperP.style.color = 'var(--text-color)';
             helperP.style.padding = '20px';
             helperP.style.fontStyle = 'italic';
             helperP.style.opacity = '0.7';
             helperP.innerHTML = 'Добро пожаловать! 👋<br>Создайте своего первого персонажа в настройках (⚙️), чтобы начать чат.';
             messagesBox.appendChild(helperP);
        }
    }

    // --- Event Listeners Setup ---
    function setupEventListeners() {
      if (hamburgerBtn) {
        hamburgerBtn.addEventListener('click', () => {
            mobileMenuContainer.classList.toggle('open');
            hamburgerBtn.classList.toggle('open');
            hamburgerBtn.setAttribute('aria-expanded', mobileMenuContainer.classList.contains('open'));
            mobileMenuContainer.setAttribute('aria-hidden', !mobileMenuContainer.classList.contains('open'));
        });
      }
      document.addEventListener('click', (event) => {
        if (mobileMenuContainer && mobileMenuContainer.classList.contains('open') &&
            !mobileMenuContainer.contains(event.target) &&
            hamburgerBtn && !hamburgerBtn.contains(event.target)) {
            mobileMenuContainer.classList.remove('open');
            if (hamburgerBtn) {
                hamburgerBtn.classList.remove('open');
                hamburgerBtn.setAttribute('aria-expanded', 'false');
            }
            mobileMenuContainer.setAttribute('aria-hidden', 'true');
        }
      });

      document.body.addEventListener('click', function(event) {
        const target = event.target.closest('#themeToggle');
        if (target) {
            document.body.classList.toggle("dark-theme");
            const isDark = document.body.classList.contains("dark-theme");
            setTheme(isDark);
            setAccentRgb();
            const savedUserColor = localStorage.getItem(TEXT_COLOR_STORAGE);
            if (savedUserColor) {
                applyTextColor(savedUserColor);
            } else {
                const themeTextColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
                applyTextColor(themeTextColor);
            }
        }
      });
      document.body.addEventListener('click', function(event) {
        if (event.target.closest('#toggleSettingsBtn')) {
            openSettingsModal();
        }
      });


      document.getElementById("settingsModal").addEventListener("click", (e) => {
        if (e.target === document.getElementById("settingsModal")) closeSettingsModal();
      });
       document.getElementById("lorebookModal").addEventListener("click", (e) => {
        if (e.target === document.getElementById("lorebookModal")) closeLorebookModal();
      });
       document.getElementById("backgroundModal").addEventListener("click", (e) => {
        if (e.target === document.getElementById("backgroundModal")) closeBackgroundModal();
      });
      document.getElementById("greetingSelectModal").addEventListener("click", (e) => {
        if (e.target === document.getElementById("greetingSelectModal")) closeGreetingModal();
      });

      // ИСПРАВЛЕНО: Закрытие модальных окон по Escape
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          closeSettingsModal();
          closeLorebookModal();
          closeBackgroundModal();
          closeGreetingModal();
          const avatarModal = document.querySelector('.avatar-preview-modal');
          if (avatarModal) document.body.removeChild(avatarModal);
          if (mobileMenuContainer && mobileMenuContainer.classList.contains('open')) {
            mobileMenuContainer.classList.remove('open');
            if (hamburgerBtn) {
                 hamburgerBtn.classList.remove('open');
                 hamburgerBtn.setAttribute('aria-expanded', 'false');
            }
            mobileMenuContainer.setAttribute('aria-hidden', 'true');
          }
        }
      });
      
      // ИСПРАВЛЕНО: Убираем фокус с поля ввода по клику вне его
      document.getElementById('chatContainer').addEventListener('click', (e) => {
        const inputContainer = document.querySelector('.input-area-container');
        // Check if the clicked element or any of its parents is the userInput or a child of inputContainer
        if (inputContainer && !inputContainer.contains(e.target)) {
            userInput.blur(); // Blur the input if click is outside
        }
      });

      sendButton.addEventListener("click", sendMessage);
      userInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          sendMessage();
        }
      });
      userInput.addEventListener('input', () => {
          userInput.style.height = 'auto';
          userInput.style.height = (userInput.scrollHeight) + 'px';
      });

      personalModeBtn.addEventListener('click', () => switchMode("personal"));
      groupModeBtn.addEventListener('click', () => switchMode("group"));


      document.getElementById("apiKey").addEventListener("input", () => saveToStorage(API_KEY_STORAGE, document.getElementById("apiKey").value.trim()));
      document.getElementById("apiUrl").addEventListener("input", () => saveToStorage(API_URL_STORAGE, document.getElementById("apiUrl").value.trim()));

      document.getElementById("googleApiKey").addEventListener("input", () => {
          googleApiKey = document.getElementById("googleApiKey").value.trim();
          saveToStorage(GOOGLE_API_KEY_STORAGE, googleApiKey);
      });
      document.getElementById("googleApiModel").addEventListener("change", () => {
          googleApiModel = document.getElementById("googleApiModel").value;
          saveToStorage(GOOGLE_API_MODEL_STORAGE, googleApiModel);
      });
      document.getElementById("enableGoogleApi").addEventListener("change", (event) => {
          useGoogleApi = event.target.checked;
          saveToStorage(ENABLE_GOOGLE_API_STORAGE, useGoogleApi.toString());
      });


      document.getElementById("neuralMemory").addEventListener("input", () => saveToStorage(MEMORY_KEY, document.getElementById("neuralMemory").value));
      document.getElementById("mainTextColor").addEventListener("input", (e) => {
          applyTextColor(e.target.value);
          saveToStorage(TEXT_COLOR_STORAGE, e.target.value);
      });
      chatFontSizeSlider.addEventListener("input", (e) => {
          applyChatTextSize(e.target.value);
          saveToStorage(CHAT_FONT_SIZE_STORAGE, e.target.value);
          chatFontSizeIndicator.textContent = `${Math.round(e.target.value * 100)}%`;
      });

      if (sidebarToggleButton) {
        sidebarToggleButton.addEventListener('click', toggleSidebar);
      }

      setupRestApiSwitch();
      setupFileAttach();
      setupScrollHandler();
      setupAvatarClickHandler();
      window.addEventListener('resize', handleViewChange);
    }

    // --- Sidebar Toggle (PC) ---
    function toggleSidebar() {
        if (!sidebar) return;
        sidebar.classList.toggle('collapsed');
        const isCollapsed = sidebar.classList.contains('collapsed');
        if (sidebarToggleButton) {
            sidebarToggleButton.innerHTML = isCollapsed ? '&gt;&gt;' : '&lt;&lt;';
            sidebarToggleButton.setAttribute('aria-label', isCollapsed ? 'Развернуть боковую панель' : 'Свернуть боковую панель');
        }
        localStorage.setItem(SIDEBAR_STATE_STORAGE, isCollapsed ? 'collapsed' : 'expanded');
        applyBackground(getCurrentCharacterName());
    }

    function loadSidebarState() {
        if (isMobileView() || !sidebar) {
             if(sidebar) sidebar.classList.add('collapsed');
             return;
        }
        const state = localStorage.getItem(SIDEBAR_STATE_STORAGE);
        const isCollapsed = state === 'collapsed';
        sidebar.classList.toggle('collapsed', isCollapsed);
        if (sidebarToggleButton) {
            sidebarToggleButton.innerHTML = isCollapsed ? '&gt;&gt;' : '&lt;&lt;';
            sidebarToggleButton.setAttribute('aria-label', isCollapsed ? 'Развернуть боковую панель' : 'Свернуть боковую панель');
        }
    }


    // --- Theme and Color Management ---
    function setTheme(isDark) {
      localStorage.setItem(THEME_STORAGE, isDark ? "dark" : "light");
      const themeIconPath = isDark ?
        '<path d="M12 3.6A8.4 8.4 0 003.6 12 8.4 8.4 0 0012 20.4a8.4 8.4 0 008.4-8.4A8.4 8.4 0 0012 3.6zm0 14.4a6 6 0 110-12 6 6 0 010 12zM12 7a1 1 0 00-1 1v3H8a1 1 0 000 2h3v3a1 1 0 002 0v-3h3a1 1 0 000-2h-3V8a1 1 0 00-1-1z"/>'
        : '<path d="M21 12.79A9 9 0 0112.21 3 7 7 0 1021 12.79z"/>';
      const themeIconEl = document.getElementById("themeIcon");
      if (themeIconEl) themeIconEl.innerHTML = themeIconPath;
    }
    function loadTheme() {
      const savedTheme = localStorage.getItem(THEME_STORAGE);
      const isDark = savedTheme === "dark";
      document.body.classList.toggle("dark-theme", isDark);
      setTheme(isDark);
      setAccentRgb();
    }
    function applyTextColor(color) {
        document.documentElement.style.setProperty('--text-color', color);
        document.documentElement.style.setProperty('--bold-text-color', color);
    }
    function loadTextColor() {
        const savedColor = localStorage.getItem(TEXT_COLOR_STORAGE);
        const colorPicker = document.getElementById("mainTextColor");
        if (savedColor) {
            applyTextColor(savedColor);
            if(colorPicker) colorPicker.value = savedColor;
        } else {
            const defaultThemeColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            applyTextColor(defaultThemeColor);
            if(colorPicker) colorPicker.value = defaultThemeColor;
        }
    }

    // --- Chat Font Size ---
    function applyChatTextSize(sizeMultiplier) {
        document.documentElement.style.setProperty('--chat-font-size-multiplier', sizeMultiplier);
        if (chatFontSizeIndicator) chatFontSizeIndicator.textContent = `${Math.round(sizeMultiplier * 100)}%`;
    }

    function loadChatTextSize() {
        const savedSize = localStorage.getItem(CHAT_FONT_SIZE_STORAGE);
        const defaultSize = 1;
        const sizeToApply = savedSize ? parseFloat(savedSize) : defaultSize;
        applyChatTextSize(sizeToApply);
        if (chatFontSizeSlider) chatFontSizeSlider.value = sizeToApply;
    }


    // --- Modal Handling ---
    function openSettingsModal() {
        const modal = document.getElementById("settingsModal");
        modal.style.display = "flex";
        if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
            modal.classList.add('above-hamburger');
        }
        document.getElementById("personalModeBtn").classList.toggle("selected", currentMode === "personal");
        document.getElementById("personalModeBtn").setAttribute("aria-selected", currentMode === "personal");
        document.getElementById("groupModeBtn").classList.toggle("selected", currentMode === "group");
        document.getElementById("groupModeBtn").setAttribute("aria-selected", currentMode === "group");
    }
    function closeSettingsModal() {
        const modal = document.getElementById("settingsModal");
        modal.style.display = "none";
        modal.classList.remove('above-hamburger');
    }
    function openLorebookModal() {
      const name = getCurrentCharacterName();
      if (!name || !characters[name]) return showCustomAlert("Сначала выберите или создайте персонажа.");
      document.getElementById("lorebookCharacterName").textContent = name;
      renderLorebookEntries(name);
      const modal = document.getElementById("lorebookModal");
      modal.style.display = "flex";
      const settingsModal = document.getElementById("settingsModal");
      if (settingsModal.style.display === "flex") {
          const settingsZIndex = parseInt(window.getComputedStyle(settingsModal).zIndex, 10) || 1000;
          modal.style.zIndex = settingsZIndex + 10;
      } else if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
            modal.classList.add('above-hamburger');
      } else {
          modal.style.zIndex = '';
      }
    }
    function closeLorebookModal() {
        const modal = document.getElementById("lorebookModal");
        modal.style.display = "none";
        modal.classList.remove('above-hamburger');
        modal.style.zIndex = '';
    }
    function openBackgroundModal() {
      const name = getCurrentCharacterName();
      if (!name) return showCustomAlert("Сначала выберите или создайте персонажа.");
      document.getElementById("backgroundCharacterName").textContent = name;
      const modal = document.getElementById("backgroundModal");
      modal.style.display = "flex";
      const settingsModal = document.getElementById("settingsModal");
      if (settingsModal.style.display === "flex") {
          const settingsZIndex = parseInt(window.getComputedStyle(settingsModal).zIndex, 10) || 1000;
          modal.style.zIndex = settingsZIndex + 10;
      } else if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
            modal.classList.add('above-hamburger');
      } else {
          modal.style.zIndex = '';
      }
    }
    function closeBackgroundModal() {
        const modal = document.getElementById("backgroundModal");
        modal.style.display = "none";
        modal.classList.remove('above-hamburger');
        modal.style.zIndex = '';
    }

    function openGreetingModal(characterName, greetings) {
        document.getElementById("greetingCharacterName").textContent = characterName;
        const optionsContainer = document.getElementById("greetingOptions");
        optionsContainer.innerHTML = "";
        let selectedGreeting = null;

        greetings.forEach((greeting, index) => {
            const optionDiv = document.createElement("div");
            optionDiv.className = "greeting-option";
            optionDiv.textContent = greeting.length > 150 ? greeting.substring(0, 150) + "..." : greeting;
            optionDiv.dataset.fullGreeting = greeting;
            if (index === 0) {
                optionDiv.classList.add("selected");
                selectedGreeting = greeting;
            }
            optionDiv.addEventListener("click", () => {
                optionsContainer.querySelectorAll(".greeting-option").forEach(opt => opt.classList.remove("selected"));
                optionDiv.classList.add("selected");
                selectedGreeting = greeting;
            });
            optionsContainer.appendChild(optionDiv);
        });

        const greetingModal = document.getElementById("greetingSelectModal");
        greetingModal.style.display = "flex";
        greetingModal.style.zIndex = '';
        greetingModal.classList.remove('above-hamburger');

        const settingsModal = document.getElementById("settingsModal");
        if (settingsModal.style.display === "flex") {
            const settingsZIndex = parseInt(window.getComputedStyle(settingsModal).zIndex, 10) || 1000;
            greetingModal.style.zIndex = settingsZIndex + 10;
        } else if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
            greetingModal.classList.add('above-hamburger');
        }
    }

    function closeGreetingModal() {
        const modal = document.getElementById("greetingSelectModal");
        modal.style.display = "none";
        modal.classList.remove('above-hamburger');
        modal.style.zIndex = '';
        tempImportedCharacterData = null;
    }
    function confirmGreetingSelection() {
        const selectedOption = document.querySelector("#greetingOptions .greeting-option.selected");
        if (selectedOption && tempImportedCharacterData) {
            tempImportedCharacterData.character.welcomeMessage = selectedOption.dataset.fullGreeting;
            finalizeImport(tempImportedCharacterData);
        }
        closeGreetingModal();
    }


    // --- Mode Switching (Personal/Group) ---
    function switchMode(mode) {
      if (currentMode === mode) return;
      currentMode = mode;

      const settingsPersonalBtn = document.querySelector('#settingsModal #personalModeBtn');
      const settingsGroupBtn = document.querySelector('#settingsModal #groupModeBtn');
      if (settingsPersonalBtn) {
        settingsPersonalBtn.classList.toggle("selected", mode === "personal");
        settingsPersonalBtn.setAttribute("aria-selected", mode === "personal");
      }
      if (settingsGroupBtn) {
        settingsGroupBtn.classList.toggle("selected", mode === "group");
        settingsGroupBtn.setAttribute("aria-selected", mode === "group");
      }

      renderMode();
      clearVariants();
    }

    function renderMode() {
      document.getElementById("groupParticipants").style.display = currentMode === "group" ? "flex" : "none";
      document.getElementById("characterSelect").disabled = currentMode === "group";
      shouldScrollToBottom = true;
      loadAndRenderMessages();
      renderGroupParticipants();
      updateVariantControls();
    }

    // --- Data Storage Utilities ---
    function saveToStorage(key, value) {
      if (value !== undefined && value !== null) localStorage.setItem(key, value);
      else localStorage.removeItem(key);
    }

    // --- Settings Load/Save ---
    function loadSettings() {
      characters = JSON.parse(localStorage.getItem("characters_v3")) || {};
      document.getElementById("apiKey").value = localStorage.getItem(API_KEY_STORAGE) || "";
      document.getElementById("apiUrl").value = localStorage.getItem(API_URL_STORAGE) || "https://llm.chutes.ai/v1/chat/completions";

      restApiUrlValue = localStorage.getItem(REST_API_URL_STORAGE) || "";
      document.getElementById("restApiUrl").value = restApiUrlValue;
      const headersString = localStorage.getItem(REST_API_HEADERS_STORAGE) || "";
      document.getElementById("restApiHeaders").value = headersString;
      try { restApiHeadersValue = headersString ? JSON.parse(headersString) : {}; }
      catch (e) { console.error("Ошибка парсинга сохраненных заголовков REST API:", e); restApiHeadersValue = {}; }
      useRestApi = localStorage.getItem(ENABLE_REST_API_STORAGE) === "true";
      document.getElementById("enableRestApi").checked = useRestApi;

      googleApiKey = localStorage.getItem(GOOGLE_API_KEY_STORAGE) || "";
      document.getElementById("googleApiKey").value = googleApiKey;
      googleApiModel = localStorage.getItem(GOOGLE_API_MODEL_STORAGE) || (AVAILABLE_GOOGLE_MODELS.length > 0 ? AVAILABLE_GOOGLE_MODELS[0].id : "");
      document.getElementById("googleApiModel").value = googleApiModel;
      useGoogleApi = localStorage.getItem(ENABLE_GOOGLE_API_STORAGE) === "true";
      document.getElementById("enableGoogleApi").checked = useGoogleApi;



      if (!activeCharacter && Object.keys(characters).length > 0) {
        activeCharacter = Object.keys(characters)[0];
      }

      // --- Restore temperature and maxTokens from localStorage (ensure persistence even after dynamic settings re-render) ---
      try {
        const storedTemp = localStorage.getItem('temperature');
        const storedMax = localStorage.getItem('maxTokens');
        const tempEl = document.getElementById('temperature');
        const maxEl = document.getElementById('maxTokens');
        if (tempEl && storedTemp !== null) tempEl.value = storedTemp;
        if (maxEl && storedMax !== null) maxEl.value = storedMax;

        // Attach listeners so future changes are persisted (idempotent)
        function saveTemp() { try { if (tempEl) localStorage.setItem('temperature', tempEl.value); } catch(e){console.warn(e);} }
        function saveMax() { try { if (maxEl) localStorage.setItem('maxTokens', maxEl.value); } catch(e){console.warn(e);} }
        if (tempEl && !tempEl.__charis_persist_attached) { tempEl.addEventListener('input', saveTemp); tempEl.addEventListener('change', saveTemp); tempEl.__charis_persist_attached = true; }
        if (maxEl && !maxEl.__charis_persist_attached) { maxEl.addEventListener('input', saveMax); maxEl.addEventListener('change', saveMax); maxEl.__charis_persist_attached = true; }
      } catch(e){ console.warn('settings persistence injection error', e); }

      populateCharacterSelect();
    }
    function loadNeuralMemory() {
      document.getElementById("neuralMemory").value = localStorage.getItem(MEMORY_KEY) || "";
    }

    /**
     * [FIXED] Saves settings and handles avatar file uploads by resizing and compressing them.
     */
    async function saveSettings() {
      const name = document.getElementById("characterName").value.trim();
      if (!name) return showCustomAlert("Введите имя персонажа.");

      const isNewChar = !characters[name];
      const charData = characters[name] || {};

      // --- Update character data from all form fields ---
      charData.name = name;
      charData.description = document.getElementById("description").value;
      charData.personality = document.getElementById("personality").value;
      charData.scenario = document.getElementById("scenario").value;
      charData.mes_example = document.getElementById("mes_example").value;
      charData.welcomeMessage = document.getElementById("welcomeMessage").value;
      // Removed: charData.alternate_greetings = document.getElementById("alternate_greetings").value.split('\n').map(g => g.trim()).filter(g => g);
      // When saving, we don't take alternate_greetings from UI, they are only imported.
      // If charData.alternate_greetings doesn't exist or is empty, initialize it as an empty array.
      if (!charData.alternate_greetings || !Array.isArray(charData.alternate_greetings)) {
          charData.alternate_greetings = [];
      }


      // Advanced prompts
      charData.system_prompt = document.getElementById("system_prompt").value;
      charData.post_history_instructions = document.getElementById("post_history_instructions").value;
      charData.creator_notes = document.getElementById("creator_notes").value;

      charData.model = document.getElementById("characterModel").value.trim() || document.getElementById("model").value;
      charData.lorebook = charData.lorebook || [];

      // Await avatar processing
      const charAvatarFromFile = await handleAvatarUpload('character');
      const userAvatarFromFile = await handleAvatarUpload('user');

      // Prioritize file upload, then URL input, then existing, then default placeholder
      if (charAvatarFromFile) {
          charData.avatarCharacter = charAvatarFromFile;
      } else if (document.getElementById("avatarUrl_character").value) {
          charData.avatarCharacter = document.getElementById("avatarUrl_character").value;
      } else if (!charData.avatarCharacter || charData.avatarCharacter.startsWith('data:image')) {
          charData.avatarCharacter = "https://placehold.co/100x100/FF7AAC/FFFFFF?text=Бот";
      }

      if (userAvatarFromFile) {
          charData.avatarUser = userAvatarFromFile;
      } else if (document.getElementById("avatarUrl_user").value) {
          charData.avatarUser = document.getElementById("avatarUrl_user").value;
      } else if (!charData.avatarUser || charData.avatarUser.startsWith('data:image')) {
          charData.avatarUser = "https://placehold.co/100x100/7AC5FF/FFFFFF?text=Вы";
      }


      // Save REST API settings
      restApiUrlValue = document.getElementById("restApiUrl").value.trim();
      saveToStorage(REST_API_URL_STORAGE, restApiUrlValue);
      const headersString = document.getElementById("restApiHeaders").value.trim();
      saveToStorage(REST_API_HEADERS_STORAGE, headersString);
      try { restApiHeadersValue = headersString ? JSON.parse(headersString) : {}; }
      catch (e) { showCustomAlert("Ошибка в JSON формате заголовков REST API. Заголовки не сохранены."); console.error("Неверный JSON в заголовках REST API:", e); restApiHeadersValue = {};}
      useRestApi = document.getElementById("enableRestApi").checked;
      saveToStorage(ENABLE_REST_API_STORAGE, useRestApi.toString());

      // Save Google API settings
      googleApiKey = document.getElementById("googleApiKey").value.trim();
      saveToStorage(GOOGLE_API_KEY_STORAGE, googleApiKey);
      googleApiModel = document.getElementById("googleApiModel").value;
      saveToStorage(GOOGLE_API_MODEL_STORAGE, googleApiModel);
      useGoogleApi = document.getElementById("enableGoogleApi").checked;
      saveToStorage(ENABLE_GOOGLE_API_STORAGE, useGoogleApi.toString());

      characters[name] = charData;
      localStorage.setItem("characters_v3", JSON.stringify(characters));

      populateCharacterSelect();
      renderChatList(document.getElementById('chatList'));
      const hamburgerChatListContainer = document.getElementById('mobileMenuChatListInternal');
      if (hamburgerChatListContainer) renderChatList(hamburgerChatListContainer);

      renderGroupParticipants();

      if (isNewChar || activeCharacter !== name) {
          setActiveCharacter(name);
      } else {
          loadAndRenderMessages();
          applyBackground(name);
      }
      document.getElementById("characterSelect").value = name;
      animateSaveButton();
      showCustomAlert(`Персонаж "${name}" сохранён.`);
      closeSettingsModal();
    }

    function populateGoogleApiModelSelect() {
        const selectEl = document.getElementById("googleApiModel");
        if (!selectEl) return;
        selectEl.innerHTML = "";
        AVAILABLE_GOOGLE_MODELS.forEach(model => {
            const option = document.createElement("option");
            option.value = model.id;
            option.textContent = model.name;
            selectEl.appendChild(option);
        });
        selectEl.value = localStorage.getItem(GOOGLE_API_MODEL_STORAGE) || (AVAILABLE_GOOGLE_MODELS.length > 0 ? AVAILABLE_GOOGLE_MODELS[0].id : "");
    }


    function animateSaveButton() {
      const btn = document.querySelector('.settings-content button[onclick="saveSettings()"]');
      if (!btn) return;
      const originalText = btn.textContent;
      btn.textContent = "✅ Сохранено!";
      btn.style.background = "linear-gradient(135deg, #a8e063 0%, #56ab2f 100%)";
      setTimeout(() => {
        btn.textContent = originalText;
        btn.style.background = "";
      }, 1500);
    }

    function showAvatarOptions(option, target) {
      document.getElementById(`avatarLinkInput_${target}`).style.display = option === 'link' ? 'block' : 'none';
      document.getElementById(`avatarFileInputWrapper_${target}`).style.display = option === 'file' ? 'block' : 'none';
    }

    /**
     * [FIXED] Handles avatar file upload. Resizes and compresses the image to prevent
     * localStorage size limit issues before converting to a Data URL.
     * @param {string} target - 'character' or 'user'.
     * @returns {Promise<string|null>} A promise that resolves with the compressed Data URL or null.
     */
    async function handleAvatarUpload(target) {
        const fileInput = document.getElementById(`avatarFileInput_${target}`);
        if (!fileInput || fileInput.files.length === 0) {
            return null;
        }
        const file = fileInput.files[0];
        const MAX_WIDTH = 256;
        const MAX_HEIGHT = 256;

        return new Promise((resolve) => {
            const img = document.createElement("img");
            const reader = new FileReader();

            reader.onload = (e) => {
                img.src = e.target.result; // Load file into an image element
            };

            img.onerror = () => {
                console.error("Не удалось загрузить файл изображения для обработки.");
                resolve(null); // Resolve with null if the image fails to load
            };

            img.onload = () => {
                // Resize the image on a canvas
                const canvas = document.createElement("canvas");
                let width = img.width;
                let height = img.height;

                if (width > height) {
                    if (width > MAX_WIDTH) {
                        height *= MAX_WIDTH / width;
                        width = MAX_WIDTH;
                    }
                } else {
                    if (height > MAX_HEIGHT) {
                        width *= MAX_HEIGHT / height;
                        height = MAX_HEIGHT;
                    }
                }
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0, width, height);

                // Get a compressed data URL (jpeg is usually smaller for photos)
                const dataUrl = canvas.toDataURL("image/jpeg", 0.85); 
                resolve(dataUrl);
            };
            
            reader.readAsDataURL(file);
        });
    }


    // --- Character List and Selection ---
    function populateCharacterSelect() {
      const select = document.getElementById("characterSelect");
      if (!select) return;
      const currentVal = select.value;
      select.innerHTML = "<option value=\"\" disabled>-- Выберите персонажа --</option>";
      const sortedNames = Object.keys(characters).sort((a, b) => a.localeCompare(b, 'ru'));

      for (const name of sortedNames) {
        const option = document.createElement("option");
        option.value = name;
        option.textContent = name;
        select.appendChild(option);
      }
      if (characters[currentVal]) select.value = currentVal;
      else if (activeCharacter && characters[activeCharacter]) select.value = activeCharacter;
      else if (sortedNames.length > 0) select.value = "";

      select.onchange = () => {
          if (select.value) setActiveCharacter(select.value);
          clearVariants();
      };
    }

    function renderChatList(targetContainerEl = null) {
      const container = targetContainerEl || document.getElementById("chatList");
      if (!container) {
        return;
      }

      container.innerHTML = "";
      const fragment = document.createDocumentFragment();
      const sortedNames = Object.keys(characters).sort((a, b) => a.localeCompare(b, 'ru'));

      if (sortedNames.length === 0 && container.id === "chatList") {
          container.innerHTML = `<p style="text-align:center; font-style:italic; opacity:0.7; padding:1rem;">Нет созданных персонажей.</p>`;
          return;
      }

      for (const name of sortedNames) {
        const char = characters[name];
        const chatItem = document.createElement("div");
        chatItem.className = "chat-item";
        if (activeCharacter === name && currentMode === "personal") chatItem.classList.add("active");
        chatItem.setAttribute("role", "listitem");
        chatItem.setAttribute("tabindex", "0");

        const avatarSrc = char.avatarCharacter || "https://placehold.co/80x80/FF7AAC/FFFFFF?text=" + name.charAt(0);
        chatItem.innerHTML = `
          <img src="${avatarSrc}" alt="Аватар ${name}" onerror="this.onerror=null;this.src='https://placehold.co/80x80/FF7AAC/FFFFFF?text=?';"/>
          <div class="chat-name" title="${name}">${name}</div>
          <button class="delete-char-btn" aria-label="Удалить персонажа ${name}" title="Удалить ${name}">×</button>
        `;
        chatItem.addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-char-btn')) return;
            setActiveCharacter(name);
            switchMode("personal");
            clearVariants();
            if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
                mobileMenuContainer.classList.remove('open');
                if(hamburgerBtn) hamburgerBtn.classList.remove('open');
            }
        });
        chatItem.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                if (e.target.classList.contains('delete-char-btn')) {
                    e.target.click();
                } else {
                    setActiveCharacter(name);
                    switchMode("personal");
                    clearVariants();
                     if (isMobileView() && mobileMenuContainer.classList.contains('open')) {
                        mobileMenuContainer.classList.remove('open');
                        if(hamburgerBtn) hamburgerBtn.classList.remove('open');
                    }
                }
            }
        });

        chatItem.querySelector('.delete-char-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            showCustomConfirm(`Вы уверены, что хотите удалить персонажа "${name}" и всю историю чата с ним? Это действие нельзя отменить.`, () => {
              delete characters[name];
              localStorage.setItem("characters_v3", JSON.stringify(characters));
              localStorage.removeItem(getChatKey(name));

              if (activeCharacter === name) {
                activeCharacter = Object.keys(characters)[0] || null;
                if (activeCharacter) {
                  setActiveCharacter(activeCharacter);
                } else {
                  // Clear all fields if no characters left
                  ['characterName', 'description', 'personality', 'scenario', 'mes_example', 'welcomeMessage', 'characterModel', 'system_prompt', 'post_history_instructions', 'creator_notes', 'avatarUrl_character', 'avatarUrl_user'].forEach(id => document.getElementById(id).value = '');
                  // For alternate_greetings, we no longer have an input field, so just ensure it's handled as an empty array or null if needed.
                  loadAndRenderMessages();
                  applyBackground(null);
                  displayInitialHelperMessage();
                }
              }
              renderChatList(document.getElementById('chatList'));
              const hamburgerChatList = document.getElementById('mobileMenuChatListInternal');
              if (hamburgerChatList) renderChatList(hamburgerChatList);

              renderGroupParticipants();
              populateCharacterSelect();
              clearVariants();
            });
        });
        fragment.appendChild(chatItem);
      }
      container.appendChild(fragment);
    }


    function renderGroupParticipants() {
      const container = document.getElementById("groupParticipants");
      container.innerHTML = "";
      if (currentMode !== "group" || Object.keys(characters).length === 0) {
        container.style.display = "none";
        return;
      }
      container.style.display = "flex";
      const fragment = document.createDocumentFragment();
      const sortedNames = Object.keys(characters).sort((a, b) => a.localeCompare(b, 'ru'));

      for (const name of sortedNames) {
        const char = characters[name];
        const participant = document.createElement("div");
        participant.className = "participant";
        participant.title = `Ответить от имени ${name}`;
        participant.setAttribute("role", "button");
        participant.setAttribute("tabindex", "0");
        const avatarSrc = char.avatarCharacter || 'https://placehold.co/80x80/FF7AAC/FFFFFF?text=' + name.charAt(0);
        participant.innerHTML = `
          <img src="${avatarSrc}" alt="Аватар ${name}" onerror="this.onerror=null;this.src='https://placehold.co/80x80/FF7AAC/FFFFFF?text=?';"/>
          <div>${name}</div>
        `;
        participant.addEventListener('click', () => {
            showCustomConfirm(`Сгенерировать ответ от имени ${name}?`, () => {
                 respondToLastMessage(name);
            });
        });
        participant.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                showCustomConfirm(`Сгенерировать ответ от имени ${name}?`, () => {
                     respondToLastMessage(name);
                });
            }
        });
        fragment.appendChild(participant);
      }
      if (sortedNames.length === 0) {
          container.innerHTML = `<p style="text-align:center; font-style:italic; opacity:0.7; padding:0.5rem;">Сначала создайте персонажей в настройках.</p>`;
      } else {
          container.appendChild(fragment);
      }
    }


    function setActiveCharacter(name) {
      if (!characters[name]) {
        console.warn(`Персонаж "${name}" не найден.`);
        activeCharacter = null;
        return;
      }
      activeCharacter = name;
      const ch = characters[name];

      // --- Populate all settings fields for the active character ---
      document.getElementById("characterName").value = name;
      document.getElementById("description").value = ch.description || "";
      document.getElementById("personality").value = ch.personality || "";
      document.getElementById("scenario").value = ch.scenario || "";
      document.getElementById("mes_example").value = ch.mes_example || "";
      document.getElementById("welcomeMessage").value = ch.welcomeMessage || "";
      // Removed: document.getElementById("alternate_greetings").value = (ch.alternate_greetings || []).join('\n');
      document.getElementById("system_prompt").value = ch.system_prompt || "";
      document.getElementById("post_history_instructions").value = ch.post_history_instructions || "";
      document.getElementById("creator_notes").value = ch.creator_notes || "";
      document.getElementById("characterModel").value = ch.model || "";
      
      // Update avatar URL input fields based on character data
      const avatarUrlInputChar = document.getElementById("avatarUrl_character");
      if (ch.avatarCharacter && !ch.avatarCharacter.startsWith('data:image')) {
          avatarUrlInputChar.value = ch.avatarCharacter;
          showAvatarOptions('link', 'character');
      } else {
          avatarUrlInputChar.value = "";
          showAvatarOptions('file', 'character'); // Default to file input if it's a data URL or missing
      }
      
      const avatarUrlInputUser = document.getElementById("avatarUrl_user");
      if (ch.avatarUser && !ch.avatarUser.startsWith('data:image')) {
          avatarUrlInputUser.value = ch.avatarUser;
          showAvatarOptions('link', 'user');
      } else {
          avatarUrlInputUser.value = "";
          showAvatarOptions('file', 'user'); // Default to file input if it's a data URL or missing
      }


      if (document.getElementById("characterSelect").value !== name) {
          document.getElementById("characterSelect").value = name;
      }

      shouldScrollToBottom = true;
      loadAndRenderMessages();
      renderChatList(document.getElementById('chatList'));
      const hamburgerChatList = document.getElementById('mobileMenuChatListInternal');
      if (hamburgerChatList) renderChatList(hamburgerChatList);

      applyBackground(name);
      clearVariants();
    }

    function getCurrentCharacterName() {
      if (currentMode === "personal") {
        return activeCharacter || (Object.keys(characters).length > 0 ? Object.keys(characters)[0] : null);
      }
      return null;
    }

    // --- Chat History Management ---
    function getChatKey(name) { return `chatHistory_v3_${name}`; }
    function saveChat(name, messages) {
      if (!name) return;
      try {
        localStorage.setItem(getChatKey(name), JSON.stringify(messages));
      } catch (e) {
        console.error("Ошибка сохранения чата в localStorage:", e);
        showCustomAlert("Ошибка: не удалось сохранить историю чата. Возможно, она слишком большая.");
      }
      allMessages = messages;
    }
    function loadChat(name) {
      if (!name) return [];
      let msgs = JSON.parse(localStorage.getItem(getChatKey(name)) || "[]");
      return msgs.map(msg => ({ ...msg, attachments: msg.attachments || null }));
    }
    function saveRoomChat(messages) {
        try {
            localStorage.setItem(ROOM_HISTORY_KEY, JSON.stringify(messages));
        } catch(e) {
            console.error("Ошибка сохранения чата комнаты в localStorage:", e);
            showCustomAlert("Ошибка: не удалось сохранить историю чата. Возможно, она слишком большая.");
        }
        allMessages = messages;
    }
    function loadRoomChat() {
      let msgs = JSON.parse(localStorage.getItem(ROOM_HISTORY_KEY) || "[]");
      return msgs.map(msg => ({ ...msg, attachments: msg.attachments || null }));
    }

    let allMessages = [];

    function loadAndRenderMessages(scrollToIndex = -1) {
        messagesBox.innerHTML = "";
        let characterForBackground = null;

        if (currentMode === "personal") {
            const name = getCurrentCharacterName();
            if (!name) {
                displayInitialHelperMessage();
                applyBackground(null);
                allMessages = [];
                return;
            }
            allMessages = loadChat(name);
            characterForBackground = name;
            if (allMessages.length === 0 && characters[name]?.welcomeMessage) {
                const welcome = characters[name].welcomeMessage;
                const welcomeMsgObject = { role: "assistant", content: welcome, avatar: characters[name].avatarCharacter, attachments: null };
                allMessages.push(welcomeMsgObject);
                saveChat(name, allMessages);
            } else if (allMessages.length === 0) {
                 const helperP = document.createElement('p');
                 helperP.style.textAlign = 'center'; helperP.style.color = 'var(--text-color)'; helperP.style.padding = '20px'; helperP.style.fontStyle = 'italic'; helperP.style.opacity = '0.7';
                 helperP.textContent = 'Нет сообщений. Начните диалог!';
                 messagesBox.appendChild(helperP);
            }
        } else {
            allMessages = loadRoomChat();
            characterForBackground = null;
            if (allMessages.length === 0) {
                const helperP = document.createElement('p');
                helperP.style.textAlign = 'center'; helperP.style.color = 'var(--text-color)'; helperP.style.padding = '20px'; helperP.style.fontStyle = 'italic'; helperP.style.opacity = '0.7';
                helperP.textContent = 'Нет сообщений в групповом чате. Начните диалог!';
                messagesBox.appendChild(helperP);
            }
        }
        applyBackground(characterForBackground);

        const fragment = document.createDocumentFragment();
        allMessages.forEach((msg, i) => {
            const container = createMessageContainerDOM(msg, i);
            fragment.appendChild(container);
        });
        messagesBox.appendChild(fragment);

        if (scrollToIndex !== -1 && scrollToIndex < allMessages.length) {
            const targetMsgEl = messagesBox.children[scrollToIndex];
            if (targetMsgEl) targetMsgEl.scrollIntoView({ behavior: "smooth", block: "nearest" });
        } else if (shouldScrollToBottom) {
            scrollToBottom(true);
            shouldScrollToBottom = false;
        }
    }


    // --- Message DOM Manipulation ---
    function createMessageContainerDOM(msgData, index) {
      const container = document.createElement("div");
      container.className = "message-container";
      container.dataset.index = index;

      let senderName, msgClass, roleForButtons, avatarUrl;
      const charNameForMsg = getCurrentCharacterName();

      if (currentMode === "personal") {
        senderName = msgData.role === "user" ? "Вы" : charNameForMsg;
        msgClass = msgData.role === "user" ? "user" : (msgData.role === "system" ? "system" : (msgData.role === "api" ? "api" : ""));
        roleForButtons = msgData.role;
        if (msgData.role === "user") {
          avatarUrl = characters[charNameForMsg]?.avatarUser || "https://placehold.co/80x80/7AC5FF/FFFFFF?text=Вы";
        } else if (msgData.role === "assistant") {
          avatarUrl = characters[charNameForMsg]?.avatarCharacter || "https://placehold.co/80x80/FF7AAC/FFFFFF?text=" + (charNameForMsg ? charNameForMsg.charAt(0) : "Б");
        } else {
          avatarUrl = msgData.role === "system" ? "https://placehold.co/80x80/CCCCCC/FFFFFF?text=S" : "https://placehold.co/80x80/80D0C0/FFFFFF?text=A";
        }
      } else {
        senderName = msgData.sender || (msgData.role === "user" ? "Вы" : "Система");
        msgClass = (msgData.sender === "Вы" || msgData.role === "user") ? "user" : (msgData.role === "system" ? "system" : (msgData.role === "api" ? "api" : ""));
        roleForButtons = msgData.role;
        if (msgData.sender === "Вы") {
          const anyUserAvatar = Object.values(characters).find(c => c.avatarUser)?.avatarUser;
          avatarUrl = anyUserAvatar || "https://placehold.co/80x80/7AC5FF/FFFFFF?text=Вы";
        } else if (characters[msgData.sender]) {
          avatarUrl = characters[msgData.sender].avatarCharacter || "https://placehold.co/80x80/FF7AAC/FFFFFF?text=" + msgData.sender.charAt(0);
        } else {
          avatarUrl = msgData.role === "system" ? "https://placehold.co/80x80/CCCCCC/FFFFFF?text=S" : "https://placehold.co/80x80/80D0C0/FFFFFF?text=A";
        }
      }
      avatarUrl = msgData.avatar || avatarUrl;
      if (msgClass === "user") container.classList.add("user-container");

      const contentWrapper = document.createElement('div');
      contentWrapper.className = 'message-content-wrapper';

      const avatarImg = document.createElement("img");
      avatarImg.src = avatarUrl || "https://placehold.co/80x80/CCCCCC/FFFFFF?text=?";
      avatarImg.alt = `Аватар ${senderName}`;
      avatarImg.className = "avatar";
      avatarImg.onerror = function() { this.onerror=null; this.src='https://placehold.co/80x80/CCCCCC/FFFFFF?text=?'; };


      const messageDiv = document.createElement("div");
      messageDiv.className = `message ${msgClass}`;

      let htmlContent = "";
      let textPart = msgData.content ? marked.parse(msgData.content) : '';
      htmlContent = `<strong>${senderName}:</strong>${textPart}`;
      messageDiv.innerHTML = htmlContent;

      if (msgData.attachments && msgData.attachments.length > 0) {
        const attachmentsGrid = document.createElement('div');
        attachmentsGrid.className = 'attachments-grid';
        msgData.attachments.forEach(att => {
            if (att.type && att.type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = att.src;
                img.alt = att.name || 'Прикрепленное изображение';
                img.className = 'attached-image';
                attachmentsGrid.appendChild(img);
            } else {
                const fileLink = document.createElement('a');
                fileLink.href = att.src;
                fileLink.target = '_blank';
                fileLink.className = 'attached-file-link';
                fileLink.download = att.name || 'file';
                fileLink.innerHTML = `<span class="file-icon">📄</span> ${att.name || 'Прикрепленный файл'}`;
                attachmentsGrid.appendChild(fileLink);
            }
        });
        messageDiv.appendChild(attachmentsGrid);
      }


      contentWrapper.appendChild(avatarImg);
      contentWrapper.appendChild(messageDiv);
      container.appendChild(contentWrapper);

      if (index !== null && roleForButtons !== "system" && senderName !== "API" && senderName !== "Система") {
        const buttonsDiv = document.createElement("div");
        buttonsDiv.className = "message-buttons";

        const copyBtn = document.createElement("button");
        copyBtn.className = "copy-btn"; copyBtn.title = "Копировать";
        copyBtn.setAttribute("aria-label", "Копировать сообщение");
        copyBtn.addEventListener("click", () => copyMessageToClipboard(msgData.content || ""));
        buttonsDiv.appendChild(copyBtn);

        const editBtn = document.createElement("button");
        editBtn.className = "edit-btn"; editBtn.title = "Редактировать";
        editBtn.setAttribute("aria-label", "Редактировать сообщение");
        editBtn.addEventListener("click", () => startEditingMessage(container, index));
        buttonsDiv.appendChild(editBtn);

        if (roleForButtons === "assistant") {
          const regenBtn = document.createElement("button");
          regenBtn.className = "regen-btn"; regenBtn.title = "Регенерировать";
          regenBtn.setAttribute("aria-label", "Регенерировать ответ");
          regenBtn.addEventListener("click", () => regenerateMessage(index));
          if (isBotGenerating) regenBtn.disabled = true;
          buttonsDiv.appendChild(regenBtn);
        }

        const delBtn = document.createElement("button");
        delBtn.className = "delete-btn"; delBtn.title = "Удалить";
        delBtn.setAttribute("aria-label", "Удалить сообщение");
        delBtn.addEventListener("click", () => deleteMessage(index));
        buttonsDiv.appendChild(delBtn);

        container.appendChild(buttonsDiv);
      }
      return container;
    }

    function appendNewMessageToDOM(msgData, index) {
        const container = createMessageContainerDOM(msgData, index);
        messagesBox.appendChild(container);
        requestAnimationFrame(() => {
            container.style.opacity = 1;
            container.style.transform = 'translateY(0)';
        });
        if (shouldScrollToBottom) {
            scrollToBottom(true);
        }
    }

    function updateMessageInDOM(index, newMsgData) {
        const oldContainer = messagesBox.querySelector(`.message-container[data-index="${index}"]`);
        if (oldContainer) {
            const newContainer = createMessageContainerDOM(newMsgData, index);
            messagesBox.replaceChild(newContainer, oldContainer);
             requestAnimationFrame(() => {
                newContainer.style.opacity = 1;
                newContainer.style.transform = 'translateY(0)';
            });
        }
    }
    function removeMessageFromDOM(index) {
        const containerToRemove = messagesBox.querySelector(`.message-container[data-index="${index}"]`);
        if (containerToRemove) {
            messagesBox.removeChild(containerToRemove);
            const messageContainers = messagesBox.querySelectorAll('.message-container');
            messageContainers.forEach((container, newIdx) => {
                container.dataset.index = newIdx;
            });
        }
    }


    function scrollToBottom(force = false) {
      if (force || messagesBox.scrollTop + messagesBox.clientHeight >= messagesBox.scrollHeight - 100) {
        messagesBox.scrollTop = messagesBox.scrollHeight;
      }
    }

    // --- Message Editing ---
    function startEditingMessage(container, index) {
      const messageContentWrapper = container.querySelector(".message-content-wrapper");
      const messageButtons = container.querySelector(".message-buttons");
      if (!messageContentWrapper || container.querySelector(".message-edit-area")) return;

      let originalText = allMessages[index].content;

      messageContentWrapper.style.display = "none";
      if (messageButtons) messageButtons.style.display = "none";

      const editArea = document.createElement("textarea");
      editArea.className = "message-edit-area";
      editArea.value = originalText;
      editArea.style.height = 'auto';
      editArea.style.height = (Math.max(80, editArea.scrollHeight)) + 'px';
      editArea.addEventListener('input', () => {
          editArea.style.height = 'auto';
          editArea.style.height = (Math.max(80, editArea.scrollHeight)) + 'px';
      });

      const saveBtn = document.createElement("button");
      saveBtn.textContent = "Сохранить"; saveBtn.className = "send-button";
      saveBtn.style.marginRight = "0.5rem";

      const cancelBtn = document.createElement("button");
      cancelBtn.textContent = "Отмена"; cancelBtn.className = "send-button";
      cancelBtn.style.background = "var(--participant-bg)"; cancelBtn.style.color = "var(--text-color)";

      const btnContainer = document.createElement("div");
      btnContainer.className = "edit-button-container";
      btnContainer.appendChild(saveBtn); btnContainer.appendChild(cancelBtn);

      container.insertBefore(editArea, messageContentWrapper);
      container.insertBefore(btnContainer, editArea.nextSibling);
      editArea.focus();

      saveBtn.onclick = () => {
        const newText = editArea.value.trim();
        const currentMessageAttachments = allMessages[index]?.attachments;
        if (!newText && (!currentMessageAttachments || currentMessageAttachments.length === 0)) {
            return showCustomAlert("Сообщение не может быть пустым, если нет вложений.");
        }
        updateMessageContent(index, newText);

        if (allMessages[index].role === 'user' || allMessages[index].sender === 'Вы') {
            const charToRespondName = currentMode === 'personal' ? getCurrentCharacterName() : getLastBotSender(index);
            if (charToRespondName && characters[charToRespondName]) {
                triggerBotResponseAfterEdit(index, charToRespondName);
            }
        }
      };
      cancelBtn.onclick = () => {
        messageContentWrapper.style.display = "flex";
        if (messageButtons) messageButtons.style.display = "flex";
        container.removeChild(editArea);
        container.removeChild(btnContainer);
      };
    }

    function getLastBotSender(currentUserMsgIndex) {
        if (currentMode !== 'group') return null;
        for (let i = currentUserMsgIndex - 1; i >= 0; i--) {
            if (allMessages[i].role === 'assistant' && allMessages[i].sender && characters[allMessages[i].sender]) {
                return allMessages[i].sender;
            }
        }
        return Object.keys(characters).length > 0 ? Object.keys(characters)[0] : null;
    }

    async function triggerBotResponseAfterEdit(editedUserMessageIndex, characterNameToRespond) {
        const charDataForApi = characters[characterNameToRespond];
        if (!charDataForApi) return;

        const historyUpToEdited = allMessages.slice(0, editedUserMessageIndex + 1);
        const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
        const max_tokens = parseInt(document.getElementById("maxTokens").value) || 1024;

        if (allMessages.length > editedUserMessageIndex + 1) {
            allMessages.splice(editedUserMessageIndex + 1);
             if (currentMode === "personal") saveChat(getCurrentCharacterName(), allMessages);
             else saveRoomChat(allMessages);
            loadAndRenderMessages(editedUserMessageIndex);
        }

        const systemPromptText = getSystemContent(charDataForApi, allMessages[editedUserMessageIndex].content);

        if (useGoogleApi && googleApiKey && googleApiModel) {
            let geminiContents = [];
            historyUpToEdited.forEach(m => {
                let role = (m.sender === "Вы" || m.role === "user") ? "user" : "model";
                let textContent = (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${m.content}` : m.content;

                let parts = [];
                if (textContent) parts.push({ text: textContent });
                if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                    m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                        parts.push({ inlineData: { mimeType: att.type, data: att.src.split(',')[1] } });
                    });
                } else if (m.attachments) {
                     parts.push({ text: `[Прикреплено ${m.attachments.length} файлов]` });
                }

                if (parts.length > 0) {
                     if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                        console.warn("Consecutive roles for Gemini (after edit), appending parts:", role);
                        geminiContents[geminiContents.length - 1].parts.push(...parts);
                    } else {
                        geminiContents.push({ role: role, parts: parts });
                    }
                }
            });
            let lastValidRoleAfterEdit = null;
            geminiContents = geminiContents.filter(item => {
                if (item.role === lastValidRoleAfterEdit) return false;
                lastValidRoleAfterEdit = item.role;
                return true;
            });

            
            // Добавляем пост-инструкции в systemPromptText (если заданы) чтобы Gemini учитывал их с повышенным приоритетом
            try {
                const postEl = document.getElementById('post_history_instructions');
                const postInstr = postEl ? postEl.value.trim() : '';
                if (postInstr) {
                    // добавляем в конец systemPromptText, отделяя переносами для ясности
                    systemPromptText = (systemPromptText ? systemPromptText + "\n\n" : "") + postInstr;
                }
            } catch(e){ console.error('post history instructions append error', e); }
        await fetchGeminiChatCompletion(
                googleApiKey, googleApiModel, systemPromptText, geminiContents,
                temperature, max_tokens, characterNameToRespond,
                allMessages, charDataForApi.avatarCharacter, true
            );

        } else {
            let messagesForAPI = [{ role: "system", content: systemPromptText }];
            messagesForAPI.push(...historyUpToEdited.map(m => {
                let apiMsgContentArray = [];
                if (m.content) apiMsgContentArray.push({ type: "text", text: m.content });
                // Append post-history instructions as system (if present)
                try {
                    const postEl = document.getElementById('post_history_instructions');
                    const postInstr = postEl ? postEl.value.trim() : '';
                    if (postInstr) {
                        messagesForAPI.push({ role: "system", content: postInstr });
                    }
                } catch(e){ console.error('post history instructions append error', e); }
                
                if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                    m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                         apiMsgContentArray.push({ type: "image_url", image_url: { url: att.src } });
                    });
                } else if (m.attachments) {
                     apiMsgContentArray.push({ type: "text", text: `[Прикреплено ${m.attachments.length} файлов]` });
                }
                const finalContent = apiMsgContentArray.length === 1 && apiMsgContentArray[0].type === "text" ? apiMsgContentArray[0].text : apiMsgContentArray;

                return {
                    role: (m.sender === "Вы" || m.role === "user") ? "user" : "assistant",
                    content: (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${finalContent}` : finalContent
                };
            }));

            const apiKey = document.getElementById("apiKey").value;
            const apiUrl = document.getElementById("apiUrl").value;
            const modelForApi = charDataForApi.model || document.getElementById("model").value;

            await fetchChatCompletion(
                apiUrl, apiKey, modelForApi, messagesForAPI,
                temperature, max_tokens, characterNameToRespond,
                allMessages, charDataForApi.avatarCharacter, true
            );
        }
    }


    function updateMessageContent(index, newContent) {
      if (index < 0 || index >= allMessages.length) return;
      const msgToUpdate = allMessages[index];
      msgToUpdate.content = newContent;

      if (currentMode === "personal") {
        const name = getCurrentCharacterName();
        if (!name) return;
        saveChat(name, allMessages);
      } else {
        saveRoomChat(allMessages);
      }
      updateMessageInDOM(index, msgToUpdate);
    }

    function deleteMessage(index) {
      if (index < 0 || index >= allMessages.length) return;
      showCustomConfirm("Вы уверены, что хотите удалить это сообщение?", () => {
        allMessages.splice(index, 1);

        if (currentMode === "personal") {
          const name = getCurrentCharacterName();
          if (!name) return;
          saveChat(name, allMessages);
        } else {
          saveRoomChat(allMessages);
        }
        removeMessageFromDOM(index);
        clearVariants();
        if (allMessages.length === 0) {
            loadAndRenderMessages();
        }
      });
    }

    // --- Message Regeneration ---
    async function regenerateMessage(index) {
        if (isBotGenerating) return;
        if (index < 0 || index >= allMessages.length || allMessages[index].role !== 'assistant') {
            showCustomAlert("Можно регенерировать только ответ ассистента.");
            return;
        }

        isBotGenerating = true;
        updateRegenerateButtonsState(true);
        setStatusActive(true);

        const characterForResponse = currentMode === "personal" ? getCurrentCharacterName() : allMessages[index].sender;
        if (!characterForResponse || !characters[characterForResponse]) {
            showCustomAlert("Не удалось определить персонажа для регенерации.");
            isBotGenerating = false; updateRegenerateButtonsState(false); setStatusActive(false);
            return;
        }
        const charData = characters[characterForResponse];

        let userMsgIndex = -1;
        for (let i = index - 1; i >= 0; i--) {
            const msg = allMessages[i];
            const isUserMsg = (currentMode === "personal" && msg.role === "user") ||
                              (currentMode === "group" && (msg.sender === "Вы" || msg.role === "user"));
            if (isUserMsg) {
                userMsgIndex = i;
                break;
            }
        }
        if (userMsgIndex === -1) {
            showCustomAlert("Не найдено предыдущее сообщение пользователя для контекста регенерации.");
            isBotGenerating = false; updateRegenerateButtonsState(false); setStatusActive(false);
            return;
        }

        if (regenerateVariants.length === 0 || currentVariantIndex === -1) {
            regenerateVariants = [JSON.parse(JSON.stringify(allMessages))];
            currentVariantIndex = 0;
        }

        const historyForAPI = allMessages.slice(0, index);
        const userMessageContentForSystem = allMessages[userMsgIndex].content;

        const targetMessageContainer = messagesBox.querySelector(`.message-container[data-index="${index}"]`);
        const messageDivToUpdate = targetMessageContainer ? targetMessageContainer.querySelector('.message') : null;

        if (messageDivToUpdate) {
            messageDivToUpdate.innerHTML = `<strong>${characterForResponse}:</strong> ...регенерируется...`;
            scrollToBottom(true);
        }

        let newVariantChatState;

        try {
            let reply;
            const systemPromptText = getSystemContent(charData, userMessageContentForSystem);

            if (useGoogleApi && googleApiKey && googleApiModel) {
                let geminiContents = [];
                 historyForAPI.forEach(m => {
                    let role = (m.sender === "Вы" || m.role === "user") ? "user" : "model";
                    let textContent = (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${m.content}` : m.content;
                    let parts = [];
                    if (textContent) parts.push({ text: textContent });
                    if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                        m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                            parts.push({ inlineData: { mimeType: att.type, data: att.src.split(',')[1] } });
                        });
                    } else if (m.attachments) {
                        parts.push({ text: `[Прикреплено ${m.attachments.length} файлов]` });
                    }
                    if (parts.length > 0) {
                         if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                             console.warn("Consecutive roles for Gemini (regen), appending parts:", role);
                             geminiContents[geminiContents.length - 1].parts.push(...parts);
                         } else {
                            geminiContents.push({ role: role, parts: parts });
                         }
                    }
                });
                let lastValidRoleRegen = null;
                geminiContents = geminiContents.filter(item => {
                    if (item.role === lastValidRoleRegen) return false;
                    lastValidRoleRegen = item.role;
                    return true;
                });

                const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${googleApiModel}:generateContent?key=${googleApiKey}`;
                const geminiRequestBody = {
                    systemInstruction: { parts: [{ text: systemPromptText }] },
                    contents: geminiContents,
                    generationConfig: {
                        temperature: parseFloat(document.getElementById("temperature").value) || 0.7,
                        maxOutputTokens: parseInt(document.getElementById("maxTokens").value) || 1024
                    }
                };
                const response = await fetch(geminiUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(geminiRequestBody)
                });
                if (!response.ok) throw new Error(`Google API Ошибка: ${response.status} ${await response.text()}`);
                const result = await response.json();
                reply = result.candidates?.[0]?.content?.parts?.[0]?.text || "";
                if (!reply && !(result.candidates && result.candidates[0].finishReason === "MAX_TOKENS")) throw new Error("Пустой ответ от Google API.");

                newVariantChatState = JSON.parse(JSON.stringify(allMessages.slice(0, index)));
                const newBotMsgData = {
                    ...allMessages[index],
                    content: reply,
                    attachments: null,
                };
                newVariantChatState.push(newBotMsgData);
                if (allMessages.length > index + 1) {
                    newVariantChatState.push(...JSON.parse(JSON.stringify(allMessages.slice(index + 1))));
                }
                regenerateVariants.push(newVariantChatState);
                currentVariantIndex = regenerateVariants.length - 1;
                allMessages = [...newVariantChatState];
                if (currentMode === "personal") saveChat(getCurrentCharacterName(), allMessages);
                else saveRoomChat(allMessages);
                updateMessageInDOM(index, allMessages[index]);
                scrollToBottom(true);
                shouldScrollToBottom = false;

            } else {
                shouldScrollToBottom = true;
                let messagesForStdAPI = [{ role: "system", content: systemPromptText }];
                messagesForStdAPI.push(...historyForAPI.map(m => {
                     let apiContentArray = [];
                     if (m.content) apiContentArray.push({ type: "text", text: m.content });
                // Append 'Инструкции после истории' как system-сообщение (если задано)
                try {
                    const postEl = document.getElementById('post_history_instructions');
                    const postInstr = postEl ? postEl.value.trim() : '';
                    if (postInstr) {
                        messagesForStdAPI.push({ role: "system", content: postInstr });
                    }
                } catch(e){ console.error('post history instructions append error', e); }
                
                     if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                         m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                              apiContentArray.push({ type: "image_url", image_url: { url: att.src } });
                         });
                     } else if (m.attachments) {
                         apiContentArray.push({ type: "text", text: ` [Прикреплено ${m.attachments.length} файлов]` });
                     }
                     const finalContent = apiContentArray.length === 1 && apiContentArray[0].type === "text" ? apiContentArray[0].text : apiContentArray;
                    return {
                        role: (m.sender === "Вы" || m.role === "user") ? "user" : "assistant",
                        content: (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${finalContent}` : finalContent
                    };
                }));

                const apiKey = document.getElementById("apiKey").value;
                const apiUrl = document.getElementById("apiUrl").value;
                const model = charData.model || document.getElementById("model").value;
                const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
                const max_tokens = parseInt(document.getElementById("maxTokens").value) || 1024;

                const response = await fetch(apiUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "Authorization": `Bearer ${apiKey}` },
                    body: JSON.stringify({ model, messages: messagesForStdAPI, stream: true, max_tokens, temperature })
                });
                if (!response.ok) throw new Error(`HTTP ошибка! Статус: ${response.status} ${await response.text()}`);

                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let streamedContent = "";
                reply = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value);
                    const lines = chunk.split("\n").filter(line => line.trim().startsWith("data: "));
                    for (const line of lines) {
                        if (line.includes("[DONE]")) break;
                        const jsonString = line.replace(/^data: /, "");
                        try {
                            const parsed = JSON.parse(jsonString);
                            const content = parsed.choices?.[0]?.delta?.content;
                            if (content) {
                                streamedContent += content;
                                reply = removeThoughts(streamedContent);
                                if (messageDivToUpdate) {
                                    messageDivToUpdate.innerHTML = `<strong>${characterForResponse}:</strong>${marked.parse(reply)}`;
                                    scrollToBottom(true);
                                }
                            }
                        } catch (e) { /* console.warn("Stream parsing error:", e, jsonString); */ }
                    }
                }
                if (!reply && streamedContent) reply = removeThoughts(streamedContent);

                newVariantChatState = JSON.parse(JSON.stringify(allMessages.slice(0, index)));
                const newBotMsgDataStreaming = {
                    ...allMessages[index],
                    content: reply,
                    attachments: null,
                };
                newVariantChatState.push(newBotMsgDataStreaming);
                if (allMessages.length > index + 1) {
                    newVariantChatState.push(...JSON.parse(JSON.stringify(allMessages.slice(index + 1))));
                }
                regenerateVariants.push(newVariantChatState);
                currentVariantIndex = regenerateVariants.length - 1;
                allMessages = [...newVariantChatState];
                if (currentMode === "personal") saveChat(getCurrentCharacterName(), allMessages);
                else saveRoomChat(allMessages);
                if (!messageDivToUpdate) {
                    updateMessageInDOM(index, allMessages[index]);
                }
            }
        } catch (err) {
            console.error("Ошибка регенерации:", err);
            if (messageDivToUpdate) {
                 const originalMessageOfCurrentVariant = regenerateVariants[currentVariantIndex] ? regenerateVariants[currentVariantIndex][index] : null;
                 const veryFirstOriginalMessage = regenerateVariants[0] ? regenerateVariants[0][index] : null;
                 const messageToRevertTo = originalMessageOfCurrentVariant || veryFirstOriginalMessage;

                 if (messageToRevertTo) {
                    updateMessageInDOM(index, messageToRevertTo);
                    allMessages[index] = JSON.parse(JSON.stringify(messageToRevertTo));
                 } else {
                    messageDivToUpdate.innerHTML = `<strong>${characterForResponse}:</strong> Ошибка регенерации: ${err.message}`;
                 }
            } else {
                appendNewMessageToDOM({ sender: "Система", content: `Ошибка регенерации: ${err.message}`, role: "system" }, allMessages.length);
            }
        } finally {
            setStatusActive(false);
            isBotGenerating = false;
            updateRegenerateButtonsState(false);
            updateVariantControls();
            if (shouldScrollToBottom) { scrollToBottom(true); shouldScrollToBottom = false; }
            userInput.focus();
        }
    }


    function updateRegenerateButtonsState(disable) {
        const regenBtns = document.querySelectorAll('.message-buttons .regen-btn');
        regenBtns.forEach(btn => btn.disabled = disable);
    }


    function renderSpecificChatState(chatState) {
        messagesBox.innerHTML = "";
        const fragment = document.createDocumentFragment();
        chatState.forEach((msg, i) => {
            const container = createMessageContainerDOM(msg, i);
            fragment.appendChild(container);
        });
        messagesBox.appendChild(fragment);
        scrollToBottom(true);
    }


    function updateVariantControls() {
      const hasVariants = regenerateVariants.length > 1;
      [prevVariantBtn, nextVariantBtn, applyVariantBtn, variantCounter].forEach(el => {
          if (el) el.style.display = hasVariants ? "inline-block" : "none";
      });
      if (!hasVariants) {
        if (variantCounter) variantCounter.textContent = "";
        if(prevVariantBtn) prevVariantBtn.disabled = true;
        if(nextVariantBtn) nextVariantBtn.disabled = true;
        return;
      }
      if (currentVariantIndex < 0 && regenerateVariants.length > 0) currentVariantIndex = 0;
      if (currentVariantIndex >= regenerateVariants.length) currentVariantIndex = regenerateVariants.length - 1;

      if (variantCounter) variantCounter.textContent = `Вариант ${currentVariantIndex + 1} / ${regenerateVariants.length}`;
      if (prevVariantBtn) prevVariantBtn.disabled = currentVariantIndex === 0;
      if (nextVariantBtn) nextVariantBtn.disabled = currentVariantIndex === regenerateVariants.length - 1;
    }
    function prevVariant() { if (currentVariantIndex > 0) { currentVariantIndex--; renderVariant(); updateVariantControls(); } }
    function nextVariant() { if (currentVariantIndex < regenerateVariants.length - 1) { currentVariantIndex++; renderVariant(); updateVariantControls(); } }
    function applyVariant() {
      if (currentVariantIndex < 0 || currentVariantIndex >= regenerateVariants.length) return;
      const variantToApply = regenerateVariants[currentVariantIndex];
      allMessages = [...variantToApply];

      if (currentMode === "personal") {
        const name = getCurrentCharacterName();
        if (!name) return;
        saveChat(name, allMessages);
      } else {
        saveRoomChat(allMessages);
      }
      clearVariantsAndRender();
    }
    function renderVariant() {
      if (currentVariantIndex < 0 || currentVariantIndex >= regenerateVariants.length) return;
      renderSpecificChatState(regenerateVariants[currentVariantIndex]);
    }
    function clearVariants() { regenerateVariants = []; currentVariantIndex = -1; updateVariantControls(); }
    function clearVariantsAndRender() {
        clearVariants();
        shouldScrollToBottom = true;
        loadAndRenderMessages();
    }


    function getNeuralMemory() { return document.getElementById("neuralMemory").value.trim(); }

    function getSystemContent(charData, userMessage) {
        const memory = getNeuralMemory();
        const dateTime = new Date().toLocaleString('ru-RU', { dateStyle: 'full', timeStyle: 'short' });
        const dateTimeInfo = `[Текущие дата и время]: ${dateTime}`;

        // Build a comprehensive character definition string
        let characterDefinition = "";
        if (charData.description) characterDefinition += `[Описание персонажа]\n${charData.description}\n\n`;
        if (charData.personality) characterDefinition += `[Личность]\n${charData.personality}\n\n`;
        if (charData.scenario) characterDefinition += `[Сценарий]\n${charData.scenario}\n\n`;
        if (charData.mes_example) characterDefinition += `[Пример диалога]\n${charData.mes_example}\n\n`;

        // Start building the final system prompt
        let systemContent = `${characterDefinition.trim()}\n\n${dateTimeInfo}`;

        if (memory) {
            systemContent += `\n\n[Память нейросети (глобальные заметки)]:\n${memory}`;
        }

        // Add character's specific system_prompt if it exists
        if (charData.system_prompt) {
            systemContent += `\n\n[Дополнительные системные инструкции]\n${charData.system_prompt}`;
        }

        // Check lorebook entries against the user's message
        if (charData.lorebook && charData.lorebook.length > 0 && userMessage) {
            const triggeredEntries = charData.lorebook.filter(entry =>
                entry.triggers && entry.triggers.some(trigger => userMessage.toLowerCase().includes(trigger.toLowerCase().trim()))
            );
            if (triggeredEntries.length > 0) {
                const loreInfo = triggeredEntries.map(entry => {
                    let entryPrefix = "- ";
                    if (entry.entryName) {
                        entryPrefix = `- [${entry.entryName}]: `;
                    }
                    return `${entryPrefix}${entry.info}`;
                }).join("\n");
                systemContent += `\n\n[Информация из Lorebook (активировано триггерами в последнем сообщении пользователя)]:\n${loreInfo}`;
            }
        }
        return systemContent.trim();
    }


    async function sendToRestApi(userMessageContent, attachmentsArray = null) {
        if (!restApiUrlValue) {
            appendNewMessageToDOM({sender:"Система", content:"URL REST API не настроен.", role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"}, allMessages.length);
            return;
        }
        setStatusActive(true);
        const apiPlaceholderAvatar = "https://placehold.co/80x80/80D0C0/FFFFFF?text=A";
        const placeholderMsgData = {sender:"API", content:"Отправка запроса на REST API...", role:"api", avatar: apiPlaceholderAvatar, attachments: attachmentsArray};
        allMessages.push(placeholderMsgData);
        appendNewMessageToDOM(placeholderMsgData, allMessages.length -1);


        try {
            const requestBody = { message: userMessageContent, attachments: attachmentsArray };
            const response = await fetch(restApiUrlValue, {
                method: "POST",
                headers: { "Content-Type": "application/json", ...restApiHeadersValue },
                body: JSON.stringify(requestBody)
            });

            const placeholderIndex = allMessages.findIndex(m => m.content === "Отправка запроса на REST API..." && m.sender === "API");
            if (placeholderIndex > -1) {
                allMessages.splice(placeholderIndex, 1);
                removeMessageFromDOM(placeholderIndex);
            }


            const responseData = await response.json();
            if (!response.ok) throw new Error(`API Ошибка: ${response.status} - ${responseData.error || JSON.stringify(responseData)}`);

            let apiReplyText = responseData.reply || responseData.message || JSON.stringify(responseData.data) || JSON.stringify(responseData);
            const apiReplyMsgData = {sender:"API", content:apiReplyText, role:"api", avatar: apiPlaceholderAvatar, attachments: responseData.attachments};
            allMessages.push(apiReplyMsgData);
            appendNewMessageToDOM(apiReplyMsgData, allMessages.length - 1);


        } catch (error) {
            console.error("REST API Ошибка:", error);
            const placeholderIndexOnError = allMessages.findIndex(m => m.content === "Отправка запроса на REST API..." && m.sender === "API");
            if (placeholderIndexOnError > -1) {
                 allMessages.splice(placeholderIndexOnError, 1);
                removeMessageFromDOM(placeholderIndexOnError);
            }
            const errorMsgData = {sender:"Система", content:`Ошибка REST API: ${error.message}`, role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"};
            allMessages.push(errorMsgData);
            appendNewMessageToDOM(errorMsgData, allMessages.length - 1);

        } finally {
            setStatusActive(false);
            scrollToBottom(true);
            userInput.focus();
        }
    }
    function setupRestApiSwitch() {
        const enableRestApiCheckbox = document.getElementById("enableRestApi");
        enableRestApiCheckbox.addEventListener("change", () => {
            useRestApi = enableRestApiCheckbox.checked;
            saveToStorage(ENABLE_REST_API_STORAGE, useRestApi.toString());
        });
    }

    async function respondToLastMessage(characterName) {
      if (isBotGenerating) return;
      isBotGenerating = true;
      updateRegenerateButtonsState(true);

      const currentGroupMessages = [...allMessages];
      if (currentGroupMessages.length === 0) {
          showCustomAlert("Нет сообщений для ответа.");
          isBotGenerating = false; updateRegenerateButtonsState(false); return;
      }
      if (!characters[characterName]) {
          showCustomAlert(`Персонаж "${characterName}" не найден.`);
          isBotGenerating = false; updateRegenerateButtonsState(false); return;
      }

      const charData = characters[characterName];
      let lastUserMessageForContext = "";
      let lastUserMessageAttachments = null;
      for (let i = currentGroupMessages.length -1; i >= 0; i--) {
          if ((currentGroupMessages[i].sender === "Вы" || currentGroupMessages[i].role === "user")) {
              lastUserMessageForContext = currentGroupMessages[i].content;
              lastUserMessageAttachments = currentGroupMessages[i].attachments;
              break;
          }
      }

      const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
      const max_tokens = parseInt(document.getElementById("maxTokens").value) || 1024;
      const systemPromptText = getSystemContent(charData, lastUserMessageForContext);


      if (useGoogleApi && googleApiKey && googleApiModel) {
        let geminiContents = [];
        currentGroupMessages.forEach(m => {
            let role = (m.sender === "Вы" || m.role === "user") ? "user" : "model";
            let textContent = (m.sender !== "Вы" && m.role !== "user" && m.sender) ? `${m.sender}: ${m.content}` : m.content;

            let parts = [];
            if (textContent) parts.push({ text: textContent });
            if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                 m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                    parts.push({ inlineData: { mimeType: att.type, data: att.src.split(',')[1] } });
                 });
            } else if (m.attachments) {
                parts.push({ text: `[Прикреплено ${m.attachments.length} файлов]` });
            }

            if (parts.length > 0) {
                 if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                     console.warn("Consecutive roles for Gemini (respondToLast), appending parts:", role);
                     geminiContents[geminiContents.length - 1].parts.push(...parts);
                 } else {
                    geminiContents.push({ role: role, parts: parts });
                 }
            }
        });
        let lastValidRoleGroup = null;
        geminiContents = geminiContents.filter(item => {
            if (item.role === lastValidRoleGroup) return false;
            lastValidRoleGroup = item.role;
            return true;
        });

        await fetchGeminiChatCompletion(
            googleApiKey, googleApiModel, systemPromptText, geminiContents,
            temperature, max_tokens, characterName, allMessages, charData.avatarCharacter
        );

      } else {
        const model = charData.model || document.getElementById("model").value;
        const apiKey = document.getElementById("apiKey").value;
        const apiUrl = document.getElementById("apiUrl").value;
        const messagesForAPI = [
          { role: "system", content: systemPromptText },
          ...currentGroupMessages.map(m => {
              let apiContentArray = [];
              if (m.content) apiContentArray.push({ type: "text", text: m.content });
              if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                   m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                        apiContentArray.push({ type: "image_url", image_url: { url: att.src } });
                   });
              } else if (m.attachments) {
                  apiContentArray.push({ type: "text", text: ` [Прикреплено ${m.attachments.length} файлов]` });
              }

              const finalContent = apiContentArray.length === 1 && apiContentArray[0].type === "text" ? apiContentArray[0].text : apiContentArray;
              return {
                  role: (m.sender === "Вы" || m.role === "user") ? "user" : "assistant",
                  content: (m.sender !== "Вы" && m.role !== "user" && m.sender) ? `${m.sender}: ${finalContent}` : finalContent
              }
          })
        ];
        await fetchChatCompletion(apiUrl, apiKey, model, messagesForAPI, temperature, max_tokens, characterName, allMessages, charData.avatarCharacter);
      }
    }


    async function sendMessage() {
        if (isBotGenerating && !useRestApi && !(useGoogleApi && googleApiKey && googleApiModel) ) {
            return;
        }

        const messageContent = userInput.value.trim();
        if (!messageContent && attachedFiles.length === 0) return;

        clearVariants();
        const originalPlaceholder = userInput.placeholder;
        userInput.value = "";
        userInput.placeholder = "Отправка...";
        userInput.disabled = true;
        userInput.style.height = 'auto';
        userInput.style.height = (userInput.scrollHeight) + 'px';


        let userAvatarUrl;
        let activeCharNameForUserMsg = getCurrentCharacterName();
        let attachmentsDataArray = [];

        if (attachedFiles.length > 0) {
            for (const file of attachedFiles) {
                 attachmentsDataArray.push({
                    name: file.name,
                    type: file.type,
                    src: await readFileAsDataURL(file)
                });
            }
        }

        const userMsgObject = {
            role: "user",
            content: messageContent,
            attachments: attachmentsDataArray.length > 0 ? attachmentsDataArray : null
        };

        if (currentMode === "personal") {
            if (!activeCharNameForUserMsg) {
                showCustomAlert("Выберите персонажа для отправки сообщения.");
                userInput.placeholder = originalPlaceholder; userInput.disabled = false; userInput.focus(); return;
            }
            userAvatarUrl = characters[activeCharNameForUserMsg]?.avatarUser || "https://placehold.co/80x80/7AC5FF/FFFFFF?text=Вы";
            userMsgObject.avatar = userAvatarUrl;
            allMessages.push(userMsgObject);
            saveChat(activeCharNameForUserMsg, allMessages);
        } else {
            const anyUserAvatar = Object.values(characters).find(c => c.avatarUser)?.avatarUser;
            userAvatarUrl = anyUserAvatar || "https://placehold.co/80x80/7AC5FF/FFFFFF?text=Вы";
            userMsgObject.sender = "Вы";
            userMsgObject.avatar = userAvatarUrl;
            allMessages.push(userMsgObject);
            saveRoomChat(allMessages);
        }

        appendNewMessageToDOM(userMsgObject, allMessages.length - 1);
        shouldScrollToBottom = true;

        attachedFiles = [];
        renderFilePreviews();
        document.getElementById("fileInput").value = "";

        const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
        const max_tokens = parseInt(document.getElementById("maxTokens").value) || 1024;

        let charToRespondName, charDataForApi, systemContextMsgForLLM;
        if (currentMode === "personal") {
            charToRespondName = activeCharNameForUserMsg;
            charDataForApi = characters[charToRespondName];
            systemContextMsgForLLM = messageContent;
        } else {
            let lastBotSender = null;
            for (let i = allMessages.length - 2; i >= 0; i--) {
                if (allMessages[i].role === 'assistant' && allMessages[i].sender && characters[allMessages[i].sender]) {
                    lastBotSender = allMessages[i].sender; break;
                }
            }
            charToRespondName = lastBotSender || (Object.keys(characters).length > 0 ? Object.keys(characters)[0] : null);
            if (!charToRespondName || !characters[charToRespondName]) {
                const sysMsg = {sender:"Система", content:"Не удалось определить персонажа для ответа в группе.", role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"};
                allMessages.push(sysMsg); appendNewMessageToDOM(sysMsg, allMessages.length - 1);
                userInput.placeholder = originalPlaceholder; userInput.disabled = false; userInput.focus(); return;
            }
            charDataForApi = characters[charToRespondName];
            systemContextMsgForLLM = messageContent;
        }

        const systemPromptText = getSystemContent(charDataForApi, systemContextMsgForLLM);

        if (useGoogleApi && googleApiKey && googleApiModel) {
            isBotGenerating = true;
            updateRegenerateButtonsState(true);
            setStatusActive(true);
            shouldScrollToBottom = true;

            let geminiContents = [];
            allMessages.forEach(m => {
                let role = (m.sender === "Вы" || m.role === "user") ? "user" : "model";
                let textContent = (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${m.content}` : m.content;

                let parts = [];
                if (textContent) parts.push({ text: textContent });
                if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                     m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                        parts.push({ inlineData: { mimeType: att.type, data: att.src.split(',')[1] } });
                     });
                } else if (m.attachments) {
                    parts.push({ text: `[Прикреплено ${m.attachments.length} файлов]` });
                }


                if (parts.length > 0) {
                    if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                        console.warn("Consecutive roles for Gemini (send), appending parts:", role);
                         geminiContents[geminiContents.length - 1].parts.push(...parts);
                    } else {
                        geminiContents.push({ role: role, parts: parts });
                    }
                }
            });
            let lastValidRoleSend = null;
            geminiContents = geminiContents.filter(item => {
                if (item.role === lastValidRoleSend) return false;
                lastValidRoleSend = item.role;
                return true;
            });


            await fetchGeminiChatCompletion(
                googleApiKey, googleApiModel, systemPromptText, geminiContents,
                temperature, max_tokens, charToRespondName, allMessages, charDataForApi.avatarCharacter
            );


        } else if (useRestApi && restApiUrlValue) {
            shouldScrollToBottom = true;
            await sendToRestApi(messageContent, attachmentsDataArray);
        } else {
            isBotGenerating = true;
            updateRegenerateButtonsState(true);
            setStatusActive(true);
            shouldScrollToBottom = true;

            let messagesForAPI = [{ role: "system", content: systemPromptText }];
            messagesForAPI.push(...allMessages.map(m => {
                let apiMsgContentArray = [];
                if (m.content) apiMsgContentArray.push({ type: "text", text: m.content });
                if (m.attachments && m.attachments.some(att => att.type.startsWith('image/') && att.src.startsWith('data:image'))) {
                     m.attachments.filter(att => att.type.startsWith('image/') && att.src.startsWith('data:image')).forEach(att => {
                        apiMsgContentArray.push({ type: "image_url", image_url: { url: att.src } });
                     });
                } else if (m.attachments) {
                    apiMsgContentArray.push({ type: "text", text: `[Прикреплено ${m.attachments.length} файлов]` });
                }

                const finalContent = apiMsgContentArray.length === 1 && apiMsgContentArray[0].type === "text" ? apiMsgContentArray[0].text : apiMsgContentArray;
                return {
                    role: (m.sender === "Вы" || m.role === "user") ? "user" : "assistant",
                    content: (m.sender !== "Вы" && m.role !== "user" && m.sender && currentMode === 'group') ? `${m.sender}: ${finalContent}` : finalContent
                };
            }));

            const apiKey = document.getElementById("apiKey").value;
            const apiUrl = document.getElementById("apiUrl").value;
            const modelForApi = charDataForApi.model || document.getElementById("model").value;

            await fetchChatCompletion(apiUrl, apiKey, modelForApi, messagesForAPI, temperature, max_tokens, charToRespondName, allMessages, charDataForApi.avatarCharacter);
        }
        userInput.placeholder = originalPlaceholder; userInput.disabled = false;
        userInput.focus(); // Keep focus on the input field
    }

    async function fetchGeminiChatCompletion(gApiKey, gModel, systemInstructionText, geminiContents, temperature, maxOutputTokens, apiCharacterName, chatArrayToUpdateRef, botAvatarUrl, isAfterEdit = false) {
        const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${gModel}:generateContent?key=${gApiKey}`;

        const requestBody = {
            systemInstruction: { parts: [{ text: systemInstructionText }] },
            contents: geminiContents,
            generationConfig: {
                temperature: temperature,
                maxOutputTokens: maxOutputTokens
            }
        };

        setStatusActive(true);

        const placeholderMsgData = { content: "...", role: "assistant", avatar: botAvatarUrl, attachments: null };
        if (currentMode === "group") {
            placeholderMsgData.sender = apiCharacterName;
        }

        let placeholderIndex = -1;
        if (!isAfterEdit) {
            chatArrayToUpdateRef.push(placeholderMsgData);
            placeholderIndex = chatArrayToUpdateRef.length - 1;
            appendNewMessageToDOM(placeholderMsgData, placeholderIndex);
        } else {
             chatArrayToUpdateRef.push(placeholderMsgData);
             placeholderIndex = chatArrayToUpdateRef.length - 1;
             appendNewMessageToDOM(placeholderMsgData, placeholderIndex);
        }


        try {
            const response = await fetch(geminiApiUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`Google API Ошибка: ${response.status} - ${errorBody}`);
            }
            const result = await response.json();
            const reply = result.candidates?.[0]?.content?.parts?.[0]?.text || "";

            if (!reply && !(result.candidates && result.candidates[0].finishReason === "MAX_TOKENS")) {
                 throw new Error("Пустой ответ от Google API или неожиданный формат.");
            }

            chatArrayToUpdateRef[placeholderIndex].content = reply;
            chatArrayToUpdateRef[placeholderIndex].attachments = null;
            if (currentMode === "group") {
                 chatArrayToUpdateRef[placeholderIndex].sender = apiCharacterName;
            }

            updateMessageInDOM(placeholderIndex, chatArrayToUpdateRef[placeholderIndex]);
            scrollToBottom(true);
            shouldScrollToBottom = false;

            if (currentMode === "personal") saveChat(getCurrentCharacterName(), chatArrayToUpdateRef);
            else saveRoomChat(chatArrayToUpdateRef);

        } catch (err) {
            console.error("fetchGeminiChatCompletion Ошибка:", err);
            if (chatArrayToUpdateRef[placeholderIndex] && chatArrayToUpdateRef[placeholderIndex].content === "...") {
                chatArrayToUpdateRef.splice(placeholderIndex, 1);
                removeMessageFromDOM(placeholderIndex);
            }
            const errorMsgData = {sender:"Система", content:`Ошибка Google Gemini API: ${err.message}`, role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"};
            chatArrayToUpdateRef.push(errorMsgData);
            appendNewMessageToDOM(errorMsgData, chatArrayToUpdateRef.length - 1);
        } finally {
            setStatusActive(false);
            isBotGenerating = false;
            updateRegenerateButtonsState(false);
            if (shouldScrollToBottom) { scrollToBottom(true); shouldScrollToBottom = false; }
            userInput.focus();
        }
    }


    async function fetchChatCompletion(apiUrl, apiKey, model, messagesForAPI, temperature, max_tokens, apiCharacterName, chatArrayToUpdateRef, botAvatarUrl, isAfterEdit = false) {
      const requestBody = { model, messages: messagesForAPI, stream: true, max_tokens, temperature };
      setStatusActive(true);
      shouldScrollToBottom = true;

      const placeholderMsgData = { content: "...", role: "assistant", avatar: botAvatarUrl, attachments: null };
      if (currentMode === "group") {
          placeholderMsgData.sender = apiCharacterName;
      }

      chatArrayToUpdateRef.push(placeholderMsgData);
      const placeholderIndex = chatArrayToUpdateRef.length - 1;
      appendNewMessageToDOM(placeholderMsgData, placeholderIndex);

      try {
        const response = await fetch(apiUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Authorization": `Bearer ${apiKey}` },
          body: JSON.stringify(requestBody)
        });
        if (!response.ok) throw new Error(`HTTP ошибка! Статус: ${response.status} ${await response.text()}`);

        const reader = response.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let reply = "", streamedContent = "";

        const streamingMessageContainer = messagesBox.querySelector(`.message-container[data-index="${placeholderIndex}"]`);
        const streamingMessageDiv = streamingMessageContainer?.querySelector(".message");


        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value);
          const lines = chunk.split("\n").filter(line => line.trim().startsWith("data: "));
          for (const line of lines) {
            if (line.includes("[DONE]")) break;
            const jsonString = line.replace(/^data: /, "");
            try {
              const parsed = JSON.parse(jsonString);
              const content = parsed.choices?.[0]?.delta?.content;
              if (content) {
                streamedContent += content;
                reply = removeThoughts(streamedContent);
                if (streamingMessageDiv) {
                  streamingMessageDiv.innerHTML = `<strong>${apiCharacterName}:</strong>${marked.parse(reply)}`;
                  scrollToBottom(true);
                }
              }
            } catch (e) { /* console.warn("Stream parsing error:", e, jsonString); */ }
          }
        }
        if (!reply && streamedContent) reply = removeThoughts(streamedContent);

        chatArrayToUpdateRef[placeholderIndex].content = reply;
        chatArrayToUpdateRef[placeholderIndex].attachments = null;
        if (currentMode === "group") {
            chatArrayToUpdateRef[placeholderIndex].sender = apiCharacterName;
        }

        if (!streamingMessageDiv) {
            updateMessageInDOM(placeholderIndex, chatArrayToUpdateRef[placeholderIndex]);
        }

        if (currentMode === "personal") saveChat(getCurrentCharacterName(), chatArrayToUpdateRef);
        else saveRoomChat(chatArrayToUpdateRef);


      } catch (err) {
        console.error("fetchChatCompletion Ошибка:", err);
        if (chatArrayToUpdateRef[placeholderIndex] && chatArrayToUpdateRef[placeholderIndex].content === "...") {
            chatArrayToUpdateRef.splice(placeholderIndex, 1);
            removeMessageFromDOM(placeholderIndex);
        }
        const errorMsgData = {sender:"Система", content:`Ошибка LLM: ${err.message}`, role:"system", avatar:"https://placehold.co/80x80/CCCCCC/FFFFFF?text=S"};
        chatArrayToUpdateRef.push(errorMsgData);
        appendNewMessageToDOM(errorMsgData, chatArrayToUpdateRef.length - 1);

      } finally {
        setStatusActive(false);
        isBotGenerating = false;
        updateRegenerateButtonsState(false);
        if (shouldScrollToBottom) { scrollToBottom(true); shouldScrollToBottom = false; }
      }
    }


    function removeThoughts(text) { return text.replace(/<think>[\s\S]*?<\/think>/g, '').trim(); }

    function clearMessages() {
      showCustomConfirm("Вы уверены, что хотите очистить текущий чат? Это действие нельзя отменить.", () => {
        let initialMessages = [];
        if (currentMode === "personal") {
          const name = getCurrentCharacterName();
          if (!name) return;
          const charData = characters[name];
          if (charData && charData.welcomeMessage) {
              initialMessages.push({ role: "assistant", content: charData.welcomeMessage, avatar: charData.avatarCharacter, attachments: null });
          }
          saveChat(name, initialMessages);
        } else {
          saveRoomChat(initialMessages);
        }
        shouldScrollToBottom = true;
        loadAndRenderMessages();
        clearVariants();
      });
    }

    function exportCharacterData() {
      const name = getCurrentCharacterName();
      if (!name || !characters[name]) return showCustomAlert("Выберите персонажа для экспорта.");

      const charData = characters[name];
      const chatHistory = loadChat(name);

      const dataToExport = {
        spec: "chara_card_v2",
        spec_version: "2.0",
        data: {
            name: charData.name || "",
            description: charData.description || "",
            personality: charData.personality || "",
            scenario: charData.scenario || "",
            first_mes: charData.welcomeMessage || "",
            mes_example: charData.mes_example || "",
            creator_notes: charData.creator_notes || "",
            system_prompt: charData.system_prompt || "",
            post_history_instructions: charData.post_history_instructions || "",
            alternate_greetings: charData.alternate_greetings || [],
            tags: [], // Tags not implemented in UI yet
            creator: "", // Creator not implemented in UI yet
            character_version: "", // Version not implemented in UI yet
            avatar: "none", // Placeholder, actual avatar is in our app's format
            extensions: {}
        }
      };

      const fullExportData = {
          character: charData,
          messages: chatHistory,
          version: "2.0",
          format: "llm_chatbot_rp_v3_full",
          tavern_card: dataToExport
      };

      const blob = new Blob([JSON.stringify(fullExportData, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = `${name}_персонаж_и_чат.json`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showCustomAlert(`Данные персонажа "${name}" и история чата экспортированы.`);
    }

    function importCharacterData() { document.getElementById("jsonFileInput").click(); }

    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const importedJson = JSON.parse(e.target.result);
          let charDataToProcess;

          // Check for our app's full format first
          if (importedJson.format === "llm_chatbot_rp_v3_full" && importedJson.character) {
              console.log("Importing llm_chatbot_rp_v3_full format");
              charDataToProcess = {
                  character: importedJson.character,
                  messages: importedJson.messages || [],
              };
          }
          // Then check for standard TavernAI/Chub format
          else if (importedJson.spec === "chara_card_v2" && importedJson.data) {
            console.log("Importing chara_card_v2 format");
            const tavernData = importedJson.data;
            charDataToProcess = {
              character: {
                name: tavernData.name || "Безымянный",
                description: tavernData.description || "",
                personality: tavernData.personality || "",
                scenario: tavernData.scenario || "",
                mes_example: tavernData.mes_example || "",
                welcomeMessage: tavernData.first_mes || "",
                alternate_greetings: tavernData.alternate_greetings || [],
                system_prompt: tavernData.system_prompt || "",
                post_history_instructions: tavernData.post_history_instructions || "",
                creator_notes: tavernData.creator_notes || "",
                avatarCharacter: tavernData.avatar || "https://placehold.co/100x100/FF7AAC/FFFFFF?text=Бот", // Use TavernAI avatar or default
                avatarUser: document.getElementById("avatarUrl_user").value || "https://placehold.co/100x100/7AC5FF/FFFFFF?text=Вы",
                model: document.getElementById("characterModel").value || document.getElementById("model").value,
                lorebook: [],
              },
              messages: [],
              _tavernData: tavernData // Keep original data for reference
            };

            if (tavernData.character_book && tavernData.character_book.entries) {
                charDataToProcess.character.lorebook = tavernData.character_book.entries.map(entry => ({
                    entryName: entry.name || "",
                    triggers: entry.keys || [],
                    info: entry.content || ""
                })).filter(lbEntry => (lbEntry.triggers.length > 0 && lbEntry.info) || lbEntry.entryName);
            }
          } else {
            throw new Error("Неподдерживаемый или неверный формат файла JSON.");
          }

          tempImportedCharacterData = charDataToProcess;

          if (charDataToProcess._tavernData) {
            const greetings = [];
            if (charDataToProcess._tavernData.first_mes) greetings.push(charDataToProcess._tavernData.first_mes);
            if (charDataToProcess._tavernData.alternate_greetings && charDataToProcess._tavernData.alternate_greetings.length > 0) {
                greetings.push(...charDataToProcess._tavernData.alternate_greetings);
            }

            if (greetings.length > 1) {
                openGreetingModal(charDataToProcess.character.name, greetings); return;
            } else if (greetings.length === 1) {
                charDataToProcess.character.welcomeMessage = greetings[0];
            }
          }
          finalizeImport(charDataToProcess);

        } catch (err) {
          showCustomAlert(`Ошибка импорта файла: ${err.message}`); console.error("Ошибка импорта:", err);
          tempImportedCharacterData = null;
        } finally {
            event.target.value = null;
        }
      };
      reader.readAsText(file);
    }

    function finalizeImport(dataToImport) {
        if (!dataToImport || !dataToImport.character) {
            console.error("Данные для импорта неполные.");
            showCustomAlert("Ошибка: не удалось завершить импорт, данные неполные.");
            return;
        }
        const charData = dataToImport.character;
        const charName = charData.name;

        // Ensure all fields exist on the object to prevent errors
        const fullCharData = {
          name: charName,
          description: charData.description || "",
          personality: charData.personality || "",
          scenario: charData.scenario || "",
          mes_example: charData.mes_example || "",
          welcomeMessage: charData.welcomeMessage || "",
          alternate_greetings: charData.alternate_greetings || [],
          system_prompt: charData.system_prompt || "",
          post_history_instructions: charData.post_history_instructions || "",
          creator_notes: charData.creator_notes || "",
          model: charData.model || document.getElementById("model").value,
          avatarCharacter: charData.avatarCharacter || "https://placehold.co/100x100/FF7AAC/FFFFFF?text=Бот",
          avatarUser: charData.avatarUser || document.getElementById("avatarUrl_user").value || "https://placehold.co/100x100/7AC5FF/FFFFFF?text=Вы",
          lorebook: charData.lorebook || [],
          backgroundImage: charData.backgroundImage || null
        };

        characters[charName] = fullCharData;
        saveChat(charName, dataToImport.messages || []);
        localStorage.setItem("characters_v3", JSON.stringify(characters));

        populateCharacterSelect();
        setActiveCharacter(charName);
        document.getElementById("characterSelect").value = charName;

        showCustomAlert(`Персонаж "${charName}" успешно импортирован!`);
        closeSettingsModal();
        tempImportedCharacterData = null;
    }


    function setupFileAttach() {
        const hiddenFileInput = document.getElementById("fileInput");
        if(hiddenFileInput) {
            hiddenFileInput.addEventListener("change", (event) => {
                if (event.target.files.length > 0) {
                    Array.from(event.target.files).forEach(file => attachedFiles.push(file));
                    renderFilePreviews();
                    userInput.placeholder = `${attachedFiles.length} файл(ов) прикреплено. Введите текст или отправьте.`;
                }
                event.target.value = null;
            });
        }
    }

    function renderFilePreviews() {
        filePreviewsContainer.innerHTML = "";
        if (attachedFiles.length === 0) {
            filePreviewsContainer.style.display = "none";
            if (!userInput.value.trim()) {
                 userInput.placeholder = "Введите сообщение...";
            }
            return;
        }
        filePreviewsContainer.style.display = "flex";

        attachedFiles.forEach((file, index) => {
            const previewItem = document.createElement('div');
            previewItem.className = 'file-preview-item';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-file-btn';
            removeBtn.innerHTML = '&times;';
            removeBtn.title = 'Удалить файл';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                attachedFiles.splice(index, 1);
                renderFilePreviews();
                 if (attachedFiles.length > 0) {
                    userInput.placeholder = `${attachedFiles.length} файл(ов) прикреплено. Введите текст или отправьте.`;
                } else if (!userInput.value.trim()) {
                     userInput.placeholder = "Введите сообщение...";
                }
            };
            previewItem.appendChild(removeBtn);

            if (file.type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = URL.createObjectURL(file);
                img.onload = () => URL.revokeObjectURL(img.src);
                previewItem.appendChild(img);
            } else {
                const icon = document.createElement('div');
                icon.className = 'file-icon-placeholder';
                icon.textContent = '📄';
                previewItem.appendChild(icon);
            }
            const fileName = document.createElement('div');
            fileName.className = 'file-info';
            fileName.textContent = file.name;
            fileName.title = file.name;
            previewItem.appendChild(fileName);

            filePreviewsContainer.appendChild(previewItem);
        });
    }


    function readFileAsDataURL(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }


    function renderLorebookEntries(characterName) {
      const container = document.getElementById("lorebookEntries");
      container.innerHTML = "";
      const character = characters[characterName];
      if (!character || !character.lorebook || character.lorebook.length === 0) {
        container.innerHTML = "<p style='font-style:italic; opacity:0.7;'>Записей нет.</p>"; return;
      }
      character.lorebook.forEach((entry, index) => {
        const entryDiv = document.createElement("div");
        entryDiv.className = "lorebook-entry";
        entryDiv.innerHTML = `
          <div>
            <label for="lore-entryName-${index}">Название записи (Имя):</label>
            <input type="text" id="lore-entryName-${index}" value="${entry.entryName || ""}" data-index="${index}" oninput="updateLorebookField(${index}, 'entryName', this.value)" />
          </div>
          <div>
            <label for="lore-triggers-${index}">Ключевые слова (через запятую):</label>
            <input type="text" id="lore-triggers-${index}" value="${(entry.triggers || []).join(', ')}" data-index="${index}" oninput="updateLorebookField(${index}, 'triggers', this.value)" />
          </div>
          <div>
            <label for="lore-info-${index}">Информация:</label>
            <textarea id="lore-info-${index}" data-index="${index}" oninput="updateLorebookField(${index}, 'info', this.value)">${entry.info || ""}</textarea>
          </div>
          <button type="button" onclick="deleteLorebookEntry(${index})" style="background: #ffcdd2; color:#5f2120; font-size:0.9rem; padding: 0.5rem 0.8rem;">Удалить запись</button>
        `;
        container.appendChild(entryDiv);
      });
    }

    function updateLorebookField(index, field, value) {
        const charName = getCurrentCharacterName();
        if (!charName || !characters[charName] || !characters[charName].lorebook[index]) return;

        if (field === 'entryName') {
            characters[charName].lorebook[index].entryName = value.trim();
        } else if (field === 'triggers') {
            characters[charName].lorebook[index].triggers = value.split(',').map(t => t.trim()).filter(t => t);
        } else if (field === 'info') {
            characters[charName].lorebook[index].info = value.trim();
        }
        localStorage.setItem("characters_v2", JSON.stringify(characters));
    }

    function addLorebookEntry() {
      const charName = getCurrentCharacterName();
      if (!charName || !characters[charName]) return showCustomAlert("Сначала выберите персонажа.");
      characters[charName].lorebook = characters[charName].lorebook || [];
      characters[charName].lorebook.push({ entryName: "", triggers: [], info: "" }); // Add new empty entry with entryName
      localStorage.setItem("characters_v2", JSON.stringify(characters));
      renderLorebookEntries(charName);
    }

    function deleteLorebookEntry(index) {
      const charName = getCurrentCharacterName();
      if (!charName || !characters[charName] || !characters[charName].lorebook) return;
      showCustomConfirm("Удалить эту запись из Lorebook?", () => {
        characters[charName].lorebook.splice(index, 1);
        localStorage.setItem("characters_v2", JSON.stringify(characters));
        renderLorebookEntries(charName);
      });
    }

    function uploadBackground() {
      const name = getCurrentCharacterName(); // Get current character
      if (!name || !characters[name]) return showCustomAlert("Персонаж не найден.");
      const fileInput = document.getElementById("backgroundFileInput");
      const file = fileInput.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          characters[name].backgroundImage = e.target.result; // Store as dataURL
          localStorage.setItem("characters_v2", JSON.stringify(characters)); // Save
          applyBackground(name); // Apply immediately
          closeBackgroundModal(); // Close modal
        };
        reader.readAsDataURL(file);
      } else {
        showCustomAlert("Пожалуйста, выберите файл изображения.");
      }
      fileInput.value = ""; // Reset file input
    }
    function deleteBackground() {
      const name = getCurrentCharacterName();
      if (!name || !characters[name]) return showCustomAlert("Персонаж не найден.");
      delete characters[name].backgroundImage; // Remove property
      localStorage.setItem("characters_v2", JSON.stringify(characters)); // Save
      applyBackground(name); // Re-apply (will remove background)
      closeBackgroundModal();
    }

    function applyBackground(characterName) {
      const messagesDiv = document.querySelector('.messages');
      const chatContainerDiv = document.getElementById('chatContainer');
      const inputAreaContainer = document.querySelector('.input-area-container');

      if (!messagesDiv || !chatContainerDiv || !inputAreaContainer) return;

      const character = characterName ? characters[characterName] : null;
      const backgroundImage = character?.backgroundImage;

      if (backgroundImage && currentMode === "personal") {
        chatContainerDiv.style.backgroundImage = `url(${backgroundImage})`;
        chatContainerDiv.style.backgroundSize = 'cover';
        chatContainerDiv.style.backgroundPosition = 'center';
        chatContainerDiv.style.backgroundRepeat = 'no-repeat';
        chatContainerDiv.classList.add('chat-container-custom-bg'); // Add class to adjust padding

        messagesDiv.classList.add('has-custom-background');
        inputAreaContainer.classList.add('has-custom-background-too');
      } else {
        chatContainerDiv.style.backgroundImage = 'none';
        chatContainerDiv.classList.remove('chat-container-custom-bg'); // Remove class to revert padding

        messagesDiv.classList.remove('has-custom-background');
        inputAreaContainer.classList.remove('has-custom-background-too');
      }
    }


    function setupAvatarClickHandler() {
      document.addEventListener('click', function(e) {
        const targetElement = e.target;
        // Check if clicked on an avatar in a message, or an attached image in a message, or an image in file preview
        if (targetElement.classList.contains('avatar')) {
          const avatarSrc = targetElement.src;
          previewImage(avatarSrc);
        }
        else if (targetElement.classList.contains('attached-image')) { // Image inside a message bubble
          const imageSrc = targetElement.src;
          previewImage(imageSrc);
        }
        else if (targetElement.tagName === 'IMG' && targetElement.closest('.file-preview-item')) { // Image in the file preview area before sending
             const imageSrc = targetElement.src;
             previewImage(imageSrc);
        }
      });
    }

    function previewImage(src) {
        // Remove existing modal if any
        const existingModal = document.querySelector('.avatar-preview-modal');
        if (existingModal) document.body.removeChild(existingModal);

        const modal = document.createElement('div');
        modal.className = 'avatar-preview-modal';
        // Basic styling for the modal (overlay)
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.background = 'rgba(0,0,0,0.8)'; // Dark overlay
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.style.zIndex = '2000'; // High z-index to be on top
        modal.style.cursor = 'zoom-out'; // Indicate it can be closed by clicking
        // Image styling within the modal
        modal.innerHTML = `
            <img src="${src}" style="max-width:90vw; max-height:90vh; object-fit:contain; border-radius: 8px; box-shadow: 0 5px 25px rgba(0,0,0,0.5);" />
        `;
        // Close modal on click
        modal.addEventListener('click', () => document.body.removeChild(modal));
        document.body.appendChild(modal);
    }


    function setupScrollHandler() {
      messagesBox.addEventListener("scroll", () => {
        // If user scrolls up, disable auto-scroll to bottom
        const nearBottom = messagesBox.scrollTop + messagesBox.clientHeight >= messagesBox.scrollHeight - 100;
        if (!nearBottom) {
            shouldScrollToBottom = false; // User has scrolled away from the bottom
        }
        // Auto-scroll is re-enabled when a new message is sent or bot responds (by setting shouldScrollToBottom = true)
      });
    }

    function showCustomAlert(message) {
        const messageBox = document.createElement('div');
        messageBox.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--accent-color);
            color: white;
            padding: 15px 25px;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 15px rgba(var(--accent-color-rgb), 0.3);
            z-index: 3000;
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            text-align: center;
        `;
        messageBox.textContent = message;
        document.body.appendChild(messageBox);
        setTimeout(() => {
            messageBox.style.opacity = 1;
        }, 10); // Small delay to trigger transition
        setTimeout(() => {
            messageBox.style.opacity = 0;
            messageBox.addEventListener('transitionend', () => messageBox.remove());
        }, 2000); // Disappear after 2 seconds
    }

    function showCustomConfirm(message, onConfirm) {
        const confirmBox = document.createElement('div');
        confirmBox.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-bg);
            color: var(--text-color);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            z-index: 3000;
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 350px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        `;
        confirmBox.innerHTML = `
            <p>${message}</p>
            <div style="display: flex; justify-content: center; gap: 10px;">
                <button id="confirmYes" class="send-button" style="margin:0;">Да</button>
                <button id="confirmNo" class="send-button" style="background: var(--participant-bg); color:var(--text-color); margin:0;">Нет</button>
            </div>
        `;
        document.body.appendChild(confirmBox);
        setTimeout(() => {
            confirmBox.style.opacity = 1;
        }, 10);

        document.getElementById('confirmYes').onclick = () => {
            onConfirm();
            confirmBox.remove();
        };
        document.getElementById('confirmNo').onclick = () => {
            confirmBox.remove();
        };
    }


    function setStatusActive(active) {
      const currentStatusIndicator = document.getElementById("messages-status-indicator");
      // The mobile prefix container and its cloned indicator might not always exist if the DOM structure changes.
      // It's safer to query for it within the mobile prefix div if it's consistently there.
      const mobilePrefixDiv = mainInputRow.querySelector('.mobile-input-prefix');
      const clonedStatusIndicator = mobilePrefixDiv ? mobilePrefixDiv.querySelector('#messages-status-indicator') : null;


      if (currentStatusIndicator) {
        currentStatusIndicator.classList.toggle("active", active);
        currentStatusIndicator.title = active ? "Нейросеть активна..." : "Нейросеть неактивна";
      }
      if (clonedStatusIndicator) { // Also update the cloned indicator if it exists (for mobile view)
        clonedStatusIndicator.classList.toggle("active", active);
        clonedStatusIndicator.title = active ? "Нейросеть активна..." : "Нейросеть неактивна";
      }
    }

  </script>

<script>
// Original (PC) settings content (from original file)
if (typeof window.originalSettingsHTML === 'undefined') {
  window.originalSettingsHTML = `
<fieldset class="fieldset-span-1"> <legend>🔌 Настройки API LLM (По умолчанию)</legend>
<label for="apiKey">Ключ API (LLM):</label>
<input aria-label="Ключ API LLM" autocomplete="off" id="apiKey" placeholder="Введите ваш API ключ" type="password"/>
<label for="apiUrl">URL API LLM:</label>
<input aria-label="URL LLM API" id="apiUrl" type="text" value="https://llm.chutes.ai/v1/chat/completions"/>
<label for="model">Модель LLM (по умолчанию):</label>
<input aria-label="Модель LLM" id="model" readonly="" type="text" value="deepseek-ai/DeepSeek-V3-0324"/>
<label for="temperature">Температура (0-1):</label>
<input aria-label="Температура LLM" id="temperature" placeholder="Например, 0.7" step="0.1" type="number" value="0.7"/>
<label for="maxTokens">Максимум токенов:</label>
<input aria-label="Максимум токенов LLM" id="maxTokens" placeholder="Например, 1024" type="number" value="1024"/>
</fieldset>
<fieldset class="fieldset-span-1">
<legend>🇬 Настройки Google Gemini API</legend>
<label for="googleApiKey">Ключ Google API:</label>
<input aria-label="Ключ Google API" autocomplete="off" id="googleApiKey" placeholder="Введите ваш Google API ключ" type="password"/>
<label for="googleApiModel">Модель Google Gemini:</label>
<select aria-label="Модель Google Gemini" id="googleApiModel"></select>
<div style="display: flex; align-items: center; margin-top: 0.5rem; gap: 10px;">
<label for="enableGoogleApi" style="font-weight: 500; margin-bottom: 0;">Использовать Google Gemini API:</label>
<label class="switch">
<input aria-label="Включить Google Gemini API" id="enableGoogleApi" type="checkbox"/>
<span class="slider round"></span>
</label>
</div>
</fieldset>
<fieldset>
<legend>🔗 Настройки REST API</legend>
<label for="restApiUrl">URL REST API:</label>
<input aria-label="URL REST API" id="restApiUrl" placeholder="URL конечной точки REST API" type="text"/>
<label for="restApiHeaders">Заголовки REST API (JSON):</label>
<textarea aria-label="Заголовки REST API (JSON)" id="restApiHeaders" placeholder='Пример: {"Authorization": "Bearer ВАШ_ТОКЕН"}'></textarea>
<div style="display: flex; align-items: center; margin-top: 0.5rem; gap: 10px;">
<label for="enableRestApi" style="font-weight: 500; margin-bottom: 0;">Использовать REST API:</label>
<label class="switch">
<input aria-label="Включить REST API" id="enableRestApi" type="checkbox">
<span class="slider round"></span>
</input></label>
</div>
</fieldset>
<fieldset>
<legend>👤 Основные настройки Персонажа</legend>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
<div>
<label for="characterSelect">Выбрать персонажа:</label>
<select aria-label="Выбор персонажа" disabled="" id="characterSelect"></select>
</div>
<div>
<label for="characterName">Имя персонажа:</label>
<input aria-label="Имя персонажа" id="characterName" placeholder="Введите имя персонажа" type="text"/>
</div>
</div>
<label for="characterModel">Модель для персонажа (если отличается):</label>
<input aria-label="Модель персонажа" id="characterModel" placeholder="Например, gpt-4-turbo или модель Gemini" type="text"/>
</fieldset>
<fieldset>
<legend>📝 Описание и личность</legend>
<label for="description">Описание (внешность, роль, цели):</label>
<textarea aria-label="Описание персонажа" id="description" placeholder="Описание роли, характера, предыстории..." style="min-height: 140px;"></textarea>
<label for="personality">Личность (черты характера):</label>
<textarea aria-label="Личность персонажа" id="personality" placeholder="Личность, манера речи, поведение..."></textarea>
</fieldset>
<fieldset>
<legend>📖 Сценарий и примеры диалога</legend>
<label for="scenario">Сценарий (мир, окружение):</label>
<textarea aria-label="Сценарий" id="scenario" placeholder="Описание мира, ситуации, сеттинга..."></textarea>
<label for="mes_example">Пример диалога:</label>
<textarea aria-label="Пример диалога" id="mes_example" placeholder="&lt;START&gt;\\nПример диалога для демонстрации стиля..." style="min-height: 140px;"></textarea>
</fieldset>
<fieldset>
<legend>👋 Приветствия</legend>
<label for="welcomeMessage">Основное приветствие:</label>
<textarea aria-label="Основное приветственное сообщение" id="welcomeMessage" placeholder="Сообщение от бота при начале чата"></textarea>
<!-- REMOVED: Alternative Greetings Input Field -->
</fieldset>
<fieldset>
<legend>⚙️ Дополнительные инструкции для ИИ</legend>
<label for="system_prompt">Системный промпт:</label>
<textarea aria-label="Системный промпт" id="system_prompt" placeholder="Глобальные инструкции для ИИ (system prompt)"></textarea>
<label for="post_history_instructions">Инструкции после истории:</label>
<textarea aria-label="Инструкции после истории" id="post_history_instructions" placeholder="Инструкции, которые вставляются после истории чата"></textarea>
<label for="creator_notes">Заметки создателя:</label>
<textarea aria-label="Заметки создателя" id="creator_notes" placeholder="Заметки от создателя персонажа"></textarea>
</fieldset>
<fieldset class="fieldset-span-1">
<legend>🎨 Настройки оформления</legend>
<div>
<label for="mainTextColor">Основной цвет текста:</label>
<input aria-label="Основной цвет текста" id="mainTextColor" type="color"/>
</div>
<div style="margin-top: 1rem;">
<label for="chatFontSize">Размер текста в чате: <span id="chatFontSizeIndicator">100%</span></label>
<input aria-label="Размер текста в чате" id="chatFontSize" max="1.5" min="0.8" step="0.05" type="range" value="1"/>
</div>
</fieldset>
<fieldset class="fieldset-span-1">
<legend>🖼️ Аватары</legend>
<div class="avatar-selection">
<button onclick="showAvatarOptions('link', 'character')" type="button">Аватар Персонажа: Ссылка</button>
<button onclick="showAvatarOptions('file', 'character')" type="button">Аватар Персонажа: Файл</button>
</div>
<div id="avatarLinkInput_character" style="display:none; margin-top: 0.5rem;">
<input aria-label="Ссылка на аватар персонажа" id="avatarUrl_character" placeholder="URL аватара персонажа" type="text"/>
</div>
<div id="avatarFileInputWrapper_character" style="display:none; margin-top: 0.5rem;">
<input accept="image/*" aria-label="Выбор файла аватара персонажа" id="avatarFileInput_character" type="file"/>
</div>
<div class="avatar-selection" style="margin-top: 1rem;">
<button onclick="showAvatarOptions('link', 'user')" type="button">Ваш Аватар: Ссылка</button>
<button onclick="showAvatarOptions('file', 'user')" type="button">Ваш Аватар: Файл</button>
</div>
<div id="avatarLinkInput_user" style="display:none; margin-top: 0.5rem;">
<input aria-label="Ссылка на ваш аватар" id="avatarUrl_user" placeholder="URL вашего аватара" type="text"/>
</div>
<div id="avatarFileInputWrapper_user" style="display:none; margin-top: 0.5rem;">
<input accept="image/*" aria-label="Выбор файла вашего аватара" id="avatarFileInput_user" type="file"/>
</div>
</fieldset>
<fieldset>
<legend>🧠 Память ИИ (Общая)</legend>
<textarea aria-label="Память нейросети" class="memory-box" id="neuralMemory" placeholder="Заметки и контекст, которые бот будет помнить глобально..." spellcheck="true"></textarea>
</fieldset>
<div style="grid-column: span 2; display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; margin-top:1rem;">
<button onclick="saveSettings()" type="button">💾 Сохранить/Обновить</button>
<button onclick="clearMessages()" style="background: #ffcdd2; color:#5f2120;" type="button">🗑️ Очистить чат</button>
<button onclick="exportCharacterData()" type="button">📤 Экспорт JSON</button>
<button onclick="importCharacterData()" type="button">📥 Импорт JSON</button>
<input accept=".json, .card" id="jsonFileInput" onchange="handleFileUpload(event)" style="display:none" type="file"/>
<button onclick="openLorebookModal()" type="button">📚 Lorebook</button>
<button onclick="openBackgroundModal()" type="button">🖼️ Фон чата</button>
</div>
`;
}

// Mobile (tabbed) settings content (from modified file)
const mobileSettingsHTML = `<div class="tab-buttons"><button class="active" onclick="openSettingsTab(1)" type="button">🔌 Настройки API LLM (По умолчанию)</button><button onclick="openSettingsTab(2)" type="button">🇬 Настройки Google Gemini API</button><button onclick="openSettingsTab(3)" type="button">🔗 Настройки REST API</button><button onclick="openSettingsTab(4)" type="button">👤 Основные настройки Персонажа</button><button onclick="openSettingsTab(5)" type="button">📝 Описание и личность</button><button onclick="openSettingsTab(6)" type="button">📖 Сценарий и примеры диалога</button><button onclick="openSettingsTab(7)" type="button">👋 Приветствия</button><button onclick="openSettingsTab(8)" type="button">⚙️ Дополнительные инструкции для ИИ</button><button onclick="openSettingsTab(9)" type="button">🎨 Настройки оформления</button><button onclick="openSettingsTab(10)" type="button">🖼️ Аватары</button><button onclick="openSettingsTab(11)" type="button">🧠 Память ИИ (Общая)</button></div><div class="tab-page active" id="settingsTab1"><fieldset class="fieldset-span-1"> <legend>🔌 Настройки API LLM (По умолчанию)</legend>
<label for="apiKey">Ключ API (LLM):</label>
<input aria-label="Ключ API LLM" autocomplete="off" id="apiKey" placeholder="Введите ваш API ключ" type="password"/>
<label for="apiUrl">URL API LLM:</label>
<input aria-label="URL LLM API" id="apiUrl" type="text" value="https://llm.chutes.ai/v1/chat/completions"/>
<label for="model">Модель LLM (по умолчанию):</label>
<input aria-label="Модель LLM" id="model" readonly="" type="text" value="deepseek-ai/DeepSeek-V3-0324"/>
<label for="temperature">Температура (0-1):</label>
<input aria-label="Температура LLM" id="temperature" placeholder="Например, 0.7" step="0.1" type="number" value="0.7"/>
<label for="maxTokens">Максимум токенов:</label>
<input aria-label="Максимум токенов LLM" id="maxTokens" placeholder="Например, 1024" type="number" value="1024"/>
</fieldset></div><div class="tab-page" id="settingsTab2"><fieldset class="fieldset-span-1">
<legend>🇬 Настройки Google Gemini API</legend>
<label for="googleApiKey">Ключ Google API:</label>
<input aria-label="Ключ Google API" autocomplete="off" id="googleApiKey" placeholder="Введите ваш Google API ключ" type="password"/>
<label for="googleApiModel">Модель Google Gemini:</label>
<select aria-label="Модель Google Gemini" id="googleApiModel"></select>
<div style="display: flex; align-items: center; margin-top: 0.5rem; gap: 10px;">
<label for="enableGoogleApi" style="font-weight: 500; margin-bottom: 0;">Использовать Google Gemini API:</label>
<label class="switch">
<input aria-label="Включить Google Gemini API" id="enableGoogleApi" type="checkbox"/>
<span class="slider round"></span>
</label>
</div>
</fieldset></div><div class="tab-page" id="settingsTab3"><fieldset>
<legend>🔗 Настройки REST API</legend>
<label for="restApiUrl">URL REST API:</label>
<input aria-label="URL REST API" id="restApiUrl" placeholder="URL конечной точки REST API" type="text"/>
<label for="restApiHeaders">Заголовки REST API (JSON):</label>
<textarea aria-label="Заголовки REST API (JSON)" id="restApiHeaders" placeholder='Пример: {"Authorization": "Bearer ВАШ_ТОКЕН"}'></textarea>
<div style="display: flex; align-items: center; margin-top: 0.5rem; gap: 10px;">
<label for="enableRestApi" style="font-weight: 500; margin-bottom: 0;">Использовать REST API:</label>
<label class="switch">
<input aria-label="Включить REST API" id="enableRestApi" type="checkbox"/>
<span class="slider round"></span>
</label>
</div>
</fieldset></div><div class="tab-page" id="settingsTab4"><fieldset>
<legend>👤 Основные настройки Персонажа</legend>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
<div>
<label for="characterSelect">Выбрать персонажа:</label>
<select aria-label="Выбор персонажа" disabled="" id="characterSelect"></select>
</div>
<div>
<label for="characterName">Имя персонажа:</label>
<input aria-label="Имя персонажа" id="characterName" placeholder="Введите имя персонажа" type="text"/>
</div>
</div>
<label for="characterModel">Модель для персонажа (если отличается):</label>
<input aria-label="Модель персонажа" id="characterModel" placeholder="Например, gpt-4-turbo или модель Gemini" type="text"/>
</fieldset></div><div class="tab-page" id="settingsTab5"><fieldset>
<legend>📝 Описание и личность</legend>
<label for="description">Описание (внешность, роль, цели):</label>
<textarea aria-label="Описание персонажа" id="description" placeholder="Описание роли, характера, предыстории..." style="min-height: 140px;"></textarea>
<label for="personality">Личность (черты характера):</label>
<textarea aria-label="Личность персонажа" id="personality" placeholder="Личность, манера речи, поведение..."></textarea>
</fieldset></div><div class="tab-page" id="settingsTab6"><fieldset>
<legend>📖 Сценарий и примеры диалога</legend>
<label for="scenario">Сценарий (мир, окружение):</label>
<textarea aria-label="Сценарий" id="scenario" placeholder="Описание мира, ситуации, сеттинга..."></textarea>
<label for="mes_example">Пример диалога:</label>
<textarea aria-label="Пример диалога" id="mes_example" placeholder="&lt;START&gt;\\nПример диалога для демонстрации стиля..." style="min-height: 140px;"></textarea>
</fieldset></div><div class="tab-page" id="settingsTab7"><fieldset>
<legend>👋 Приветствия</legend>
<label for="welcomeMessage">Основное приветствие:</label>
<textarea aria-label="Основное приветственное сообщение" id="welcomeMessage" placeholder="Сообщение от бота при начале чата"></textarea>
<!-- REMOVED: Alternative Greetings Input Field -->
</fieldset></div><div class="tab-page" id="settingsTab8"><fieldset>
<legend>⚙️ Дополнительные инструкции для ИИ</legend>
<label for="system_prompt">Системный промпт:</label>
<textarea aria-label="Системный промпт" id="system_prompt" placeholder="Глобальные инструкции для ИИ (system prompt)"></textarea>
<label for="post_history_instructions">Инструкции после истории:</label>
<textarea aria-label="Инструкции после истории" id="post_history_instructions" placeholder="Инструкции, которые вставляются после истории чата"></textarea>
<label for="creator_notes">Заметки создателя:</label>
<textarea aria-label="Заметки создателя" id="creator_notes" placeholder="Заметки от создателя персонажа"></textarea>
</fieldset></div><div class="tab-page" id="settingsTab9"><fieldset class="fieldset-span-1">
<legend>🎨 Настройки оформления</legend>
<div>
<label for="mainTextColor">Основной цвет текста:</label>
<input aria-label="Основной цвет текста" id="mainTextColor" type="color"/>
</div>
<div style="margin-top: 1rem;">
<label for="chatFontSize">Размер текста в чате: <span id="chatFontSizeIndicator">100%</span></label>
<input aria-label="Размер текста в чате" id="chatFontSize" max="1.5" min="0.8" step="0.05" type="range" value="1"/>
</div>
</fieldset></div><div class="tab-page" id="settingsTab10"><fieldset class="fieldset-span-1">
<legend>🖼️ Аватары</legend>
<div class="avatar-selection">
<button onclick="showAvatarOptions('link', 'character')" type="button">Аватар Персонажа: Ссылка</button>
<button onclick="showAvatarOptions('file', 'character')" type="button">Аватар Персонажа: Файл</button>
</div>
<div id="avatarLinkInput_character" style="display:none; margin-top: 0.5rem;">
<input aria-label="Ссылка на аватар персонажа" id="avatarUrl_character" placeholder="URL аватара персонажа" type="text"/>
</div>
<div id="avatarFileInputWrapper_character" style="display:none; margin-top: 0.5rem;">
<input accept="image/*" aria-label="Выбор файла аватара персонажа" id="avatarFileInput_character" type="file"/>
</div>
<div class="avatar-selection" style="margin-top: 1rem;">
<button onclick="showAvatarOptions('link', 'user')" type="button">Ваш Аватар: Ссылка</button>
<button onclick="showAvatarOptions('file', 'user')" type="button">Ваш Аватар: Файл</button>
</div>
<div id="avatarLinkInput_user" style="display:none; margin-top: 0.5rem;">
<input aria-label="Ссылка на ваш аватар" id="avatarUrl_user" placeholder="URL вашего аватара" type="text"/>
</div>
<div id="avatarFileInputWrapper_user" style="display:none; margin-top: 0.5rem;">
<input accept="image/*" aria-label="Выбор файла вашего аватара" id="avatarFileInput_user" type="file"/>
</div>
</fieldset></div><div class="tab-page" id="settingsTab11"><fieldset>
<legend>🧠 Память ИИ (Общая)</legend>
<textarea aria-label="Память нейросети" class="memory-box" id="neuralMemory" placeholder="Заметки и контекст, которые бот будет помнить глобально..." spellcheck="true"></textarea>
</fieldset></div>`;

function applySettingsLayout() {
  const container = document.getElementById('settingsSection');
  if(!container) return;
  const w = window.innerWidth || document.documentElement.clientWidth;
  if (w > 900) {
    // PC: restore original layout (if not already)
    if (container.innerHTML.trim() !== originalSettingsHTML.trim()) {
      container.innerHTML = originalSettingsHTML;
      // reattach any JS bindings if needed (basic)
      if (typeof initSettingsBindings === 'function') initSettingsBindings();
    }
    // hide mobile tab buttons if any exist
    const tb = document.querySelectorAll('.settings-content .tab-buttons');
    tb.forEach(b => b.style.display = 'none');
  } else {
    // Mobile: use tabbed layout (if not already)
    if (container.innerHTML.trim() !== mobileSettingsHTML.trim()) {
      container.innerHTML = mobileSettingsHTML;
      // ensure first tab active
      const btns = container.querySelectorAll('.tab-buttons button');
      if (btns && btns.length > 0) btns[0].classList.add('active');
      // run mobile tab initializer if exists
      if (typeof initMobileTabs === 'function') initMobileTabs();
      if (typeof initSettingsBindings === 'function') initSettingsBindings();
    }
    // show mobile tab buttons
    const tb = document.querySelectorAll('.settings-content .tab-buttons');
    tb.forEach(b => b.style.display = 'flex');
  }
}

// helper in case other functions need to rebind
function initMobileTabs() {
  // ensure openSettingsTab exists
  if (typeof openSettingsTab !== 'function') return;
  // activate first tab
  const btns = document.querySelectorAll('.settings-content .tab-buttons button');
  if (btns.length) btns.forEach((b,i)=> b.classList.toggle('active', i===0));
  const pages = document.querySelectorAll('.settings-content .tab-page');
  pages.forEach((p,i)=> p.classList.toggle('active', i===0));
}

// expose a simple initializer for other scripts
function initSettingsBindings() {
  // nothing heavy for now; placeholder to reattach event handlers if needed
}

// switch on load and resize
window.addEventListener('DOMContentLoaded', applySettingsLayout);
window.addEventListener('resize', applySettingsLayout);
</script>

<script>
(function(){
  const modalIds = ['settingsModal','lorebookModal','backgroundModal','greetingSelectModal','clearChatConfirmModal'];
  function addShowClass(modal) {
    if (!modal) return;
    modal.classList.add('modal-show');
  }
  function removeShowClass(modal) {
    if (!modal) return;
    modal.classList.remove('modal-show');
  }

  // Wrap original open/close functions if present to toggle modal-show reliably.
  modalIds.forEach(id => {
    const modal = document.getElementById(id);
    if (!modal) return;
    // If modal.style.display used by code, ensure it's set to 'flex' only when showing
    // We'll observe mutations on style attribute to sync modal-show class.
    const mo = new MutationObserver((mutations) => {
      for (const m of mutations) {
        if (m.attributeName === 'style') {
          const display = modal.style.display;
          if (display && display.indexOf('flex') !== -1) {
            // show requested by existing code -> add class so animation occurs
            addShowClass(modal);
          } else if (display === 'none' || display === '') {
            // existing code hid it -> remove class to allow fade-out
            removeShowClass(modal);
          }
        }
      }
    });
    mo.observe(modal, { attributes: true, attributeFilter: ['style'] });

    // Also listen for transitionend on opacity to set display none if not shown
    modal.addEventListener('transitionend', (e) => {
      if (e.propertyName !== 'opacity') return;
      if (!modal.classList.contains('modal-show')) {
        // ensure it's not intercepting pointer events after fade-out
        modal.style.display = 'none';
      } else {
        // ensure display is flex when visible
        modal.style.display = 'flex';
      }
    });
    // initialize: if currently style.display flex -> add class, else ensure display none
    if (modal.style.display && modal.style.display.indexOf('flex') !== -1) {
      addShowClass(modal);
    } else {
      modal.style.display = 'none';
      removeShowClass(modal);
    }
  });

  // Additionally, prevent rapid repeated opening by attaching a delegation handler on document
  document.addEventListener('click', function(e){
    const target = e.target;
    // block clicks that try to open multiple confirm boxes by detecting data-action attributes too
    const openSelectors = ['toggleSettingsBtn','toggleLorebookBtn','toggleBackgroundBtn','toggleGreetingBtn'];
    for (const id of openSelectors) {
      if (target.closest && target.closest('#'+id)) {
        const modalId = id === 'toggleSettingsBtn' ? 'settingsModal' :
                        id === 'toggleLorebookBtn' ? 'lorebookModal' :
                        id === 'toggleBackgroundBtn' ? 'backgroundModal' :
                        id === 'toggleGreetingBtn' ? 'greetingSelectModal' : null;
        if (!modalId) return;
        const modal = document.getElementById(modalId);
        if (!modal) return;
        // If already visible or in transition, stop propagation to prevent other handlers firing duplicates
        if (modal.classList.contains('modal-show') || modal.dataset.animating === '1') {
          e.stopPropagation();
          e.preventDefault();
          return;
        }
        // mark animating briefly to avoid duplicate triggers
        modal.dataset.animating = '1';
        setTimeout(() => { delete modal.dataset.animating; }, 500);
      }
    }
  }, true);

})();</script>
<!-- END IMPORTED MODAL SCRIPTS -->



<!-- LOCALSTORAGE_MAXTOKENS_TEMPERATURE_INJECTED -->
<script>
// Robust persistence for Max Tokens and Temperature (handles both "maxTokens" and "max-tokens" ids, dynamic re-renders)
// Saves to localStorage keys: 'maxTokens' and 'temperature'
(function(){
  const ID_CANDIDATES = ['maxTokens','max-tokens'];
  const TEMP_ID_CANDIDATES = ['temperature','temp','tempurature']; // include common typos as fallback

  function findEl(candidates){
    for(const id of candidates){
      const el = document.getElementById(id);
      if(el) return el;
    }
    return null;
  }

  function attach(el, keyName){
    if(!el) return;
    if(el.__charis_persist_attached) return;
    const save = () => { try { localStorage.setItem(keyName, el.value); } catch(e){ console.warn('localStorage set error', e); } };
    el.addEventListener('input', save);
    el.addEventListener('change', save);
    el.__charis_persist_attached = true;
  }

  function restoreIfNeeded(){
    try {
      const maxEl = findEl(ID_CANDIDATES);
      const tempEl = findEl(TEMP_ID_CANDIDATES);

      const sMax = localStorage.getItem('maxTokens');
      const sTemp = localStorage.getItem('temperature');

      if (sMax !== null && maxEl) {
        // Only set if different to avoid clobbering dynamic defaults immediately
        if (maxEl.value !== sMax) maxEl.value = sMax;
      }
      if (sTemp !== null && tempEl) {
        if (tempEl.value !== sTemp) tempEl.value = sTemp;
      }

      // attach listeners
      if (maxEl) attach(maxEl, 'maxTokens');
      if (tempEl) attach(tempEl, 'temperature');
      return !!(maxEl || tempEl);
    } catch(e){ console.warn('restoreIfNeeded error', e); return false; }
  }

  // Try restore right away
  if (!restoreIfNeeded()) {
    // If elements are not present yet (dynamic render), observe DOM for them
    const obs = new MutationObserver((mutations, observer) => {
      if (restoreIfNeeded()) {
        // once attached, disconnect observer after short delay to avoid overhead
        setTimeout(()=>observer.disconnect(), 3000);
      }
    });
    obs.observe(document.documentElement || document.body, { childList: true, subtree: true });
    // Also try again on window load
    window.addEventListener('load', () => { restoreIfNeeded(); setTimeout(()=>obs.disconnect(), 3000); });
  }

  // Expose helper API
  window.__charis_settings_persistence = Object.assign(window.__charis_settings_persistence || {}, {
    saveNow: function(){ try{ const maxEl = findEl(ID_CANDIDATES); const tempEl = findEl(TEMP_ID_CANDIDATES); if(maxEl) localStorage.setItem('maxTokens', maxEl.value); if(tempEl) localStorage.setItem('temperature', tempEl.value); }catch(e){console.warn(e);} },
    restoreNow: function(){ try{ restoreIfNeeded(); }catch(e){console.warn(e);} },
    clear: function(){ try{ localStorage.removeItem('maxTokens'); localStorage.removeItem('temperature'); }catch(e){console.warn(e);} }
  });
})();
</script>



<!-- === Chat History Safe-Save Patch === -->
<script>
(function() {
    function safeSetItem(key, value) {
        try {
            localStorage.setItem(key, value);
        } catch (e) {
            console.warn("⚠ История не сохранена: превышен лимит памяти.", e);
        }
    }

    // Перехват сохранения сообщений
    window.saveChatHistory = function(messages) {
        const cleaned = messages.map(msg => {
            if (msg.attachments) {
                msg.attachments = msg.attachments.map(file => {
                    if (file.data && file.data.length > 50000) { // base64 слишком длинный
                        const blob = new Blob([file.data], { type: file.type || "application/octet-stream" });
                        const url = URL.createObjectURL(blob);
                        return {
                            name: file.name,
                            type: file.type,
                            size: file.size,
                            previewUrl: url // сохраняем ссылку вместо base64
                        };
                    }
                    return file;
                });
            }
            return msg;
        });
        safeSetItem("chatHistory", JSON.stringify(cleaned));
    };
})();
</script>
<!-- === End Patch === -->

</body>
</html>
